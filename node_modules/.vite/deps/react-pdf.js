import {
  require_jsx_runtime
} from "./chunk-BB2JS7EP.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __toESM,
  require_react
} from "./chunk-IAT5SZDQ.js";

// node_modules/warning/warning.js
var require_warning = __commonJS({
  "node_modules/warning/warning.js"(exports, module) {
    "use strict";
    var __DEV__ = true;
    var warning9 = function() {
    };
    if (__DEV__) {
      printWarning = function printWarning2(format, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for (var key = 1; key < len; key++) {
          args[key - 1] = arguments[key];
        }
        var argIndex = 0;
        var message = "Warning: " + format.replace(/%s/g, function() {
          return args[argIndex++];
        });
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
      warning9 = function(condition, format, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++) {
          args[key - 2] = arguments[key];
        }
        if (format === void 0) {
          throw new Error(
            "`warning(condition, format, ...args)` requires a warning message argument"
          );
        }
        if (!condition) {
          printWarning.apply(null, [format].concat(args));
        }
      };
    }
    var printWarning;
    module.exports = warning9;
  }
});

// node_modules/pdfjs-dist/build/pdf.mjs
var pdf_exports = {};
__export(pdf_exports, {
  AbortException: () => AbortException,
  AnnotationEditorLayer: () => AnnotationEditorLayer,
  AnnotationEditorParamsType: () => AnnotationEditorParamsType,
  AnnotationEditorType: () => AnnotationEditorType,
  AnnotationEditorUIManager: () => AnnotationEditorUIManager,
  AnnotationLayer: () => AnnotationLayer,
  AnnotationMode: () => AnnotationMode,
  AnnotationType: () => AnnotationType,
  CSSConstants: () => CSSConstants,
  ColorPicker: () => ColorPicker,
  DOMSVGFactory: () => DOMSVGFactory,
  DrawLayer: () => DrawLayer,
  FeatureTest: () => util_FeatureTest,
  GlobalWorkerOptions: () => GlobalWorkerOptions,
  ImageKind: () => util_ImageKind,
  InvalidPDFException: () => InvalidPDFException,
  MathClamp: () => MathClamp,
  OPS: () => OPS,
  OutputScale: () => OutputScale,
  PDFDataRangeTransport: () => PDFDataRangeTransport,
  PDFDateString: () => PDFDateString,
  PDFWorker: () => PDFWorker,
  PasswordResponses: () => PasswordResponses,
  PermissionFlag: () => PermissionFlag,
  PixelsPerInch: () => PixelsPerInch,
  RenderingCancelledException: () => RenderingCancelledException,
  ResponseException: () => ResponseException,
  SignatureExtractor: () => SignatureExtractor,
  SupportedImageMimeTypes: () => SupportedImageMimeTypes,
  TextLayer: () => TextLayer,
  TouchManager: () => TouchManager,
  Util: () => Util,
  VerbosityLevel: () => VerbosityLevel,
  XfaLayer: () => XfaLayer,
  applyOpacity: () => applyOpacity,
  build: () => build,
  createValidAbsoluteUrl: () => createValidAbsoluteUrl,
  fetchData: () => fetchData,
  findContrastColor: () => findContrastColor,
  getDocument: () => getDocument,
  getFilenameFromUrl: () => getFilenameFromUrl,
  getPdfFilenameFromUrl: () => getPdfFilenameFromUrl,
  getRGB: () => getRGB,
  getUuid: () => getUuid,
  getXfaPageViewport: () => getXfaPageViewport,
  isDataScheme: () => isDataScheme,
  isPdfFile: () => isPdfFile,
  isValidExplicitDest: () => isValidExplicitDest,
  noContextMenu: () => noContextMenu,
  normalizeUnicode: () => normalizeUnicode,
  renderRichText: () => renderRichText,
  setLayerDimensions: () => setLayerDimensions,
  shadow: () => shadow,
  stopEvent: () => stopEvent,
  updateUrlHash: () => updateUrlHash,
  version: () => version
});
var __webpack_require__ = {};
(() => {
  __webpack_require__.d = (exports, definition) => {
    for (var key in definition) {
      if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
        Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
      }
    }
  };
})();
(() => {
  __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
})();
var isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
var FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
var LINE_FACTOR = 1.35;
var LINE_DESCENT_FACTOR = 0.35;
var BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;
var RenderingIntentFlag = {
  ANY: 1,
  DISPLAY: 2,
  PRINT: 4,
  SAVE: 8,
  ANNOTATIONS_FORMS: 16,
  ANNOTATIONS_STORAGE: 32,
  ANNOTATIONS_DISABLE: 64,
  IS_EDITING: 128,
  OPLIST: 256
};
var AnnotationMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
};
var AnnotationEditorPrefix = "pdfjs_internal_editor_";
var AnnotationEditorType = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  HIGHLIGHT: 9,
  STAMP: 13,
  INK: 15,
  POPUP: 16,
  SIGNATURE: 101,
  COMMENT: 102
};
var AnnotationEditorParamsType = {
  RESIZE: 1,
  CREATE: 2,
  FREETEXT_SIZE: 11,
  FREETEXT_COLOR: 12,
  FREETEXT_OPACITY: 13,
  INK_COLOR: 21,
  INK_THICKNESS: 22,
  INK_OPACITY: 23,
  HIGHLIGHT_COLOR: 31,
  HIGHLIGHT_THICKNESS: 32,
  HIGHLIGHT_FREE: 33,
  HIGHLIGHT_SHOW_ALL: 34,
  DRAW_STEP: 41
};
var PermissionFlag = {
  PRINT: 4,
  MODIFY_CONTENTS: 8,
  COPY: 16,
  MODIFY_ANNOTATIONS: 32,
  FILL_INTERACTIVE_FORMS: 256,
  COPY_FOR_ACCESSIBILITY: 512,
  ASSEMBLE: 1024,
  PRINT_HIGH_QUALITY: 2048
};
var TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
var util_ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
var AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
var AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
var VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
var OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91,
  setStrokeTransparent: 92,
  setFillTransparent: 93,
  rawFillPath: 94
};
var DrawOPS = {
  moveTo: 0,
  lineTo: 1,
  curveTo: 2,
  closePath: 3
};
var PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
var verbosity = VerbosityLevel.WARNINGS;
function setVerbosityLevel(level) {
  if (Number.isInteger(level)) {
    verbosity = level;
  }
}
function getVerbosityLevel() {
  return verbosity;
}
function info(msg) {
  if (verbosity >= VerbosityLevel.INFOS) {
    console.info(`Info: ${msg}`);
  }
}
function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.warn(`Warning: ${msg}`);
  }
}
function unreachable(msg) {
  throw new Error(msg);
}
function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}
function _isValidProtocol(url) {
  switch (url == null ? void 0 : url.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return true;
    default:
      return false;
  }
}
function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
  if (!url) {
    return null;
  }
  if (options && typeof url === "string") {
    if (options.addDefaultProtocol && url.startsWith("www.")) {
      const dots = url.match(/\./g);
      if ((dots == null ? void 0 : dots.length) >= 2) {
        url = `http://${url}`;
      }
    }
    if (options.tryConvertEncoding) {
      try {
        url = stringToUTF8String(url);
      } catch {
      }
    }
  }
  const absoluteUrl = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);
  return _isValidProtocol(absoluteUrl) ? absoluteUrl : null;
}
function updateUrlHash(url, hash, allowRel = false) {
  const res = URL.parse(url);
  if (res) {
    res.hash = hash;
    return res.href;
  }
  if (allowRel && createValidAbsoluteUrl(url, "http://example.com")) {
    return url.split("#", 1)[0] + `${hash ? `#${hash}` : ""}`;
  }
  return "";
}
function shadow(obj, prop, value, nonSerializable = false) {
  Object.defineProperty(obj, prop, {
    value,
    enumerable: !nonSerializable,
    configurable: true,
    writable: false
  });
  return value;
}
var BaseException = function BaseExceptionClosure() {
  function BaseException2(message, name) {
    this.message = message;
    this.name = name;
  }
  BaseException2.prototype = new Error();
  BaseException2.constructor = BaseException2;
  return BaseException2;
}();
var PasswordException = class extends BaseException {
  constructor(msg, code) {
    super(msg, "PasswordException");
    this.code = code;
  }
};
var UnknownErrorException = class extends BaseException {
  constructor(msg, details) {
    super(msg, "UnknownErrorException");
    this.details = details;
  }
};
var InvalidPDFException = class extends BaseException {
  constructor(msg) {
    super(msg, "InvalidPDFException");
  }
};
var ResponseException = class extends BaseException {
  constructor(msg, status, missing) {
    super(msg, "ResponseException");
    this.status = status;
    this.missing = missing;
  }
};
var FormatError = class extends BaseException {
  constructor(msg) {
    super(msg, "FormatError");
  }
};
var AbortException = class extends BaseException {
  constructor(msg) {
    super(msg, "AbortException");
  }
};
function bytesToString(bytes) {
  if (typeof bytes !== "object" || (bytes == null ? void 0 : bytes.length) === void 0) {
    unreachable("Invalid argument for bytesToString");
  }
  const length = bytes.length;
  const MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  const strBuf = [];
  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    const chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  return strBuf.join("");
}
function stringToBytes(str) {
  if (typeof str !== "string") {
    unreachable("Invalid argument for stringToBytes");
  }
  const length = str.length;
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 255;
  }
  return bytes;
}
function string32(value) {
  return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
}
function isLittleEndian() {
  const buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}
function isEvalSupported() {
  try {
    new Function("");
    return true;
  } catch {
    return false;
  }
}
var util_FeatureTest = class {
  static get isLittleEndian() {
    return shadow(this, "isLittleEndian", isLittleEndian());
  }
  static get isEvalSupported() {
    return shadow(this, "isEvalSupported", isEvalSupported());
  }
  static get isOffscreenCanvasSupported() {
    return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
  }
  static get isImageDecoderSupported() {
    return shadow(this, "isImageDecoderSupported", typeof ImageDecoder !== "undefined");
  }
  static get platform() {
    const {
      platform,
      userAgent
    } = navigator;
    return shadow(this, "platform", {
      isAndroid: userAgent.includes("Android"),
      isLinux: platform.includes("Linux"),
      isMac: platform.includes("Mac"),
      isWindows: platform.includes("Win"),
      isFirefox: userAgent.includes("Firefox")
    });
  }
  static get isCSSRoundSupported() {
    var _a2, _b;
    return shadow(this, "isCSSRoundSupported", (_b = (_a2 = globalThis.CSS) == null ? void 0 : _a2.supports) == null ? void 0 : _b.call(_a2, "width: round(1.5px, 1px)"));
  }
};
var hexNumbers = Array.from(Array(256).keys(), (n) => n.toString(16).padStart(2, "0"));
var _getExtremumOnCurve, getExtremumOnCurve_fn, _getExtremum, getExtremum_fn;
var Util = class {
  static makeHexColor(r2, g, b) {
    return `#${hexNumbers[r2]}${hexNumbers[g]}${hexNumbers[b]}`;
  }
  static domMatrixToTransform(dm) {
    return [dm.a, dm.b, dm.c, dm.d, dm.e, dm.f];
  }
  static scaleMinMax(transform, minMax) {
    let temp;
    if (transform[0]) {
      if (transform[0] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[2];
        minMax[2] = temp;
      }
      minMax[0] *= transform[0];
      minMax[2] *= transform[0];
      if (transform[3] < 0) {
        temp = minMax[1];
        minMax[1] = minMax[3];
        minMax[3] = temp;
      }
      minMax[1] *= transform[3];
      minMax[3] *= transform[3];
    } else {
      temp = minMax[0];
      minMax[0] = minMax[1];
      minMax[1] = temp;
      temp = minMax[2];
      minMax[2] = minMax[3];
      minMax[3] = temp;
      if (transform[1] < 0) {
        temp = minMax[1];
        minMax[1] = minMax[3];
        minMax[3] = temp;
      }
      minMax[1] *= transform[1];
      minMax[3] *= transform[1];
      if (transform[2] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[2];
        minMax[2] = temp;
      }
      minMax[0] *= transform[2];
      minMax[2] *= transform[2];
    }
    minMax[0] += transform[4];
    minMax[1] += transform[5];
    minMax[2] += transform[4];
    minMax[3] += transform[5];
  }
  static transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  }
  static multiplyByDOMMatrix(m, md) {
    return [m[0] * md.a + m[2] * md.b, m[1] * md.a + m[3] * md.b, m[0] * md.c + m[2] * md.d, m[1] * md.c + m[3] * md.d, m[0] * md.e + m[2] * md.f + m[4], m[1] * md.e + m[3] * md.f + m[5]];
  }
  static applyTransform(p, m, pos = 0) {
    const p0 = p[pos];
    const p1 = p[pos + 1];
    p[pos] = p0 * m[0] + p1 * m[2] + m[4];
    p[pos + 1] = p0 * m[1] + p1 * m[3] + m[5];
  }
  static applyTransformToBezier(p, transform, pos = 0) {
    const m0 = transform[0];
    const m1 = transform[1];
    const m2 = transform[2];
    const m3 = transform[3];
    const m4 = transform[4];
    const m5 = transform[5];
    for (let i = 0; i < 6; i += 2) {
      const pI = p[pos + i];
      const pI1 = p[pos + i + 1];
      p[pos + i] = pI * m0 + pI1 * m2 + m4;
      p[pos + i + 1] = pI * m1 + pI1 * m3 + m5;
    }
  }
  static applyInverseTransform(p, m) {
    const p0 = p[0];
    const p1 = p[1];
    const d = m[0] * m[3] - m[1] * m[2];
    p[0] = (p0 * m[3] - p1 * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    p[1] = (-p0 * m[1] + p1 * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
  }
  static axialAlignedBoundingBox(rect, transform, output) {
    const m0 = transform[0];
    const m1 = transform[1];
    const m2 = transform[2];
    const m3 = transform[3];
    const m4 = transform[4];
    const m5 = transform[5];
    const r0 = rect[0];
    const r1 = rect[1];
    const r2 = rect[2];
    const r3 = rect[3];
    let a0 = m0 * r0 + m4;
    let a2 = a0;
    let a1 = m0 * r2 + m4;
    let a3 = a1;
    let b0 = m3 * r1 + m5;
    let b2 = b0;
    let b1 = m3 * r3 + m5;
    let b3 = b1;
    if (m1 !== 0 || m2 !== 0) {
      const m1r0 = m1 * r0;
      const m1r2 = m1 * r2;
      const m2r1 = m2 * r1;
      const m2r3 = m2 * r3;
      a0 += m2r1;
      a3 += m2r1;
      a1 += m2r3;
      a2 += m2r3;
      b0 += m1r0;
      b3 += m1r0;
      b1 += m1r2;
      b2 += m1r2;
    }
    output[0] = Math.min(output[0], a0, a1, a2, a3);
    output[1] = Math.min(output[1], b0, b1, b2, b3);
    output[2] = Math.max(output[2], a0, a1, a2, a3);
    output[3] = Math.max(output[3], b0, b1, b2, b3);
  }
  static inverseTransform(m) {
    const d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  }
  static singularValueDecompose2dScale(matrix, output) {
    const m0 = matrix[0];
    const m1 = matrix[1];
    const m2 = matrix[2];
    const m3 = matrix[3];
    const a = m0 ** 2 + m1 ** 2;
    const b = m0 * m2 + m1 * m3;
    const c = m2 ** 2 + m3 ** 2;
    const first = (a + c) / 2;
    const second = Math.sqrt(first ** 2 - (a * c - b ** 2));
    output[0] = Math.sqrt(first + second || 1);
    output[1] = Math.sqrt(first - second || 1);
  }
  static normalizeRect(rect) {
    const r2 = rect.slice(0);
    if (rect[0] > rect[2]) {
      r2[0] = rect[2];
      r2[2] = rect[0];
    }
    if (rect[1] > rect[3]) {
      r2[1] = rect[3];
      r2[3] = rect[1];
    }
    return r2;
  }
  static intersect(rect1, rect2) {
    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
    if (xLow > xHigh) {
      return null;
    }
    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
    if (yLow > yHigh) {
      return null;
    }
    return [xLow, yLow, xHigh, yHigh];
  }
  static pointBoundingBox(x, y, minMax) {
    minMax[0] = Math.min(minMax[0], x);
    minMax[1] = Math.min(minMax[1], y);
    minMax[2] = Math.max(minMax[2], x);
    minMax[3] = Math.max(minMax[3], y);
  }
  static rectBoundingBox(x0, y0, x1, y1, minMax) {
    minMax[0] = Math.min(minMax[0], x0, x1);
    minMax[1] = Math.min(minMax[1], y0, y1);
    minMax[2] = Math.max(minMax[2], x0, x1);
    minMax[3] = Math.max(minMax[3], y0, y1);
  }
  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
    minMax[0] = Math.min(minMax[0], x0, x3);
    minMax[1] = Math.min(minMax[1], y0, y3);
    minMax[2] = Math.max(minMax[2], x0, x3);
    minMax[3] = Math.max(minMax[3], y0, y3);
    __privateMethod(this, _getExtremum, getExtremum_fn).call(this, x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);
    __privateMethod(this, _getExtremum, getExtremum_fn).call(this, x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);
  }
};
_getExtremumOnCurve = new WeakSet();
getExtremumOnCurve_fn = function(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {
  if (t <= 0 || t >= 1) {
    return;
  }
  const mt = 1 - t;
  const tt = t * t;
  const ttt = tt * t;
  const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;
  const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;
  minMax[0] = Math.min(minMax[0], x);
  minMax[1] = Math.min(minMax[1], y);
  minMax[2] = Math.max(minMax[2], x);
  minMax[3] = Math.max(minMax[3], y);
};
_getExtremum = new WeakSet();
getExtremum_fn = function(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {
  if (Math.abs(a) < 1e-12) {
    if (Math.abs(b) >= 1e-12) {
      __privateMethod(this, _getExtremumOnCurve, getExtremumOnCurve_fn).call(this, x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);
    }
    return;
  }
  const delta = b ** 2 - 4 * c * a;
  if (delta < 0) {
    return;
  }
  const sqrtDelta = Math.sqrt(delta);
  const a2 = 2 * a;
  __privateMethod(this, _getExtremumOnCurve, getExtremumOnCurve_fn).call(this, x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);
  __privateMethod(this, _getExtremumOnCurve, getExtremumOnCurve_fn).call(this, x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);
};
__privateAdd(Util, _getExtremumOnCurve);
__privateAdd(Util, _getExtremum);
function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}
var NormalizeRegex = null;
var NormalizationMap = null;
function normalizeUnicode(str) {
  if (!NormalizeRegex) {
    NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
    NormalizationMap = /* @__PURE__ */ new Map([["ﬅ", "ſt"]]);
  }
  return str.replaceAll(NormalizeRegex, (_, p1, p2) => p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2));
}
function getUuid() {
  if (typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }
  const buf = new Uint8Array(32);
  crypto.getRandomValues(buf);
  return bytesToString(buf);
}
var AnnotationPrefix = "pdfjs_internal_id_";
function _isValidExplicitDest(validRef, validName, dest) {
  if (!Array.isArray(dest) || dest.length < 2) {
    return false;
  }
  const [page, zoom, ...args] = dest;
  if (!validRef(page) && !Number.isInteger(page)) {
    return false;
  }
  if (!validName(zoom)) {
    return false;
  }
  const argsLen = args.length;
  let allowNull = true;
  switch (zoom.name) {
    case "XYZ":
      if (argsLen < 2 || argsLen > 3) {
        return false;
      }
      break;
    case "Fit":
    case "FitB":
      return argsLen === 0;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (argsLen > 1) {
        return false;
      }
      break;
    case "FitR":
      if (argsLen !== 4) {
        return false;
      }
      allowNull = false;
      break;
    default:
      return false;
  }
  for (const arg of args) {
    if (typeof arg === "number" || allowNull && arg === null) {
      continue;
    }
    return false;
  }
  return true;
}
function MathClamp(v, min, max) {
  return Math.min(Math.max(v, min), max);
}
function toBase64Util(arr) {
  if (Uint8Array.prototype.toBase64) {
    return arr.toBase64();
  }
  return btoa(bytesToString(arr));
}
function fromBase64Util(str) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(str);
  }
  return stringToBytes(atob(str));
}
if (typeof Promise.try !== "function") {
  Promise.try = function(fn, ...args) {
    return new Promise((resolve) => {
      resolve(fn(...args));
    });
  };
}
if (typeof Math.sumPrecise !== "function") {
  Math.sumPrecise = function(numbers) {
    return numbers.reduce((a, b) => a + b, 0);
  };
}
var XfaText = class _XfaText {
  static textContent(xfa) {
    const items = [];
    const output = {
      items,
      styles: /* @__PURE__ */ Object.create(null)
    };
    function walk(node) {
      var _a2;
      if (!node) {
        return;
      }
      let str = null;
      const name = node.name;
      if (name === "#text") {
        str = node.value;
      } else if (!_XfaText.shouldBuildText(name)) {
        return;
      } else if ((_a2 = node == null ? void 0 : node.attributes) == null ? void 0 : _a2.textContent) {
        str = node.attributes.textContent;
      } else if (node.value) {
        str = node.value;
      }
      if (str !== null) {
        items.push({
          str
        });
      }
      if (!node.children) {
        return;
      }
      for (const child of node.children) {
        walk(child);
      }
    }
    walk(xfa);
    return output;
  }
  static shouldBuildText(name) {
    return !(name === "textarea" || name === "input" || name === "option" || name === "select");
  }
};
var XfaLayer = class {
  static setupStorage(html, id, element, storage, intent) {
    const storedData = storage.getValue(id, {
      value: null
    });
    switch (element.name) {
      case "textarea":
        if (storedData.value !== null) {
          html.textContent = storedData.value;
        }
        if (intent === "print") {
          break;
        }
        html.addEventListener("input", (event) => {
          storage.setValue(id, {
            value: event.target.value
          });
        });
        break;
      case "input":
        if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
          if (storedData.value === element.attributes.xfaOn) {
            html.setAttribute("checked", true);
          } else if (storedData.value === element.attributes.xfaOff) {
            html.removeAttribute("checked");
          }
          if (intent === "print") {
            break;
          }
          html.addEventListener("change", (event) => {
            storage.setValue(id, {
              value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (storedData.value !== null) {
            html.setAttribute("value", storedData.value);
          }
          if (intent === "print") {
            break;
          }
          html.addEventListener("input", (event) => {
            storage.setValue(id, {
              value: event.target.value
            });
          });
        }
        break;
      case "select":
        if (storedData.value !== null) {
          html.setAttribute("value", storedData.value);
          for (const option of element.children) {
            if (option.attributes.value === storedData.value) {
              option.attributes.selected = true;
            } else if (option.attributes.hasOwnProperty("selected")) {
              delete option.attributes.selected;
            }
          }
        }
        html.addEventListener("input", (event) => {
          const options = event.target.options;
          const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
          storage.setValue(id, {
            value
          });
        });
        break;
    }
  }
  static setAttributes({
    html,
    element,
    storage = null,
    intent,
    linkService
  }) {
    const {
      attributes
    } = element;
    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
    if (attributes.type === "radio") {
      attributes.name = `${attributes.name}-${intent}`;
    }
    for (const [key, value] of Object.entries(attributes)) {
      if (value === null || value === void 0) {
        continue;
      }
      switch (key) {
        case "class":
          if (value.length) {
            html.setAttribute(key, value.join(" "));
          }
          break;
        case "dataId":
          break;
        case "id":
          html.setAttribute("data-element-id", value);
          break;
        case "style":
          Object.assign(html.style, value);
          break;
        case "textContent":
          html.textContent = value;
          break;
        default:
          if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
            html.setAttribute(key, value);
          }
      }
    }
    if (isHTMLAnchorElement) {
      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
    }
    if (storage && attributes.dataId) {
      this.setupStorage(html, attributes.dataId, element, storage);
    }
  }
  static render(parameters) {
    var _a2, _b;
    const storage = parameters.annotationStorage;
    const linkService = parameters.linkService;
    const root = parameters.xfaHtml;
    const intent = parameters.intent || "display";
    const rootHtml = document.createElement(root.name);
    if (root.attributes) {
      this.setAttributes({
        html: rootHtml,
        element: root,
        intent,
        linkService
      });
    }
    const isNotForRichText = intent !== "richText";
    const rootDiv = parameters.div;
    rootDiv.append(rootHtml);
    if (parameters.viewport) {
      const transform = `matrix(${parameters.viewport.transform.join(",")})`;
      rootDiv.style.transform = transform;
    }
    if (isNotForRichText) {
      rootDiv.setAttribute("class", "xfaLayer xfaFont");
    }
    const textDivs = [];
    if (root.children.length === 0) {
      if (root.value) {
        const node = document.createTextNode(root.value);
        rootHtml.append(node);
        if (isNotForRichText && XfaText.shouldBuildText(root.name)) {
          textDivs.push(node);
        }
      }
      return {
        textDivs
      };
    }
    const stack = [[root, -1, rootHtml]];
    while (stack.length > 0) {
      const [parent, i, html] = stack.at(-1);
      if (i + 1 === parent.children.length) {
        stack.pop();
        continue;
      }
      const child = parent.children[++stack.at(-1)[1]];
      if (child === null) {
        continue;
      }
      const {
        name
      } = child;
      if (name === "#text") {
        const node = document.createTextNode(child.value);
        textDivs.push(node);
        html.append(node);
        continue;
      }
      const childHtml = ((_a2 = child == null ? void 0 : child.attributes) == null ? void 0 : _a2.xmlns) ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);
      html.append(childHtml);
      if (child.attributes) {
        this.setAttributes({
          html: childHtml,
          element: child,
          storage,
          intent,
          linkService
        });
      }
      if (((_b = child.children) == null ? void 0 : _b.length) > 0) {
        stack.push([child, -1, childHtml]);
      } else if (child.value) {
        const node = document.createTextNode(child.value);
        if (isNotForRichText && XfaText.shouldBuildText(name)) {
          textDivs.push(node);
        }
        childHtml.append(node);
      }
    }
    for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
      el.setAttribute("readOnly", true);
    }
    return {
      textDivs
    };
  }
  static update(parameters) {
    const transform = `matrix(${parameters.viewport.transform.join(",")})`;
    parameters.div.style.transform = transform;
    parameters.div.hidden = false;
  }
};
var SVG_NS = "http://www.w3.org/2000/svg";
var _PixelsPerInch = class _PixelsPerInch {
};
__publicField(_PixelsPerInch, "CSS", 96);
__publicField(_PixelsPerInch, "PDF", 72);
__publicField(_PixelsPerInch, "PDF_TO_CSS_UNITS", _PixelsPerInch.CSS / _PixelsPerInch.PDF);
var PixelsPerInch = _PixelsPerInch;
async function fetchData(url, type = "text") {
  if (isValidFetchUrl(url, document.baseURI)) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(response.statusText);
    }
    switch (type) {
      case "arraybuffer":
        return response.arrayBuffer();
      case "blob":
        return response.blob();
      case "json":
        return response.json();
    }
    return response.text();
  }
  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest();
    request.open("GET", url, true);
    request.responseType = type;
    request.onreadystatechange = () => {
      if (request.readyState !== XMLHttpRequest.DONE) {
        return;
      }
      if (request.status === 200 || request.status === 0) {
        switch (type) {
          case "arraybuffer":
          case "blob":
          case "json":
            resolve(request.response);
            return;
        }
        resolve(request.responseText);
        return;
      }
      reject(new Error(request.statusText));
    };
    request.send(null);
  });
}
var PageViewport = class _PageViewport {
  constructor({
    viewBox,
    userUnit,
    scale,
    rotation,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  }) {
    this.viewBox = viewBox;
    this.userUnit = userUnit;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    scale *= userUnit;
    const centerX = (viewBox[2] + viewBox[0]) / 2;
    const centerY = (viewBox[3] + viewBox[1]) / 2;
    let rotateA, rotateB, rotateC, rotateD;
    rotation %= 360;
    if (rotation < 0) {
      rotation += 360;
    }
    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;
      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;
      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;
      case 0:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }
    let offsetCanvasX, offsetCanvasY;
    let width, height;
    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = (viewBox[3] - viewBox[1]) * scale;
      height = (viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = (viewBox[2] - viewBox[0]) * scale;
      height = (viewBox[3] - viewBox[1]) * scale;
    }
    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
    this.width = width;
    this.height = height;
  }
  get rawDims() {
    const dims = this.viewBox;
    return shadow(this, "rawDims", {
      pageWidth: dims[2] - dims[0],
      pageHeight: dims[3] - dims[1],
      pageX: dims[0],
      pageY: dims[1]
    });
  }
  clone({
    scale = this.scale,
    rotation = this.rotation,
    offsetX = this.offsetX,
    offsetY = this.offsetY,
    dontFlip = false
  } = {}) {
    return new _PageViewport({
      viewBox: this.viewBox.slice(),
      userUnit: this.userUnit,
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }
  convertToViewportPoint(x, y) {
    const p = [x, y];
    Util.applyTransform(p, this.transform);
    return p;
  }
  convertToViewportRectangle(rect) {
    const topLeft = [rect[0], rect[1]];
    Util.applyTransform(topLeft, this.transform);
    const bottomRight = [rect[2], rect[3]];
    Util.applyTransform(bottomRight, this.transform);
    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
  }
  convertToPdfPoint(x, y) {
    const p = [x, y];
    Util.applyInverseTransform(p, this.transform);
    return p;
  }
};
var RenderingCancelledException = class extends BaseException {
  constructor(msg, extraDelay = 0) {
    super(msg, "RenderingCancelledException");
    this.extraDelay = extraDelay;
  }
};
function isDataScheme(url) {
  const ii = url.length;
  let i = 0;
  while (i < ii && url[i].trim() === "") {
    i++;
  }
  return url.substring(i, i + 5).toLowerCase() === "data:";
}
function isPdfFile(filename) {
  return typeof filename === "string" && /\.pdf$/i.test(filename);
}
function getFilenameFromUrl(url) {
  [url] = url.split(/[#?]/, 1);
  return url.substring(url.lastIndexOf("/") + 1);
}
function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
  if (typeof url !== "string") {
    return defaultFilename;
  }
  if (isDataScheme(url)) {
    warn('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
    return defaultFilename;
  }
  const getURL = (urlString) => {
    try {
      return new URL(urlString);
    } catch {
      try {
        return new URL(decodeURIComponent(urlString));
      } catch {
        try {
          return new URL(urlString, "https://foo.bar");
        } catch {
          try {
            return new URL(decodeURIComponent(urlString), "https://foo.bar");
          } catch {
            return null;
          }
        }
      }
    }
  };
  const newURL = getURL(url);
  if (!newURL) {
    return defaultFilename;
  }
  const decode = (name) => {
    try {
      let decoded = decodeURIComponent(name);
      if (decoded.includes("/")) {
        decoded = decoded.split("/").at(-1);
        if (decoded.test(/^\.pdf$/i)) {
          return decoded;
        }
        return name;
      }
      return decoded;
    } catch {
      return name;
    }
  };
  const pdfRegex = /\.pdf$/i;
  const filename = newURL.pathname.split("/").at(-1);
  if (pdfRegex.test(filename)) {
    return decode(filename);
  }
  if (newURL.searchParams.size > 0) {
    const values = Array.from(newURL.searchParams.values()).reverse();
    for (const value of values) {
      if (pdfRegex.test(value)) {
        return decode(value);
      }
    }
    const keys = Array.from(newURL.searchParams.keys()).reverse();
    for (const key of keys) {
      if (pdfRegex.test(key)) {
        return decode(key);
      }
    }
  }
  if (newURL.hash) {
    const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
    const hashFilename = reFilename.exec(newURL.hash);
    if (hashFilename) {
      return decode(hashFilename[0]);
    }
  }
  return defaultFilename;
}
var StatTimer = class {
  constructor() {
    __publicField(this, "started", /* @__PURE__ */ Object.create(null));
    __publicField(this, "times", []);
  }
  time(name) {
    if (name in this.started) {
      warn(`Timer is already running for ${name}`);
    }
    this.started[name] = Date.now();
  }
  timeEnd(name) {
    if (!(name in this.started)) {
      warn(`Timer has not been started for ${name}`);
    }
    this.times.push({
      name,
      start: this.started[name],
      end: Date.now()
    });
    delete this.started[name];
  }
  toString() {
    const outBuf = [];
    let longest = 0;
    for (const {
      name
    } of this.times) {
      longest = Math.max(name.length, longest);
    }
    for (const {
      name,
      start,
      end
    } of this.times) {
      outBuf.push(`${name.padEnd(longest)} ${end - start}ms
`);
    }
    return outBuf.join("");
  }
};
function isValidFetchUrl(url, baseUrl) {
  const res = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);
  return (res == null ? void 0 : res.protocol) === "http:" || (res == null ? void 0 : res.protocol) === "https:";
}
function noContextMenu(e) {
  e.preventDefault();
}
function stopEvent(e) {
  e.preventDefault();
  e.stopPropagation();
}
function deprecated(details) {
  console.log("Deprecated API usage: " + details);
}
var _regex;
var PDFDateString = class {
  static toDateObject(input) {
    if (input instanceof Date) {
      return input;
    }
    if (!input || typeof input !== "string") {
      return null;
    }
    __privateGet(this, _regex) || __privateSet(this, _regex, new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
    const matches = __privateGet(this, _regex).exec(input);
    if (!matches) {
      return null;
    }
    const year = parseInt(matches[1], 10);
    let month = parseInt(matches[2], 10);
    month = month >= 1 && month <= 12 ? month - 1 : 0;
    let day = parseInt(matches[3], 10);
    day = day >= 1 && day <= 31 ? day : 1;
    let hour = parseInt(matches[4], 10);
    hour = hour >= 0 && hour <= 23 ? hour : 0;
    let minute = parseInt(matches[5], 10);
    minute = minute >= 0 && minute <= 59 ? minute : 0;
    let second = parseInt(matches[6], 10);
    second = second >= 0 && second <= 59 ? second : 0;
    const universalTimeRelation = matches[7] || "Z";
    let offsetHour = parseInt(matches[8], 10);
    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
    let offsetMinute = parseInt(matches[9], 10) || 0;
    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
    if (universalTimeRelation === "-") {
      hour += offsetHour;
      minute += offsetMinute;
    } else if (universalTimeRelation === "+") {
      hour -= offsetHour;
      minute -= offsetMinute;
    }
    return new Date(Date.UTC(year, month, day, hour, minute, second));
  }
};
_regex = new WeakMap();
__privateAdd(PDFDateString, _regex, void 0);
function getXfaPageViewport(xfaPage, {
  scale = 1,
  rotation = 0
}) {
  const {
    width,
    height
  } = xfaPage.attributes.style;
  const viewBox = [0, 0, parseInt(width), parseInt(height)];
  return new PageViewport({
    viewBox,
    userUnit: 1,
    scale,
    rotation
  });
}
function getRGB(color) {
  if (color.startsWith("#")) {
    const colorRGB = parseInt(color.slice(1), 16);
    return [(colorRGB & 16711680) >> 16, (colorRGB & 65280) >> 8, colorRGB & 255];
  }
  if (color.startsWith("rgb(")) {
    return color.slice(4, -1).split(",").map((x) => parseInt(x));
  }
  if (color.startsWith("rgba(")) {
    return color.slice(5, -1).split(",").map((x) => parseInt(x)).slice(0, 3);
  }
  warn(`Not a valid color format: "${color}"`);
  return [0, 0, 0];
}
function getColorValues(colors) {
  const span = document.createElement("span");
  span.style.visibility = "hidden";
  span.style.colorScheme = "only light";
  document.body.append(span);
  for (const name of colors.keys()) {
    span.style.color = name;
    const computedColor = window.getComputedStyle(span).color;
    colors.set(name, getRGB(computedColor));
  }
  span.remove();
}
function getCurrentTransform(ctx) {
  const {
    a,
    b,
    c,
    d,
    e,
    f
  } = ctx.getTransform();
  return [a, b, c, d, e, f];
}
function getCurrentTransformInverse(ctx) {
  const {
    a,
    b,
    c,
    d,
    e,
    f
  } = ctx.getTransform().invertSelf();
  return [a, b, c, d, e, f];
}
function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {
  if (viewport instanceof PageViewport) {
    const {
      pageWidth,
      pageHeight
    } = viewport.rawDims;
    const {
      style
    } = div;
    const useRound = util_FeatureTest.isCSSRoundSupported;
    const w = `var(--total-scale-factor) * ${pageWidth}px`, h = `var(--total-scale-factor) * ${pageHeight}px`;
    const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x))` : `calc(${w})`, heightStr = useRound ? `round(down, ${h}, var(--scale-round-y))` : `calc(${h})`;
    if (!mustFlip || viewport.rotation % 180 === 0) {
      style.width = widthStr;
      style.height = heightStr;
    } else {
      style.width = heightStr;
      style.height = widthStr;
    }
  }
  if (mustRotate) {
    div.setAttribute("data-main-rotation", viewport.rotation);
  }
}
var OutputScale = class _OutputScale {
  constructor() {
    const {
      pixelRatio
    } = _OutputScale;
    this.sx = pixelRatio;
    this.sy = pixelRatio;
  }
  get scaled() {
    return this.sx !== 1 || this.sy !== 1;
  }
  get symmetric() {
    return this.sx === this.sy;
  }
  limitCanvas(width, height, maxPixels, maxDim, capAreaFactor = -1) {
    let maxAreaScale = Infinity, maxWidthScale = Infinity, maxHeightScale = Infinity;
    maxPixels = _OutputScale.capPixels(maxPixels, capAreaFactor);
    if (maxPixels > 0) {
      maxAreaScale = Math.sqrt(maxPixels / (width * height));
    }
    if (maxDim !== -1) {
      maxWidthScale = maxDim / width;
      maxHeightScale = maxDim / height;
    }
    const maxScale = Math.min(maxAreaScale, maxWidthScale, maxHeightScale);
    if (this.sx > maxScale || this.sy > maxScale) {
      this.sx = maxScale;
      this.sy = maxScale;
      return true;
    }
    return false;
  }
  static get pixelRatio() {
    return globalThis.devicePixelRatio || 1;
  }
  static capPixels(maxPixels, capAreaFactor) {
    if (capAreaFactor >= 0) {
      const winPixels = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + capAreaFactor / 100));
      return maxPixels > 0 ? Math.min(maxPixels, winPixels) : winPixels;
    }
    return maxPixels;
  }
};
var SupportedImageMimeTypes = ["image/apng", "image/avif", "image/bmp", "image/gif", "image/jpeg", "image/png", "image/svg+xml", "image/webp", "image/x-icon"];
var ColorScheme = class {
  static get isDarkMode() {
    var _a2;
    return shadow(this, "isDarkMode", !!((_a2 = window == null ? void 0 : window.matchMedia) == null ? void 0 : _a2.call(window, "(prefers-color-scheme: dark)").matches));
  }
};
var CSSConstants = class {
  static get commentForegroundColor() {
    const element = document.createElement("span");
    element.classList.add("comment", "sidebar");
    const {
      style
    } = element;
    style.width = style.height = "0";
    style.display = "none";
    style.color = "var(--comment-fg-color)";
    document.body.append(element);
    const {
      color
    } = window.getComputedStyle(element);
    element.remove();
    return shadow(this, "commentForegroundColor", getRGB(color));
  }
};
function applyOpacity(r2, g, b, opacity) {
  opacity = Math.min(Math.max(opacity ?? 1, 0), 1);
  const white = 255 * (1 - opacity);
  r2 = Math.round(r2 * opacity + white);
  g = Math.round(g * opacity + white);
  b = Math.round(b * opacity + white);
  return [r2, g, b];
}
function RGBToHSL(rgb, output) {
  const r2 = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const max = Math.max(r2, g, b);
  const min = Math.min(r2, g, b);
  const l = (max + min) / 2;
  if (max === min) {
    output[0] = output[1] = 0;
  } else {
    const d = max - min;
    output[1] = l < 0.5 ? d / (max + min) : d / (2 - max - min);
    switch (max) {
      case r2:
        output[0] = ((g - b) / d + (g < b ? 6 : 0)) * 60;
        break;
      case g:
        output[0] = ((b - r2) / d + 2) * 60;
        break;
      case b:
        output[0] = ((r2 - g) / d + 4) * 60;
        break;
    }
  }
  output[2] = l;
}
function HSLToRGB(hsl, output) {
  const h = hsl[0];
  const s = hsl[1];
  const l = hsl[2];
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs(h / 60 % 2 - 1));
  const m = l - c / 2;
  switch (Math.floor(h / 60)) {
    case 0:
      output[0] = c + m;
      output[1] = x + m;
      output[2] = m;
      break;
    case 1:
      output[0] = x + m;
      output[1] = c + m;
      output[2] = m;
      break;
    case 2:
      output[0] = m;
      output[1] = c + m;
      output[2] = x + m;
      break;
    case 3:
      output[0] = m;
      output[1] = x + m;
      output[2] = c + m;
      break;
    case 4:
      output[0] = x + m;
      output[1] = m;
      output[2] = c + m;
      break;
    case 5:
    case 6:
      output[0] = c + m;
      output[1] = m;
      output[2] = x + m;
      break;
  }
}
function computeLuminance(x) {
  return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
}
function contrastRatio(hsl1, hsl2, output) {
  HSLToRGB(hsl1, output);
  output.map(computeLuminance);
  const lum1 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];
  HSLToRGB(hsl2, output);
  output.map(computeLuminance);
  const lum2 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];
  return lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);
}
var contrastCache = /* @__PURE__ */ new Map();
function findContrastColor(baseColor, fixedColor) {
  const key = baseColor[0] + baseColor[1] * 256 + baseColor[2] * 65536 + fixedColor[0] * 16777216 + fixedColor[1] * 4294967296 + fixedColor[2] * 1099511627776;
  let cachedValue = contrastCache.get(key);
  if (cachedValue) {
    return cachedValue;
  }
  const array = new Float32Array(9);
  const output = array.subarray(0, 3);
  const baseHSL = array.subarray(3, 6);
  RGBToHSL(baseColor, baseHSL);
  const fixedHSL = array.subarray(6, 9);
  RGBToHSL(fixedColor, fixedHSL);
  const isFixedColorDark = fixedHSL[2] < 0.5;
  const minContrast = isFixedColorDark ? 12 : 4.5;
  baseHSL[2] = isFixedColorDark ? Math.sqrt(baseHSL[2]) : 1 - Math.sqrt(1 - baseHSL[2]);
  if (contrastRatio(baseHSL, fixedHSL, output) < minContrast) {
    let start, end;
    if (isFixedColorDark) {
      start = baseHSL[2];
      end = 1;
    } else {
      start = 0;
      end = baseHSL[2];
    }
    const PRECISION = 5e-3;
    while (end - start > PRECISION) {
      const mid = baseHSL[2] = (start + end) / 2;
      if (isFixedColorDark === contrastRatio(baseHSL, fixedHSL, output) < minContrast) {
        start = mid;
      } else {
        end = mid;
      }
    }
    baseHSL[2] = isFixedColorDark ? end : start;
  }
  HSLToRGB(baseHSL, output);
  cachedValue = Util.makeHexColor(Math.round(output[0] * 255), Math.round(output[1] * 255), Math.round(output[2] * 255));
  contrastCache.set(key, cachedValue);
  return cachedValue;
}
function renderRichText({
  html,
  dir,
  className
}, container) {
  const fragment = document.createDocumentFragment();
  if (typeof html === "string") {
    const p = document.createElement("p");
    p.dir = dir || "auto";
    const lines = html.split(/(?:\r\n?|\n)/);
    for (let i = 0, ii = lines.length; i < ii; ++i) {
      const line = lines[i];
      p.append(document.createTextNode(line));
      if (i < ii - 1) {
        p.append(document.createElement("br"));
      }
    }
    fragment.append(p);
  } else {
    XfaLayer.render({
      xfaHtml: html,
      div: fragment,
      intent: "richText"
    });
  }
  fragment.firstChild.classList.add("richText", className);
  container.append(fragment);
}
var _toolbar, _colorPicker, _editor, _buttons, _altText, _comment, _commentButtonDivider, _signatureDescriptionButton, _l10nRemove, _pointerDown, pointerDown_fn, _focusIn, focusIn_fn, _focusOut, focusOut_fn, _addListenersToElement, addListenersToElement_fn, _divider, divider_get;
var _EditorToolbar = class _EditorToolbar {
  constructor(editor) {
    __privateAdd(this, _focusIn);
    __privateAdd(this, _focusOut);
    __privateAdd(this, _addListenersToElement);
    __privateAdd(this, _divider);
    __privateAdd(this, _toolbar, null);
    __privateAdd(this, _colorPicker, null);
    __privateAdd(this, _editor, void 0);
    __privateAdd(this, _buttons, null);
    __privateAdd(this, _altText, null);
    __privateAdd(this, _comment, null);
    __privateAdd(this, _commentButtonDivider, null);
    __privateAdd(this, _signatureDescriptionButton, null);
    __privateSet(this, _editor, editor);
    __privateGet(_EditorToolbar, _l10nRemove) || __privateSet(_EditorToolbar, _l10nRemove, Object.freeze({
      freetext: "pdfjs-editor-remove-freetext-button",
      highlight: "pdfjs-editor-remove-highlight-button",
      ink: "pdfjs-editor-remove-ink-button",
      stamp: "pdfjs-editor-remove-stamp-button",
      signature: "pdfjs-editor-remove-signature-button"
    }));
  }
  render() {
    const editToolbar = __privateSet(this, _toolbar, document.createElement("div"));
    editToolbar.classList.add("editToolbar", "hidden");
    editToolbar.setAttribute("role", "toolbar");
    const signal = __privateGet(this, _editor)._uiManager._signal;
    if (signal instanceof AbortSignal && !signal.aborted) {
      editToolbar.addEventListener("contextmenu", noContextMenu, {
        signal
      });
      editToolbar.addEventListener("pointerdown", __privateMethod(_EditorToolbar, _pointerDown, pointerDown_fn), {
        signal
      });
    }
    const buttons = __privateSet(this, _buttons, document.createElement("div"));
    buttons.className = "buttons";
    editToolbar.append(buttons);
    const position = __privateGet(this, _editor).toolbarPosition;
    if (position) {
      const {
        style
      } = editToolbar;
      const x = __privateGet(this, _editor)._uiManager.direction === "ltr" ? 1 - position[0] : position[0];
      style.insetInlineEnd = `${100 * x}%`;
      style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;
    }
    return editToolbar;
  }
  get div() {
    return __privateGet(this, _toolbar);
  }
  hide() {
    var _a2;
    __privateGet(this, _toolbar).classList.add("hidden");
    (_a2 = __privateGet(this, _colorPicker)) == null ? void 0 : _a2.hideDropdown();
  }
  show() {
    var _a2, _b;
    __privateGet(this, _toolbar).classList.remove("hidden");
    (_a2 = __privateGet(this, _altText)) == null ? void 0 : _a2.shown();
    (_b = __privateGet(this, _comment)) == null ? void 0 : _b.shown();
  }
  addDeleteButton() {
    const {
      editorType,
      _uiManager: _uiManager5
    } = __privateGet(this, _editor);
    const button = document.createElement("button");
    button.classList.add("basic", "deleteButton");
    button.tabIndex = 0;
    button.setAttribute("data-l10n-id", __privateGet(_EditorToolbar, _l10nRemove)[editorType]);
    if (__privateMethod(this, _addListenersToElement, addListenersToElement_fn).call(this, button)) {
      button.addEventListener("click", (e) => {
        _uiManager5.delete();
      }, {
        signal: _uiManager5._signal
      });
    }
    __privateGet(this, _buttons).append(button);
  }
  async addAltText(altText) {
    const button = await altText.render();
    __privateMethod(this, _addListenersToElement, addListenersToElement_fn).call(this, button);
    __privateGet(this, _buttons).append(button, __privateGet(this, _divider, divider_get));
    __privateSet(this, _altText, altText);
  }
  addComment(comment, beforeElement = null) {
    if (__privateGet(this, _comment)) {
      return;
    }
    const button = comment.renderForToolbar();
    if (!button) {
      return;
    }
    __privateMethod(this, _addListenersToElement, addListenersToElement_fn).call(this, button);
    const divider = __privateSet(this, _commentButtonDivider, __privateGet(this, _divider, divider_get));
    if (!beforeElement) {
      __privateGet(this, _buttons).append(button, divider);
    } else {
      __privateGet(this, _buttons).insertBefore(button, beforeElement);
      __privateGet(this, _buttons).insertBefore(divider, beforeElement);
    }
    __privateSet(this, _comment, comment);
    comment.toolbar = this;
  }
  addColorPicker(colorPicker) {
    if (__privateGet(this, _colorPicker)) {
      return;
    }
    __privateSet(this, _colorPicker, colorPicker);
    const button = colorPicker.renderButton();
    __privateMethod(this, _addListenersToElement, addListenersToElement_fn).call(this, button);
    __privateGet(this, _buttons).append(button, __privateGet(this, _divider, divider_get));
  }
  async addEditSignatureButton(signatureManager) {
    const button = __privateSet(this, _signatureDescriptionButton, await signatureManager.renderEditButton(__privateGet(this, _editor)));
    __privateMethod(this, _addListenersToElement, addListenersToElement_fn).call(this, button);
    __privateGet(this, _buttons).append(button, __privateGet(this, _divider, divider_get));
  }
  removeButton(name) {
    var _a2, _b;
    switch (name) {
      case "comment":
        (_a2 = __privateGet(this, _comment)) == null ? void 0 : _a2.removeToolbarCommentButton();
        __privateSet(this, _comment, null);
        (_b = __privateGet(this, _commentButtonDivider)) == null ? void 0 : _b.remove();
        __privateSet(this, _commentButtonDivider, null);
        break;
    }
  }
  async addButton(name, tool) {
    switch (name) {
      case "colorPicker":
        this.addColorPicker(tool);
        break;
      case "altText":
        await this.addAltText(tool);
        break;
      case "editSignature":
        await this.addEditSignatureButton(tool);
        break;
      case "delete":
        this.addDeleteButton();
        break;
      case "comment":
        this.addComment(tool);
        break;
    }
  }
  async addButtonBefore(name, tool, beforeSelector) {
    const beforeElement = __privateGet(this, _buttons).querySelector(beforeSelector);
    if (!beforeElement) {
      return;
    }
    if (name === "comment") {
      this.addComment(tool, beforeElement);
    }
  }
  updateEditSignatureButton(description) {
    if (__privateGet(this, _signatureDescriptionButton)) {
      __privateGet(this, _signatureDescriptionButton).title = description;
    }
  }
  remove() {
    var _a2;
    __privateGet(this, _toolbar).remove();
    (_a2 = __privateGet(this, _colorPicker)) == null ? void 0 : _a2.destroy();
    __privateSet(this, _colorPicker, null);
  }
};
_toolbar = new WeakMap();
_colorPicker = new WeakMap();
_editor = new WeakMap();
_buttons = new WeakMap();
_altText = new WeakMap();
_comment = new WeakMap();
_commentButtonDivider = new WeakMap();
_signatureDescriptionButton = new WeakMap();
_l10nRemove = new WeakMap();
_pointerDown = new WeakSet();
pointerDown_fn = function(e) {
  e.stopPropagation();
};
_focusIn = new WeakSet();
focusIn_fn = function(e) {
  __privateGet(this, _editor)._focusEventsAllowed = false;
  stopEvent(e);
};
_focusOut = new WeakSet();
focusOut_fn = function(e) {
  __privateGet(this, _editor)._focusEventsAllowed = true;
  stopEvent(e);
};
_addListenersToElement = new WeakSet();
addListenersToElement_fn = function(element) {
  const signal = __privateGet(this, _editor)._uiManager._signal;
  if (!(signal instanceof AbortSignal) || signal.aborted) {
    return false;
  }
  element.addEventListener("focusin", __privateMethod(this, _focusIn, focusIn_fn).bind(this), {
    capture: true,
    signal
  });
  element.addEventListener("focusout", __privateMethod(this, _focusOut, focusOut_fn).bind(this), {
    capture: true,
    signal
  });
  element.addEventListener("contextmenu", noContextMenu, {
    signal
  });
  return true;
};
_divider = new WeakSet();
divider_get = function() {
  const divider = document.createElement("div");
  divider.className = "divider";
  return divider;
};
__privateAdd(_EditorToolbar, _pointerDown);
__privateAdd(_EditorToolbar, _l10nRemove, null);
var EditorToolbar = _EditorToolbar;
var _buttons2, _toolbar2, _uiManager, _render, render_fn, _getLastPoint, getLastPoint_fn, _makeButton, makeButton_fn;
var FloatingToolbar = class {
  constructor(uiManager) {
    __privateAdd(this, _render);
    __privateAdd(this, _getLastPoint);
    __privateAdd(this, _makeButton);
    __privateAdd(this, _buttons2, null);
    __privateAdd(this, _toolbar2, null);
    __privateAdd(this, _uiManager, void 0);
    __privateSet(this, _uiManager, uiManager);
  }
  show(parent, boxes, isLTR) {
    const [x, y] = __privateMethod(this, _getLastPoint, getLastPoint_fn).call(this, boxes, isLTR);
    const {
      style
    } = __privateGet(this, _toolbar2) || __privateSet(this, _toolbar2, __privateMethod(this, _render, render_fn).call(this));
    parent.append(__privateGet(this, _toolbar2));
    style.insetInlineEnd = `${100 * x}%`;
    style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;
  }
  hide() {
    __privateGet(this, _toolbar2).remove();
  }
};
_buttons2 = new WeakMap();
_toolbar2 = new WeakMap();
_uiManager = new WeakMap();
_render = new WeakSet();
render_fn = function() {
  const editToolbar = __privateSet(this, _toolbar2, document.createElement("div"));
  editToolbar.className = "editToolbar";
  editToolbar.setAttribute("role", "toolbar");
  const signal = __privateGet(this, _uiManager)._signal;
  if (signal instanceof AbortSignal && !signal.aborted) {
    editToolbar.addEventListener("contextmenu", noContextMenu, {
      signal
    });
  }
  const buttons = __privateSet(this, _buttons2, document.createElement("div"));
  buttons.className = "buttons";
  editToolbar.append(buttons);
  if (__privateGet(this, _uiManager).hasCommentManager()) {
    __privateMethod(this, _makeButton, makeButton_fn).call(this, "commentButton", `pdfjs-comment-floating-button`, "pdfjs-comment-floating-button-label", () => {
      __privateGet(this, _uiManager).commentSelection("floating_button");
    });
  }
  __privateMethod(this, _makeButton, makeButton_fn).call(this, "highlightButton", `pdfjs-highlight-floating-button1`, "pdfjs-highlight-floating-button-label", () => {
    __privateGet(this, _uiManager).highlightSelection("floating_button");
  });
  return editToolbar;
};
_getLastPoint = new WeakSet();
getLastPoint_fn = function(boxes, isLTR) {
  let lastY = 0;
  let lastX = 0;
  for (const box of boxes) {
    const y = box.y + box.height;
    if (y < lastY) {
      continue;
    }
    const x = box.x + (isLTR ? box.width : 0);
    if (y > lastY) {
      lastX = x;
      lastY = y;
      continue;
    }
    if (isLTR) {
      if (x > lastX) {
        lastX = x;
      }
    } else if (x < lastX) {
      lastX = x;
    }
  }
  return [isLTR ? 1 - lastX : lastX, lastY];
};
_makeButton = new WeakSet();
makeButton_fn = function(buttonClass, l10nId, labelL10nId, clickHandler) {
  const button = document.createElement("button");
  button.classList.add("basic", buttonClass);
  button.tabIndex = 0;
  button.setAttribute("data-l10n-id", l10nId);
  const span = document.createElement("span");
  button.append(span);
  span.className = "visuallyHidden";
  span.setAttribute("data-l10n-id", labelL10nId);
  const signal = __privateGet(this, _uiManager)._signal;
  if (signal instanceof AbortSignal && !signal.aborted) {
    button.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    button.addEventListener("click", clickHandler, {
      signal
    });
  }
  __privateGet(this, _buttons2).append(button);
};
function bindEvents(obj, element, names) {
  for (const name of names) {
    element.addEventListener(name, obj[name].bind(obj));
  }
}
var _id;
var IdManager = class {
  constructor() {
    __privateAdd(this, _id, 0);
  }
  get id() {
    return `${AnnotationEditorPrefix}${__privateWrapper(this, _id)._++}`;
  }
};
_id = new WeakMap();
var _baseId, _id2, _cache, _get, get_fn;
var _ImageManager = class _ImageManager {
  constructor() {
    __privateAdd(this, _get);
    __privateAdd(this, _baseId, getUuid());
    __privateAdd(this, _id2, 0);
    __privateAdd(this, _cache, null);
  }
  static get _isSVGFittingCanvas() {
    const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>`;
    const canvas = new OffscreenCanvas(1, 3);
    const ctx = canvas.getContext("2d", {
      willReadFrequently: true
    });
    const image = new Image();
    image.src = svg;
    const promise = image.decode().then(() => {
      ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
      return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
    });
    return shadow(this, "_isSVGFittingCanvas", promise);
  }
  async getFromFile(file) {
    const {
      lastModified,
      name,
      size,
      type
    } = file;
    return __privateMethod(this, _get, get_fn).call(this, `${lastModified}_${name}_${size}_${type}`, file);
  }
  async getFromUrl(url) {
    return __privateMethod(this, _get, get_fn).call(this, url, url);
  }
  async getFromBlob(id, blobPromise) {
    const blob = await blobPromise;
    return __privateMethod(this, _get, get_fn).call(this, id, blob);
  }
  async getFromId(id) {
    __privateGet(this, _cache) || __privateSet(this, _cache, /* @__PURE__ */ new Map());
    const data = __privateGet(this, _cache).get(id);
    if (!data) {
      return null;
    }
    if (data.bitmap) {
      data.refCounter += 1;
      return data;
    }
    if (data.file) {
      return this.getFromFile(data.file);
    }
    if (data.blobPromise) {
      const {
        blobPromise
      } = data;
      delete data.blobPromise;
      return this.getFromBlob(data.id, blobPromise);
    }
    return this.getFromUrl(data.url);
  }
  getFromCanvas(id, canvas) {
    __privateGet(this, _cache) || __privateSet(this, _cache, /* @__PURE__ */ new Map());
    let data = __privateGet(this, _cache).get(id);
    if (data == null ? void 0 : data.bitmap) {
      data.refCounter += 1;
      return data;
    }
    const offscreen = new OffscreenCanvas(canvas.width, canvas.height);
    const ctx = offscreen.getContext("2d");
    ctx.drawImage(canvas, 0, 0);
    data = {
      bitmap: offscreen.transferToImageBitmap(),
      id: `image_${__privateGet(this, _baseId)}_${__privateWrapper(this, _id2)._++}`,
      refCounter: 1,
      isSvg: false
    };
    __privateGet(this, _cache).set(id, data);
    __privateGet(this, _cache).set(data.id, data);
    return data;
  }
  getSvgUrl(id) {
    const data = __privateGet(this, _cache).get(id);
    if (!(data == null ? void 0 : data.isSvg)) {
      return null;
    }
    return data.svgUrl;
  }
  deleteId(id) {
    var _a2;
    __privateGet(this, _cache) || __privateSet(this, _cache, /* @__PURE__ */ new Map());
    const data = __privateGet(this, _cache).get(id);
    if (!data) {
      return;
    }
    data.refCounter -= 1;
    if (data.refCounter !== 0) {
      return;
    }
    const {
      bitmap
    } = data;
    if (!data.url && !data.file) {
      const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
      const ctx = canvas.getContext("bitmaprenderer");
      ctx.transferFromImageBitmap(bitmap);
      data.blobPromise = canvas.convertToBlob();
    }
    (_a2 = bitmap.close) == null ? void 0 : _a2.call(bitmap);
    data.bitmap = null;
  }
  isValidId(id) {
    return id.startsWith(`image_${__privateGet(this, _baseId)}_`);
  }
};
_baseId = new WeakMap();
_id2 = new WeakMap();
_cache = new WeakMap();
_get = new WeakSet();
get_fn = async function(key, rawData) {
  __privateGet(this, _cache) || __privateSet(this, _cache, /* @__PURE__ */ new Map());
  let data = __privateGet(this, _cache).get(key);
  if (data === null) {
    return null;
  }
  if (data == null ? void 0 : data.bitmap) {
    data.refCounter += 1;
    return data;
  }
  try {
    data || (data = {
      bitmap: null,
      id: `image_${__privateGet(this, _baseId)}_${__privateWrapper(this, _id2)._++}`,
      refCounter: 0,
      isSvg: false
    });
    let image;
    if (typeof rawData === "string") {
      data.url = rawData;
      image = await fetchData(rawData, "blob");
    } else if (rawData instanceof File) {
      image = data.file = rawData;
    } else if (rawData instanceof Blob) {
      image = rawData;
    }
    if (image.type === "image/svg+xml") {
      const mustRemoveAspectRatioPromise = _ImageManager._isSVGFittingCanvas;
      const fileReader = new FileReader();
      const imageElement = new Image();
      const imagePromise = new Promise((resolve, reject) => {
        imageElement.onload = () => {
          data.bitmap = imageElement;
          data.isSvg = true;
          resolve();
        };
        fileReader.onload = async () => {
          const url = data.svgUrl = fileReader.result;
          imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;
        };
        imageElement.onerror = fileReader.onerror = reject;
      });
      fileReader.readAsDataURL(image);
      await imagePromise;
    } else {
      data.bitmap = await createImageBitmap(image);
    }
    data.refCounter = 1;
  } catch (e) {
    warn(e);
    data = null;
  }
  __privateGet(this, _cache).set(key, data);
  if (data) {
    __privateGet(this, _cache).set(data.id, data);
  }
  return data;
};
var ImageManager = _ImageManager;
var _commands, _locked, _maxSize, _position;
var CommandManager = class {
  constructor(maxSize = 128) {
    __privateAdd(this, _commands, []);
    __privateAdd(this, _locked, false);
    __privateAdd(this, _maxSize, void 0);
    __privateAdd(this, _position, -1);
    __privateSet(this, _maxSize, maxSize);
  }
  add({
    cmd,
    undo,
    post,
    mustExec,
    type = NaN,
    overwriteIfSameType = false,
    keepUndo = false
  }) {
    if (mustExec) {
      cmd();
    }
    if (__privateGet(this, _locked)) {
      return;
    }
    const save = {
      cmd,
      undo,
      post,
      type
    };
    if (__privateGet(this, _position) === -1) {
      if (__privateGet(this, _commands).length > 0) {
        __privateGet(this, _commands).length = 0;
      }
      __privateSet(this, _position, 0);
      __privateGet(this, _commands).push(save);
      return;
    }
    if (overwriteIfSameType && __privateGet(this, _commands)[__privateGet(this, _position)].type === type) {
      if (keepUndo) {
        save.undo = __privateGet(this, _commands)[__privateGet(this, _position)].undo;
      }
      __privateGet(this, _commands)[__privateGet(this, _position)] = save;
      return;
    }
    const next = __privateGet(this, _position) + 1;
    if (next === __privateGet(this, _maxSize)) {
      __privateGet(this, _commands).splice(0, 1);
    } else {
      __privateSet(this, _position, next);
      if (next < __privateGet(this, _commands).length) {
        __privateGet(this, _commands).splice(next);
      }
    }
    __privateGet(this, _commands).push(save);
  }
  undo() {
    if (__privateGet(this, _position) === -1) {
      return;
    }
    __privateSet(this, _locked, true);
    const {
      undo,
      post
    } = __privateGet(this, _commands)[__privateGet(this, _position)];
    undo();
    post == null ? void 0 : post();
    __privateSet(this, _locked, false);
    __privateSet(this, _position, __privateGet(this, _position) - 1);
  }
  redo() {
    if (__privateGet(this, _position) < __privateGet(this, _commands).length - 1) {
      __privateSet(this, _position, __privateGet(this, _position) + 1);
      __privateSet(this, _locked, true);
      const {
        cmd,
        post
      } = __privateGet(this, _commands)[__privateGet(this, _position)];
      cmd();
      post == null ? void 0 : post();
      __privateSet(this, _locked, false);
    }
  }
  hasSomethingToUndo() {
    return __privateGet(this, _position) !== -1;
  }
  hasSomethingToRedo() {
    return __privateGet(this, _position) < __privateGet(this, _commands).length - 1;
  }
  cleanType(type) {
    if (__privateGet(this, _position) === -1) {
      return;
    }
    for (let i = __privateGet(this, _position); i >= 0; i--) {
      if (__privateGet(this, _commands)[i].type !== type) {
        __privateGet(this, _commands).splice(i + 1, __privateGet(this, _position) - i);
        __privateSet(this, _position, i);
        return;
      }
    }
    __privateGet(this, _commands).length = 0;
    __privateSet(this, _position, -1);
  }
  destroy() {
    __privateSet(this, _commands, null);
  }
};
_commands = new WeakMap();
_locked = new WeakMap();
_maxSize = new WeakMap();
_position = new WeakMap();
var _serialize, serialize_fn;
var KeyboardManager = class {
  constructor(callbacks) {
    __privateAdd(this, _serialize);
    this.buffer = [];
    this.callbacks = /* @__PURE__ */ new Map();
    this.allKeys = /* @__PURE__ */ new Set();
    const {
      isMac
    } = util_FeatureTest.platform;
    for (const [keys, callback, options = {}] of callbacks) {
      for (const key of keys) {
        const isMacKey = key.startsWith("mac+");
        if (isMac && isMacKey) {
          this.callbacks.set(key.slice(4), {
            callback,
            options
          });
          this.allKeys.add(key.split("+").at(-1));
        } else if (!isMac && !isMacKey) {
          this.callbacks.set(key, {
            callback,
            options
          });
          this.allKeys.add(key.split("+").at(-1));
        }
      }
    }
  }
  exec(self, event) {
    if (!this.allKeys.has(event.key)) {
      return;
    }
    const info2 = this.callbacks.get(__privateMethod(this, _serialize, serialize_fn).call(this, event));
    if (!info2) {
      return;
    }
    const {
      callback,
      options: {
        bubbles = false,
        args = [],
        checker = null
      }
    } = info2;
    if (checker && !checker(self, event)) {
      return;
    }
    callback.bind(self, ...args, event)();
    if (!bubbles) {
      stopEvent(event);
    }
  }
};
_serialize = new WeakSet();
serialize_fn = function(event) {
  if (event.altKey) {
    this.buffer.push("alt");
  }
  if (event.ctrlKey) {
    this.buffer.push("ctrl");
  }
  if (event.metaKey) {
    this.buffer.push("meta");
  }
  if (event.shiftKey) {
    this.buffer.push("shift");
  }
  this.buffer.push(event.key);
  const str = this.buffer.join("+");
  this.buffer.length = 0;
  return str;
};
var _ColorManager = class _ColorManager {
  get _colors() {
    const colors = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
    getColorValues(colors);
    return shadow(this, "_colors", colors);
  }
  convert(color) {
    const rgb = getRGB(color);
    if (!window.matchMedia("(forced-colors: active)").matches) {
      return rgb;
    }
    for (const [name, RGB] of this._colors) {
      if (RGB.every((x, i) => x === rgb[i])) {
        return _ColorManager._colorsMapping.get(name);
      }
    }
    return rgb;
  }
  getHexCode(name) {
    const rgb = this._colors.get(name);
    if (!rgb) {
      return name;
    }
    return Util.makeHexColor(...rgb);
  }
};
__publicField(_ColorManager, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
var ColorManager = _ColorManager;
var _abortController, _activeEditor, _allEditableAnnotations, _allEditors, _allLayers, _altTextManager, _annotationStorage, _changedExistingAnnotations, _commandManager, _commentManager, _copyPasteAC, _currentDrawingSession, _currentPageIndex, _deletedAnnotationsElementIds, _draggingEditors, _editorTypes, _editorsToRescale, _enableHighlightFloatingButton, _enableUpdatedAddImage, _enableNewAltTextWhenAddingImage, _filterFactory, _focusMainContainerTimeoutId, _focusManagerAC, _highlightColors, _highlightWhenShiftUp, _floatingToolbar, _idManager, _isEnabled, _isPointerDown, _isWaiting, _keyboardManagerAC, _lastActiveElement, _mainHighlightColorPicker, _missingCanvases, _mlManager, _mode, _selectedEditors, _selectedTextNode, _signatureManager, _pageColors, _showAllStates, _pdfDocument, _previousStates, _translation, _translationTimeoutId, _container, _viewer, _viewerAlert, _updateModeCapability, _getAnchorElementForSelection, getAnchorElementForSelection_fn, _getLayerForTextLayer, getLayerForTextLayer_fn, _displayFloatingToolbar, displayFloatingToolbar_fn, _selectionChange, selectionChange_fn, _onSelectEnd, onSelectEnd_fn, _addSelectionListener, addSelectionListener_fn, _addFocusManager, addFocusManager_fn, _removeFocusManager, removeFocusManager_fn, _addKeyboardManager, addKeyboardManager_fn, _removeKeyboardManager, removeKeyboardManager_fn, _addCopyPasteListeners, addCopyPasteListeners_fn, _removeCopyPasteListeners, removeCopyPasteListeners_fn, _addDragAndDropListeners, addDragAndDropListeners_fn, _dispatchUpdateStates, dispatchUpdateStates_fn, _dispatchUpdateUI, dispatchUpdateUI_fn, _enableAll, enableAll_fn, _disableAll, disableAll_fn, _addEditorToLayer, addEditorToLayer_fn, _lastSelectedEditor, lastSelectedEditor_get, _isEmpty, isEmpty_fn, _selectEditors, selectEditors_fn;
var _AnnotationEditorUIManager = class _AnnotationEditorUIManager {
  constructor(container, viewer, viewerAlert, altTextManager, commentManager, signatureManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar, supportsPinchToZoom) {
    __privateAdd(this, _getAnchorElementForSelection);
    __privateAdd(this, _getLayerForTextLayer);
    __privateAdd(this, _displayFloatingToolbar);
    __privateAdd(this, _selectionChange);
    __privateAdd(this, _onSelectEnd);
    __privateAdd(this, _addSelectionListener);
    __privateAdd(this, _addFocusManager);
    __privateAdd(this, _removeFocusManager);
    __privateAdd(this, _addKeyboardManager);
    __privateAdd(this, _removeKeyboardManager);
    __privateAdd(this, _addCopyPasteListeners);
    __privateAdd(this, _removeCopyPasteListeners);
    __privateAdd(this, _addDragAndDropListeners);
    __privateAdd(this, _dispatchUpdateStates);
    __privateAdd(this, _dispatchUpdateUI);
    __privateAdd(this, _enableAll);
    __privateAdd(this, _disableAll);
    __privateAdd(this, _addEditorToLayer);
    __privateAdd(this, _lastSelectedEditor);
    __privateAdd(this, _isEmpty);
    __privateAdd(this, _selectEditors);
    __privateAdd(this, _abortController, new AbortController());
    __privateAdd(this, _activeEditor, null);
    __privateAdd(this, _allEditableAnnotations, null);
    __privateAdd(this, _allEditors, /* @__PURE__ */ new Map());
    __privateAdd(this, _allLayers, /* @__PURE__ */ new Map());
    __privateAdd(this, _altTextManager, null);
    __privateAdd(this, _annotationStorage, null);
    __privateAdd(this, _changedExistingAnnotations, null);
    __privateAdd(this, _commandManager, new CommandManager());
    __privateAdd(this, _commentManager, null);
    __privateAdd(this, _copyPasteAC, null);
    __privateAdd(this, _currentDrawingSession, null);
    __privateAdd(this, _currentPageIndex, 0);
    __privateAdd(this, _deletedAnnotationsElementIds, /* @__PURE__ */ new Set());
    __privateAdd(this, _draggingEditors, null);
    __privateAdd(this, _editorTypes, null);
    __privateAdd(this, _editorsToRescale, /* @__PURE__ */ new Set());
    __publicField(this, "_editorUndoBar", null);
    __privateAdd(this, _enableHighlightFloatingButton, false);
    __privateAdd(this, _enableUpdatedAddImage, false);
    __privateAdd(this, _enableNewAltTextWhenAddingImage, false);
    __privateAdd(this, _filterFactory, null);
    __privateAdd(this, _focusMainContainerTimeoutId, null);
    __privateAdd(this, _focusManagerAC, null);
    __privateAdd(this, _highlightColors, null);
    __privateAdd(this, _highlightWhenShiftUp, false);
    __privateAdd(this, _floatingToolbar, null);
    __privateAdd(this, _idManager, new IdManager());
    __privateAdd(this, _isEnabled, false);
    __privateAdd(this, _isPointerDown, false);
    __privateAdd(this, _isWaiting, false);
    __privateAdd(this, _keyboardManagerAC, null);
    __privateAdd(this, _lastActiveElement, null);
    __privateAdd(this, _mainHighlightColorPicker, null);
    __privateAdd(this, _missingCanvases, null);
    __privateAdd(this, _mlManager, null);
    __privateAdd(this, _mode, AnnotationEditorType.NONE);
    __privateAdd(this, _selectedEditors, /* @__PURE__ */ new Set());
    __privateAdd(this, _selectedTextNode, null);
    __privateAdd(this, _signatureManager, null);
    __privateAdd(this, _pageColors, null);
    __privateAdd(this, _showAllStates, null);
    __privateAdd(this, _pdfDocument, null);
    __privateAdd(this, _previousStates, {
      isEditing: false,
      isEmpty: true,
      hasSomethingToUndo: false,
      hasSomethingToRedo: false,
      hasSelectedEditor: false,
      hasSelectedText: false
    });
    __privateAdd(this, _translation, [0, 0]);
    __privateAdd(this, _translationTimeoutId, null);
    __privateAdd(this, _container, null);
    __privateAdd(this, _viewer, null);
    __privateAdd(this, _viewerAlert, null);
    __privateAdd(this, _updateModeCapability, null);
    const signal = this._signal = __privateGet(this, _abortController).signal;
    __privateSet(this, _container, container);
    __privateSet(this, _viewer, viewer);
    __privateSet(this, _viewerAlert, viewerAlert);
    __privateSet(this, _altTextManager, altTextManager);
    __privateSet(this, _commentManager, commentManager);
    __privateSet(this, _signatureManager, signatureManager);
    __privateSet(this, _pdfDocument, pdfDocument);
    this._eventBus = eventBus;
    eventBus._on("editingaction", this.onEditingAction.bind(this), {
      signal
    });
    eventBus._on("pagechanging", this.onPageChanging.bind(this), {
      signal
    });
    eventBus._on("scalechanging", this.onScaleChanging.bind(this), {
      signal
    });
    eventBus._on("rotationchanging", this.onRotationChanging.bind(this), {
      signal
    });
    eventBus._on("setpreference", this.onSetPreference.bind(this), {
      signal
    });
    eventBus._on("switchannotationeditorparams", (evt) => this.updateParams(evt.type, evt.value), {
      signal
    });
    window.addEventListener("pointerdown", () => {
      __privateSet(this, _isPointerDown, true);
    }, {
      capture: true,
      signal
    });
    window.addEventListener("pointerup", () => {
      __privateSet(this, _isPointerDown, false);
    }, {
      capture: true,
      signal
    });
    __privateMethod(this, _addSelectionListener, addSelectionListener_fn).call(this);
    __privateMethod(this, _addDragAndDropListeners, addDragAndDropListeners_fn).call(this);
    __privateMethod(this, _addKeyboardManager, addKeyboardManager_fn).call(this);
    __privateSet(this, _annotationStorage, pdfDocument.annotationStorage);
    __privateSet(this, _filterFactory, pdfDocument.filterFactory);
    __privateSet(this, _pageColors, pageColors);
    __privateSet(this, _highlightColors, highlightColors || null);
    __privateSet(this, _enableHighlightFloatingButton, enableHighlightFloatingButton);
    __privateSet(this, _enableUpdatedAddImage, enableUpdatedAddImage);
    __privateSet(this, _enableNewAltTextWhenAddingImage, enableNewAltTextWhenAddingImage);
    __privateSet(this, _mlManager, mlManager || null);
    this.viewParameters = {
      realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
      rotation: 0
    };
    this.isShiftKeyDown = false;
    this._editorUndoBar = editorUndoBar || null;
    this._supportsPinchToZoom = supportsPinchToZoom !== false;
    commentManager == null ? void 0 : commentManager.setSidebarUiManager(this);
  }
  static get _keyboardManager() {
    const proto = _AnnotationEditorUIManager.prototype;
    const arrowChecker = (self) => __privateGet(self, _container).contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && self.hasSomethingToControl();
    const textInputChecker = (_self, {
      target: el
    }) => {
      if (el instanceof HTMLInputElement) {
        const {
          type
        } = el;
        return type !== "text" && type !== "number";
      }
      return true;
    };
    const small = this.TRANSLATE_SMALL;
    const big = this.TRANSLATE_BIG;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], proto.selectAll, {
      checker: textInputChecker
    }], [["ctrl+z", "mac+meta+z"], proto.undo, {
      checker: textInputChecker
    }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], proto.redo, {
      checker: textInputChecker
    }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], proto.delete, {
      checker: textInputChecker
    }], [["Enter", "mac+Enter"], proto.addNewEditorFromKeyboard, {
      checker: (self, {
        target: el
      }) => !(el instanceof HTMLButtonElement) && __privateGet(self, _container).contains(el) && !self.isEnterHandled
    }], [[" ", "mac+ "], proto.addNewEditorFromKeyboard, {
      checker: (self, {
        target: el
      }) => !(el instanceof HTMLButtonElement) && __privateGet(self, _container).contains(document.activeElement)
    }], [["Escape", "mac+Escape"], proto.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], proto.translateSelectedEditors, {
      args: [-small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto.translateSelectedEditors, {
      args: [-big, 0],
      checker: arrowChecker
    }], [["ArrowRight", "mac+ArrowRight"], proto.translateSelectedEditors, {
      args: [small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto.translateSelectedEditors, {
      args: [big, 0],
      checker: arrowChecker
    }], [["ArrowUp", "mac+ArrowUp"], proto.translateSelectedEditors, {
      args: [0, -small],
      checker: arrowChecker
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto.translateSelectedEditors, {
      args: [0, -big],
      checker: arrowChecker
    }], [["ArrowDown", "mac+ArrowDown"], proto.translateSelectedEditors, {
      args: [0, small],
      checker: arrowChecker
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto.translateSelectedEditors, {
      args: [0, big],
      checker: arrowChecker
    }]]));
  }
  destroy() {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
    (_a2 = __privateGet(this, _updateModeCapability)) == null ? void 0 : _a2.resolve();
    __privateSet(this, _updateModeCapability, null);
    (_b = __privateGet(this, _abortController)) == null ? void 0 : _b.abort();
    __privateSet(this, _abortController, null);
    this._signal = null;
    for (const layer of __privateGet(this, _allLayers).values()) {
      layer.destroy();
    }
    __privateGet(this, _allLayers).clear();
    __privateGet(this, _allEditors).clear();
    __privateGet(this, _editorsToRescale).clear();
    (_c = __privateGet(this, _missingCanvases)) == null ? void 0 : _c.clear();
    __privateSet(this, _activeEditor, null);
    __privateGet(this, _selectedEditors).clear();
    __privateGet(this, _commandManager).destroy();
    (_d = __privateGet(this, _altTextManager)) == null ? void 0 : _d.destroy();
    (_e = __privateGet(this, _commentManager)) == null ? void 0 : _e.destroy();
    (_f = __privateGet(this, _signatureManager)) == null ? void 0 : _f.destroy();
    (_g = __privateGet(this, _floatingToolbar)) == null ? void 0 : _g.hide();
    __privateSet(this, _floatingToolbar, null);
    (_h = __privateGet(this, _mainHighlightColorPicker)) == null ? void 0 : _h.destroy();
    __privateSet(this, _mainHighlightColorPicker, null);
    __privateSet(this, _allEditableAnnotations, null);
    if (__privateGet(this, _focusMainContainerTimeoutId)) {
      clearTimeout(__privateGet(this, _focusMainContainerTimeoutId));
      __privateSet(this, _focusMainContainerTimeoutId, null);
    }
    if (__privateGet(this, _translationTimeoutId)) {
      clearTimeout(__privateGet(this, _translationTimeoutId));
      __privateSet(this, _translationTimeoutId, null);
    }
    (_i = this._editorUndoBar) == null ? void 0 : _i.destroy();
    __privateSet(this, _pdfDocument, null);
  }
  combinedSignal(ac) {
    return AbortSignal.any([this._signal, ac.signal]);
  }
  get mlManager() {
    return __privateGet(this, _mlManager);
  }
  get useNewAltTextFlow() {
    return __privateGet(this, _enableUpdatedAddImage);
  }
  get useNewAltTextWhenAddingImage() {
    return __privateGet(this, _enableNewAltTextWhenAddingImage);
  }
  get hcmFilter() {
    return shadow(this, "hcmFilter", __privateGet(this, _pageColors) ? __privateGet(this, _filterFactory).addHCMFilter(__privateGet(this, _pageColors).foreground, __privateGet(this, _pageColors).background) : "none");
  }
  get direction() {
    return shadow(this, "direction", getComputedStyle(__privateGet(this, _container)).direction);
  }
  get _highlightColors() {
    return shadow(this, "_highlightColors", __privateGet(this, _highlightColors) ? new Map(__privateGet(this, _highlightColors).split(",").map((pair) => {
      pair = pair.split("=").map((x) => x.trim());
      pair[1] = pair[1].toUpperCase();
      return pair;
    })) : null);
  }
  get highlightColors() {
    const {
      _highlightColors: _highlightColors2
    } = this;
    if (!_highlightColors2) {
      return shadow(this, "highlightColors", null);
    }
    const map = /* @__PURE__ */ new Map();
    const hasHCM = !!__privateGet(this, _pageColors);
    for (const [name, color] of _highlightColors2) {
      const isNameForHCM = name.endsWith("_HCM");
      if (hasHCM && isNameForHCM) {
        map.set(name.replace("_HCM", ""), color);
        continue;
      }
      if (!hasHCM && !isNameForHCM) {
        map.set(name, color);
      }
    }
    return shadow(this, "highlightColors", map);
  }
  get highlightColorNames() {
    return shadow(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e) => e.reverse())) : null);
  }
  getNonHCMColor(color) {
    if (!this._highlightColors) {
      return color;
    }
    const colorName = this.highlightColorNames.get(color);
    return this._highlightColors.get(colorName) || color;
  }
  getNonHCMColorName(color) {
    return this.highlightColorNames.get(color) || color;
  }
  setCurrentDrawingSession(layer) {
    if (layer) {
      this.unselectAll();
      this.disableUserSelect(true);
    } else {
      this.disableUserSelect(false);
    }
    __privateSet(this, _currentDrawingSession, layer);
  }
  setMainHighlightColorPicker(colorPicker) {
    __privateSet(this, _mainHighlightColorPicker, colorPicker);
  }
  editAltText(editor, firstTime = false) {
    var _a2;
    (_a2 = __privateGet(this, _altTextManager)) == null ? void 0 : _a2.editAltText(this, editor, firstTime);
  }
  hasCommentManager() {
    return !!__privateGet(this, _commentManager);
  }
  editComment(editor, posX, posY, options) {
    var _a2;
    (_a2 = __privateGet(this, _commentManager)) == null ? void 0 : _a2.showDialog(this, editor, posX, posY, options);
  }
  selectComment(pageIndex, uid) {
    const layer = __privateGet(this, _allLayers).get(pageIndex);
    const editor = layer == null ? void 0 : layer.getEditorByUID(uid);
    editor == null ? void 0 : editor.toggleComment(true, true);
  }
  updateComment(editor) {
    var _a2;
    (_a2 = __privateGet(this, _commentManager)) == null ? void 0 : _a2.updateComment(editor.getData());
  }
  updatePopupColor(editor) {
    var _a2;
    (_a2 = __privateGet(this, _commentManager)) == null ? void 0 : _a2.updatePopupColor(editor);
  }
  removeComment(editor) {
    var _a2;
    (_a2 = __privateGet(this, _commentManager)) == null ? void 0 : _a2.removeComments([editor.uid]);
  }
  toggleComment(editor, isSelected, visibility = void 0) {
    var _a2;
    (_a2 = __privateGet(this, _commentManager)) == null ? void 0 : _a2.toggleCommentPopup(editor, isSelected, visibility);
  }
  makeCommentColor(color, opacity) {
    var _a2;
    return color && ((_a2 = __privateGet(this, _commentManager)) == null ? void 0 : _a2.makeCommentColor(color, opacity)) || null;
  }
  getCommentDialogElement() {
    var _a2;
    return ((_a2 = __privateGet(this, _commentManager)) == null ? void 0 : _a2.dialogElement) || null;
  }
  async waitForEditorsRendered(pageNumber) {
    if (__privateGet(this, _allLayers).has(pageNumber - 1)) {
      return;
    }
    const {
      resolve,
      promise
    } = Promise.withResolvers();
    const onEditorsRendered = (evt) => {
      if (evt.pageNumber === pageNumber) {
        this._eventBus._off("editorsrendered", onEditorsRendered);
        resolve();
      }
    };
    this._eventBus.on("editorsrendered", onEditorsRendered);
    await promise;
  }
  getSignature(editor) {
    var _a2;
    (_a2 = __privateGet(this, _signatureManager)) == null ? void 0 : _a2.getSignature({
      uiManager: this,
      editor
    });
  }
  get signatureManager() {
    return __privateGet(this, _signatureManager);
  }
  switchToMode(mode, callback) {
    this._eventBus.on("annotationeditormodechanged", callback, {
      once: true,
      signal: this._signal
    });
    this._eventBus.dispatch("showannotationeditorui", {
      source: this,
      mode
    });
  }
  setPreference(name, value) {
    this._eventBus.dispatch("setpreference", {
      source: this,
      name,
      value
    });
  }
  onSetPreference({
    name,
    value
  }) {
    switch (name) {
      case "enableNewAltTextWhenAddingImage":
        __privateSet(this, _enableNewAltTextWhenAddingImage, value);
        break;
    }
  }
  onPageChanging({
    pageNumber
  }) {
    __privateSet(this, _currentPageIndex, pageNumber - 1);
  }
  focusMainContainer() {
    __privateGet(this, _container).focus();
  }
  findParent(x, y) {
    for (const layer of __privateGet(this, _allLayers).values()) {
      const {
        x: layerX,
        y: layerY,
        width,
        height
      } = layer.div.getBoundingClientRect();
      if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {
        return layer;
      }
    }
    return null;
  }
  disableUserSelect(value = false) {
    __privateGet(this, _viewer).classList.toggle("noUserSelect", value);
  }
  addShouldRescale(editor) {
    __privateGet(this, _editorsToRescale).add(editor);
  }
  removeShouldRescale(editor) {
    __privateGet(this, _editorsToRescale).delete(editor);
  }
  onScaleChanging({
    scale
  }) {
    var _a2;
    this.commitOrRemove();
    this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;
    for (const editor of __privateGet(this, _editorsToRescale)) {
      editor.onScaleChanging();
    }
    (_a2 = __privateGet(this, _currentDrawingSession)) == null ? void 0 : _a2.onScaleChanging();
  }
  onRotationChanging({
    pagesRotation
  }) {
    this.commitOrRemove();
    this.viewParameters.rotation = pagesRotation;
  }
  highlightSelection(methodOfCreation = "", comment = false) {
    const selection = document.getSelection();
    if (!selection || selection.isCollapsed) {
      return;
    }
    const {
      anchorNode,
      anchorOffset,
      focusNode,
      focusOffset
    } = selection;
    const text = selection.toString();
    const anchorElement = __privateMethod(this, _getAnchorElementForSelection, getAnchorElementForSelection_fn).call(this, selection);
    const textLayer = anchorElement.closest(".textLayer");
    const boxes = this.getSelectionBoxes(textLayer);
    if (!boxes) {
      return;
    }
    selection.empty();
    const layer = __privateMethod(this, _getLayerForTextLayer, getLayerForTextLayer_fn).call(this, textLayer);
    const isNoneMode = __privateGet(this, _mode) === AnnotationEditorType.NONE;
    const callback = () => {
      const editor = layer == null ? void 0 : layer.createAndAddNewEditor({
        x: 0,
        y: 0
      }, false, {
        methodOfCreation,
        boxes,
        anchorNode,
        anchorOffset,
        focusNode,
        focusOffset,
        text
      });
      if (isNoneMode) {
        this.showAllEditors("highlight", true, true);
      }
      if (comment) {
        editor == null ? void 0 : editor.editComment();
      }
    };
    if (isNoneMode) {
      this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);
      return;
    }
    callback();
  }
  commentSelection(methodOfCreation = "") {
    this.highlightSelection(methodOfCreation, true);
  }
  getAndRemoveDataFromAnnotationStorage(annotationId) {
    if (!__privateGet(this, _annotationStorage)) {
      return null;
    }
    const key = `${AnnotationEditorPrefix}${annotationId}`;
    const storedValue = __privateGet(this, _annotationStorage).getRawValue(key);
    if (storedValue) {
      __privateGet(this, _annotationStorage).remove(key);
    }
    return storedValue;
  }
  addToAnnotationStorage(editor) {
    if (!editor.isEmpty() && __privateGet(this, _annotationStorage) && !__privateGet(this, _annotationStorage).has(editor.id)) {
      __privateGet(this, _annotationStorage).setValue(editor.id, editor);
    }
  }
  a11yAlert(messageId, args = null) {
    const viewerAlert = __privateGet(this, _viewerAlert);
    if (!viewerAlert) {
      return;
    }
    viewerAlert.setAttribute("data-l10n-id", messageId);
    if (args) {
      viewerAlert.setAttribute("data-l10n-args", JSON.stringify(args));
    } else {
      viewerAlert.removeAttribute("data-l10n-args");
    }
  }
  blur() {
    this.isShiftKeyDown = false;
    if (__privateGet(this, _highlightWhenShiftUp)) {
      __privateSet(this, _highlightWhenShiftUp, false);
      __privateMethod(this, _onSelectEnd, onSelectEnd_fn).call(this, "main_toolbar");
    }
    if (!this.hasSelection) {
      return;
    }
    const {
      activeElement
    } = document;
    for (const editor of __privateGet(this, _selectedEditors)) {
      if (editor.div.contains(activeElement)) {
        __privateSet(this, _lastActiveElement, [editor, activeElement]);
        editor._focusEventsAllowed = false;
        break;
      }
    }
  }
  focus() {
    if (!__privateGet(this, _lastActiveElement)) {
      return;
    }
    const [lastEditor, lastActiveElement] = __privateGet(this, _lastActiveElement);
    __privateSet(this, _lastActiveElement, null);
    lastActiveElement.addEventListener("focusin", () => {
      lastEditor._focusEventsAllowed = true;
    }, {
      once: true,
      signal: this._signal
    });
    lastActiveElement.focus();
  }
  addEditListeners() {
    __privateMethod(this, _addKeyboardManager, addKeyboardManager_fn).call(this);
    __privateMethod(this, _addCopyPasteListeners, addCopyPasteListeners_fn).call(this);
  }
  removeEditListeners() {
    __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
    __privateMethod(this, _removeCopyPasteListeners, removeCopyPasteListeners_fn).call(this);
  }
  dragOver(event) {
    for (const {
      type
    } of event.dataTransfer.items) {
      for (const editorType of __privateGet(this, _editorTypes)) {
        if (editorType.isHandlingMimeForPasting(type)) {
          event.dataTransfer.dropEffect = "copy";
          event.preventDefault();
          return;
        }
      }
    }
  }
  drop(event) {
    for (const item of event.dataTransfer.items) {
      for (const editorType of __privateGet(this, _editorTypes)) {
        if (editorType.isHandlingMimeForPasting(item.type)) {
          editorType.paste(item, this.currentLayer);
          event.preventDefault();
          return;
        }
      }
    }
  }
  copy(event) {
    var _a2;
    event.preventDefault();
    (_a2 = __privateGet(this, _activeEditor)) == null ? void 0 : _a2.commitOrRemove();
    if (!this.hasSelection) {
      return;
    }
    const editors = [];
    for (const editor of __privateGet(this, _selectedEditors)) {
      const serialized = editor.serialize(true);
      if (serialized) {
        editors.push(serialized);
      }
    }
    if (editors.length === 0) {
      return;
    }
    event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
  }
  cut(event) {
    this.copy(event);
    this.delete();
  }
  async paste(event) {
    event.preventDefault();
    const {
      clipboardData
    } = event;
    for (const item of clipboardData.items) {
      for (const editorType of __privateGet(this, _editorTypes)) {
        if (editorType.isHandlingMimeForPasting(item.type)) {
          editorType.paste(item, this.currentLayer);
          return;
        }
      }
    }
    let data = clipboardData.getData("application/pdfjs");
    if (!data) {
      return;
    }
    try {
      data = JSON.parse(data);
    } catch (ex) {
      warn(`paste: "${ex.message}".`);
      return;
    }
    if (!Array.isArray(data)) {
      return;
    }
    this.unselectAll();
    const layer = this.currentLayer;
    try {
      const newEditors = [];
      for (const editor of data) {
        const deserializedEditor = await layer.deserialize(editor);
        if (!deserializedEditor) {
          return;
        }
        newEditors.push(deserializedEditor);
      }
      const cmd = () => {
        for (const editor of newEditors) {
          __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor);
        }
        __privateMethod(this, _selectEditors, selectEditors_fn).call(this, newEditors);
      };
      const undo = () => {
        for (const editor of newEditors) {
          editor.remove();
        }
      };
      this.addCommands({
        cmd,
        undo,
        mustExec: true
      });
    } catch (ex) {
      warn(`paste: "${ex.message}".`);
    }
  }
  keydown(event) {
    if (!this.isShiftKeyDown && event.key === "Shift") {
      this.isShiftKeyDown = true;
    }
    if (__privateGet(this, _mode) !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {
      _AnnotationEditorUIManager._keyboardManager.exec(this, event);
    }
  }
  keyup(event) {
    if (this.isShiftKeyDown && event.key === "Shift") {
      this.isShiftKeyDown = false;
      if (__privateGet(this, _highlightWhenShiftUp)) {
        __privateSet(this, _highlightWhenShiftUp, false);
        __privateMethod(this, _onSelectEnd, onSelectEnd_fn).call(this, "main_toolbar");
      }
    }
  }
  onEditingAction({
    name
  }) {
    switch (name) {
      case "undo":
      case "redo":
      case "delete":
      case "selectAll":
        this[name]();
        break;
      case "highlightSelection":
        this.highlightSelection("context_menu");
        break;
      case "commentSelection":
        this.commentSelection("context_menu");
        break;
    }
  }
  setEditingState(isEditing) {
    if (isEditing) {
      __privateMethod(this, _addFocusManager, addFocusManager_fn).call(this);
      __privateMethod(this, _addCopyPasteListeners, addCopyPasteListeners_fn).call(this);
      __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
        isEditing: __privateGet(this, _mode) !== AnnotationEditorType.NONE,
        isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this),
        hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
        hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
        hasSelectedEditor: false
      });
    } else {
      __privateMethod(this, _removeFocusManager, removeFocusManager_fn).call(this);
      __privateMethod(this, _removeCopyPasteListeners, removeCopyPasteListeners_fn).call(this);
      __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
        isEditing: false
      });
      this.disableUserSelect(false);
    }
  }
  registerEditorTypes(types) {
    if (__privateGet(this, _editorTypes)) {
      return;
    }
    __privateSet(this, _editorTypes, types);
    for (const editorType of __privateGet(this, _editorTypes)) {
      __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editorType.defaultPropertiesToUpdate);
    }
  }
  getId() {
    return __privateGet(this, _idManager).id;
  }
  get currentLayer() {
    return __privateGet(this, _allLayers).get(__privateGet(this, _currentPageIndex));
  }
  getLayer(pageIndex) {
    return __privateGet(this, _allLayers).get(pageIndex);
  }
  get currentPageIndex() {
    return __privateGet(this, _currentPageIndex);
  }
  addLayer(layer) {
    __privateGet(this, _allLayers).set(layer.pageIndex, layer);
    if (__privateGet(this, _isEnabled)) {
      layer.enable();
    } else {
      layer.disable();
    }
  }
  removeLayer(layer) {
    __privateGet(this, _allLayers).delete(layer.pageIndex);
  }
  async updateMode(mode, editId = null, isFromKeyboard = false, mustEnterInEditMode = false, editComment = false) {
    var _a2, _b, _c, _d, _e, _f;
    if (__privateGet(this, _mode) === mode) {
      return;
    }
    if (__privateGet(this, _updateModeCapability)) {
      await __privateGet(this, _updateModeCapability).promise;
      if (!__privateGet(this, _updateModeCapability)) {
        return;
      }
    }
    __privateSet(this, _updateModeCapability, Promise.withResolvers());
    (_a2 = __privateGet(this, _currentDrawingSession)) == null ? void 0 : _a2.commitOrRemove();
    if (__privateGet(this, _mode) === AnnotationEditorType.POPUP) {
      (_b = __privateGet(this, _commentManager)) == null ? void 0 : _b.hideSidebar();
    }
    (_c = __privateGet(this, _commentManager)) == null ? void 0 : _c.destroyPopup();
    __privateSet(this, _mode, mode);
    if (mode === AnnotationEditorType.NONE) {
      this.setEditingState(false);
      __privateMethod(this, _disableAll, disableAll_fn).call(this);
      for (const editor of __privateGet(this, _allEditors).values()) {
        editor.hideStandaloneCommentButton();
      }
      (_d = this._editorUndoBar) == null ? void 0 : _d.hide();
      this.toggleComment(null);
      __privateGet(this, _updateModeCapability).resolve();
      return;
    }
    for (const editor of __privateGet(this, _allEditors).values()) {
      editor.addStandaloneCommentButton();
    }
    if (mode === AnnotationEditorType.SIGNATURE) {
      await ((_e = __privateGet(this, _signatureManager)) == null ? void 0 : _e.loadSignatures());
    }
    this.setEditingState(true);
    await __privateMethod(this, _enableAll, enableAll_fn).call(this);
    this.unselectAll();
    for (const layer of __privateGet(this, _allLayers).values()) {
      layer.updateMode(mode);
    }
    if (mode === AnnotationEditorType.POPUP) {
      __privateGet(this, _allEditableAnnotations) || __privateSet(this, _allEditableAnnotations, await __privateGet(this, _pdfDocument).getAnnotationsByType(new Set(__privateGet(this, _editorTypes).map((editorClass) => editorClass._editorType))));
      const elementIds = /* @__PURE__ */ new Set();
      const allComments = [];
      for (const editor of __privateGet(this, _allEditors).values()) {
        const {
          annotationElementId,
          hasComment,
          deleted
        } = editor;
        if (annotationElementId) {
          elementIds.add(annotationElementId);
        }
        if (hasComment && !deleted) {
          allComments.push(editor.getData());
        }
      }
      for (const annotation of __privateGet(this, _allEditableAnnotations)) {
        const {
          id,
          popupRef,
          contentsObj
        } = annotation;
        if (popupRef && (contentsObj == null ? void 0 : contentsObj.str) && !elementIds.has(id) && !__privateGet(this, _deletedAnnotationsElementIds).has(id)) {
          allComments.push(annotation);
        }
      }
      (_f = __privateGet(this, _commentManager)) == null ? void 0 : _f.showSidebar(allComments);
    }
    if (!editId) {
      if (isFromKeyboard) {
        this.addNewEditorFromKeyboard();
      }
      __privateGet(this, _updateModeCapability).resolve();
      return;
    }
    for (const editor of __privateGet(this, _allEditors).values()) {
      if (editor.uid === editId) {
        this.setSelected(editor);
        if (editComment) {
          editor.editComment();
        } else if (mustEnterInEditMode) {
          editor.enterInEditMode();
        } else {
          editor.focus();
        }
      } else {
        editor.unselect();
      }
    }
    __privateGet(this, _updateModeCapability).resolve();
  }
  addNewEditorFromKeyboard() {
    if (this.currentLayer.canCreateNewEmptyEditor()) {
      this.currentLayer.addNewEditor();
    }
  }
  updateToolbar(options) {
    if (options.mode === __privateGet(this, _mode)) {
      return;
    }
    this._eventBus.dispatch("switchannotationeditormode", {
      source: this,
      ...options
    });
  }
  updateParams(type, value) {
    if (!__privateGet(this, _editorTypes)) {
      return;
    }
    switch (type) {
      case AnnotationEditorParamsType.CREATE:
        this.currentLayer.addNewEditor(value);
        return;
      case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:
        this._eventBus.dispatch("reporttelemetry", {
          source: this,
          details: {
            type: "editing",
            data: {
              type: "highlight",
              action: "toggle_visibility"
            }
          }
        });
        (__privateGet(this, _showAllStates) || __privateSet(this, _showAllStates, /* @__PURE__ */ new Map())).set(type, value);
        this.showAllEditors("highlight", value);
        break;
    }
    if (this.hasSelection) {
      for (const editor of __privateGet(this, _selectedEditors)) {
        editor.updateParams(type, value);
      }
    } else {
      for (const editorType of __privateGet(this, _editorTypes)) {
        editorType.updateDefaultParams(type, value);
      }
    }
  }
  showAllEditors(type, visible, updateButton = false) {
    var _a2;
    for (const editor of __privateGet(this, _allEditors).values()) {
      if (editor.editorType === type) {
        editor.show(visible);
      }
    }
    const state = ((_a2 = __privateGet(this, _showAllStates)) == null ? void 0 : _a2.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL)) ?? true;
    if (state !== visible) {
      __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, [[AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL, visible]]);
    }
  }
  enableWaiting(mustWait = false) {
    if (__privateGet(this, _isWaiting) === mustWait) {
      return;
    }
    __privateSet(this, _isWaiting, mustWait);
    for (const layer of __privateGet(this, _allLayers).values()) {
      if (mustWait) {
        layer.disableClick();
      } else {
        layer.enableClick();
      }
      layer.div.classList.toggle("waiting", mustWait);
    }
  }
  *getEditors(pageIndex) {
    for (const editor of __privateGet(this, _allEditors).values()) {
      if (editor.pageIndex === pageIndex) {
        yield editor;
      }
    }
  }
  getEditor(id) {
    return __privateGet(this, _allEditors).get(id);
  }
  addEditor(editor) {
    __privateGet(this, _allEditors).set(editor.id, editor);
  }
  removeEditor(editor) {
    var _a2, _b;
    if (editor.div.contains(document.activeElement)) {
      if (__privateGet(this, _focusMainContainerTimeoutId)) {
        clearTimeout(__privateGet(this, _focusMainContainerTimeoutId));
      }
      __privateSet(this, _focusMainContainerTimeoutId, setTimeout(() => {
        this.focusMainContainer();
        __privateSet(this, _focusMainContainerTimeoutId, null);
      }, 0));
    }
    __privateGet(this, _allEditors).delete(editor.id);
    if (editor.annotationElementId) {
      (_a2 = __privateGet(this, _missingCanvases)) == null ? void 0 : _a2.delete(editor.annotationElementId);
    }
    this.unselect(editor);
    if (!editor.annotationElementId || !__privateGet(this, _deletedAnnotationsElementIds).has(editor.annotationElementId)) {
      (_b = __privateGet(this, _annotationStorage)) == null ? void 0 : _b.remove(editor.id);
    }
  }
  addDeletedAnnotationElement(editor) {
    __privateGet(this, _deletedAnnotationsElementIds).add(editor.annotationElementId);
    this.addChangedExistingAnnotation(editor);
    editor.deleted = true;
  }
  isDeletedAnnotationElement(annotationElementId) {
    return __privateGet(this, _deletedAnnotationsElementIds).has(annotationElementId);
  }
  removeDeletedAnnotationElement(editor) {
    __privateGet(this, _deletedAnnotationsElementIds).delete(editor.annotationElementId);
    this.removeChangedExistingAnnotation(editor);
    editor.deleted = false;
  }
  setActiveEditor(editor) {
    if (__privateGet(this, _activeEditor) === editor) {
      return;
    }
    __privateSet(this, _activeEditor, editor);
    if (editor) {
      __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
    }
  }
  updateUI(editor) {
    if (__privateGet(this, _lastSelectedEditor, lastSelectedEditor_get) === editor) {
      __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
    }
  }
  updateUIForDefaultProperties(editorType) {
    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editorType.defaultPropertiesToUpdate);
  }
  toggleSelected(editor) {
    if (__privateGet(this, _selectedEditors).has(editor)) {
      __privateGet(this, _selectedEditors).delete(editor);
      editor.unselect();
      __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
        hasSelectedEditor: this.hasSelection
      });
      return;
    }
    __privateGet(this, _selectedEditors).add(editor);
    editor.select();
    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
      hasSelectedEditor: true
    });
  }
  setSelected(editor) {
    var _a2;
    this.updateToolbar({
      mode: editor.mode,
      editId: editor.id
    });
    (_a2 = __privateGet(this, _currentDrawingSession)) == null ? void 0 : _a2.commitOrRemove();
    for (const ed of __privateGet(this, _selectedEditors)) {
      if (ed !== editor) {
        ed.unselect();
      }
    }
    __privateGet(this, _selectedEditors).clear();
    __privateGet(this, _selectedEditors).add(editor);
    editor.select();
    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
      hasSelectedEditor: true
    });
  }
  isSelected(editor) {
    return __privateGet(this, _selectedEditors).has(editor);
  }
  get firstSelectedEditor() {
    return __privateGet(this, _selectedEditors).values().next().value;
  }
  unselect(editor) {
    editor.unselect();
    __privateGet(this, _selectedEditors).delete(editor);
    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
      hasSelectedEditor: this.hasSelection
    });
  }
  get hasSelection() {
    return __privateGet(this, _selectedEditors).size !== 0;
  }
  get isEnterHandled() {
    return __privateGet(this, _selectedEditors).size === 1 && this.firstSelectedEditor.isEnterHandled;
  }
  undo() {
    var _a2;
    __privateGet(this, _commandManager).undo();
    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
      hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
      hasSomethingToRedo: true,
      isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
    });
    (_a2 = this._editorUndoBar) == null ? void 0 : _a2.hide();
  }
  redo() {
    __privateGet(this, _commandManager).redo();
    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
      hasSomethingToUndo: true,
      hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
      isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
    });
  }
  addCommands(params) {
    __privateGet(this, _commandManager).add(params);
    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
      hasSomethingToUndo: true,
      hasSomethingToRedo: false,
      isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
    });
  }
  cleanUndoStack(type) {
    __privateGet(this, _commandManager).cleanType(type);
  }
  delete() {
    var _a2;
    this.commitOrRemove();
    const drawingEditor = (_a2 = this.currentLayer) == null ? void 0 : _a2.endDrawingSession(true);
    if (!this.hasSelection && !drawingEditor) {
      return;
    }
    const editors = drawingEditor ? [drawingEditor] : [...__privateGet(this, _selectedEditors)];
    const cmd = () => {
      var _a3;
      (_a3 = this._editorUndoBar) == null ? void 0 : _a3.show(undo, editors.length === 1 ? editors[0].editorType : editors.length);
      for (const editor of editors) {
        editor.remove();
      }
    };
    const undo = () => {
      for (const editor of editors) {
        __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor);
      }
    };
    this.addCommands({
      cmd,
      undo,
      mustExec: true
    });
  }
  commitOrRemove() {
    var _a2;
    (_a2 = __privateGet(this, _activeEditor)) == null ? void 0 : _a2.commitOrRemove();
  }
  hasSomethingToControl() {
    return __privateGet(this, _activeEditor) || this.hasSelection;
  }
  selectAll() {
    for (const editor of __privateGet(this, _selectedEditors)) {
      editor.commit();
    }
    __privateMethod(this, _selectEditors, selectEditors_fn).call(this, __privateGet(this, _allEditors).values());
  }
  unselectAll() {
    var _a2;
    if (__privateGet(this, _activeEditor)) {
      __privateGet(this, _activeEditor).commitOrRemove();
      if (__privateGet(this, _mode) !== AnnotationEditorType.NONE) {
        return;
      }
    }
    if ((_a2 = __privateGet(this, _currentDrawingSession)) == null ? void 0 : _a2.commitOrRemove()) {
      return;
    }
    if (!this.hasSelection) {
      return;
    }
    for (const editor of __privateGet(this, _selectedEditors)) {
      editor.unselect();
    }
    __privateGet(this, _selectedEditors).clear();
    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
      hasSelectedEditor: false
    });
  }
  translateSelectedEditors(x, y, noCommit = false) {
    if (!noCommit) {
      this.commitOrRemove();
    }
    if (!this.hasSelection) {
      return;
    }
    __privateGet(this, _translation)[0] += x;
    __privateGet(this, _translation)[1] += y;
    const [totalX, totalY] = __privateGet(this, _translation);
    const editors = [...__privateGet(this, _selectedEditors)];
    const TIME_TO_WAIT = 1e3;
    if (__privateGet(this, _translationTimeoutId)) {
      clearTimeout(__privateGet(this, _translationTimeoutId));
    }
    __privateSet(this, _translationTimeoutId, setTimeout(() => {
      __privateSet(this, _translationTimeoutId, null);
      __privateGet(this, _translation)[0] = __privateGet(this, _translation)[1] = 0;
      this.addCommands({
        cmd: () => {
          for (const editor of editors) {
            if (__privateGet(this, _allEditors).has(editor.id)) {
              editor.translateInPage(totalX, totalY);
              editor.translationDone();
            }
          }
        },
        undo: () => {
          for (const editor of editors) {
            if (__privateGet(this, _allEditors).has(editor.id)) {
              editor.translateInPage(-totalX, -totalY);
              editor.translationDone();
            }
          }
        },
        mustExec: false
      });
    }, TIME_TO_WAIT));
    for (const editor of editors) {
      editor.translateInPage(x, y);
      editor.translationDone();
    }
  }
  setUpDragSession() {
    if (!this.hasSelection) {
      return;
    }
    this.disableUserSelect(true);
    __privateSet(this, _draggingEditors, /* @__PURE__ */ new Map());
    for (const editor of __privateGet(this, _selectedEditors)) {
      __privateGet(this, _draggingEditors).set(editor, {
        savedX: editor.x,
        savedY: editor.y,
        savedPageIndex: editor.pageIndex,
        newX: 0,
        newY: 0,
        newPageIndex: -1
      });
    }
  }
  endDragSession() {
    if (!__privateGet(this, _draggingEditors)) {
      return false;
    }
    this.disableUserSelect(false);
    const map = __privateGet(this, _draggingEditors);
    __privateSet(this, _draggingEditors, null);
    let mustBeAddedInUndoStack = false;
    for (const [{
      x,
      y,
      pageIndex
    }, value] of map) {
      value.newX = x;
      value.newY = y;
      value.newPageIndex = pageIndex;
      mustBeAddedInUndoStack || (mustBeAddedInUndoStack = x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex);
    }
    if (!mustBeAddedInUndoStack) {
      return false;
    }
    const move = (editor, x, y, pageIndex) => {
      if (__privateGet(this, _allEditors).has(editor.id)) {
        const parent = __privateGet(this, _allLayers).get(pageIndex);
        if (parent) {
          editor._setParentAndPosition(parent, x, y);
        } else {
          editor.pageIndex = pageIndex;
          editor.x = x;
          editor.y = y;
        }
      }
    };
    this.addCommands({
      cmd: () => {
        for (const [editor, {
          newX,
          newY,
          newPageIndex
        }] of map) {
          move(editor, newX, newY, newPageIndex);
        }
      },
      undo: () => {
        for (const [editor, {
          savedX,
          savedY,
          savedPageIndex
        }] of map) {
          move(editor, savedX, savedY, savedPageIndex);
        }
      },
      mustExec: true
    });
    return true;
  }
  dragSelectedEditors(tx, ty) {
    if (!__privateGet(this, _draggingEditors)) {
      return;
    }
    for (const editor of __privateGet(this, _draggingEditors).keys()) {
      editor.drag(tx, ty);
    }
  }
  rebuild(editor) {
    if (editor.parent === null) {
      const parent = this.getLayer(editor.pageIndex);
      if (parent) {
        parent.changeParent(editor);
        parent.addOrRebuild(editor);
      } else {
        this.addEditor(editor);
        this.addToAnnotationStorage(editor);
        editor.rebuild();
      }
    } else {
      editor.parent.addOrRebuild(editor);
    }
  }
  get isEditorHandlingKeyboard() {
    var _a2;
    return ((_a2 = this.getActive()) == null ? void 0 : _a2.shouldGetKeyboardEvents()) || __privateGet(this, _selectedEditors).size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
  }
  isActive(editor) {
    return __privateGet(this, _activeEditor) === editor;
  }
  getActive() {
    return __privateGet(this, _activeEditor);
  }
  getMode() {
    return __privateGet(this, _mode);
  }
  isEditingMode() {
    return __privateGet(this, _mode) !== AnnotationEditorType.NONE;
  }
  get imageManager() {
    return shadow(this, "imageManager", new ImageManager());
  }
  getSelectionBoxes(textLayer) {
    if (!textLayer) {
      return null;
    }
    const selection = document.getSelection();
    for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
      if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {
        return null;
      }
    }
    const {
      x: layerX,
      y: layerY,
      width: parentWidth,
      height: parentHeight
    } = textLayer.getBoundingClientRect();
    let rotator;
    switch (textLayer.getAttribute("data-main-rotation")) {
      case "90":
        rotator = (x, y, w, h) => ({
          x: (y - layerY) / parentHeight,
          y: 1 - (x + w - layerX) / parentWidth,
          width: h / parentHeight,
          height: w / parentWidth
        });
        break;
      case "180":
        rotator = (x, y, w, h) => ({
          x: 1 - (x + w - layerX) / parentWidth,
          y: 1 - (y + h - layerY) / parentHeight,
          width: w / parentWidth,
          height: h / parentHeight
        });
        break;
      case "270":
        rotator = (x, y, w, h) => ({
          x: 1 - (y + h - layerY) / parentHeight,
          y: (x - layerX) / parentWidth,
          width: h / parentHeight,
          height: w / parentWidth
        });
        break;
      default:
        rotator = (x, y, w, h) => ({
          x: (x - layerX) / parentWidth,
          y: (y - layerY) / parentHeight,
          width: w / parentWidth,
          height: h / parentHeight
        });
        break;
    }
    const boxes = [];
    for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
      const range = selection.getRangeAt(i);
      if (range.collapsed) {
        continue;
      }
      for (const {
        x,
        y,
        width,
        height
      } of range.getClientRects()) {
        if (width === 0 || height === 0) {
          continue;
        }
        boxes.push(rotator(x, y, width, height));
      }
    }
    return boxes.length === 0 ? null : boxes;
  }
  addChangedExistingAnnotation({
    annotationElementId,
    id
  }) {
    (__privateGet(this, _changedExistingAnnotations) || __privateSet(this, _changedExistingAnnotations, /* @__PURE__ */ new Map())).set(annotationElementId, id);
  }
  removeChangedExistingAnnotation({
    annotationElementId
  }) {
    var _a2;
    (_a2 = __privateGet(this, _changedExistingAnnotations)) == null ? void 0 : _a2.delete(annotationElementId);
  }
  renderAnnotationElement(annotation) {
    var _a2;
    const editorId = (_a2 = __privateGet(this, _changedExistingAnnotations)) == null ? void 0 : _a2.get(annotation.data.id);
    if (!editorId) {
      return;
    }
    const editor = __privateGet(this, _annotationStorage).getRawValue(editorId);
    if (!editor) {
      return;
    }
    if (__privateGet(this, _mode) === AnnotationEditorType.NONE && !editor.hasBeenModified) {
      return;
    }
    editor.renderAnnotationElement(annotation);
  }
  setMissingCanvas(annotationId, annotationElementId, canvas) {
    var _a2;
    const editor = (_a2 = __privateGet(this, _missingCanvases)) == null ? void 0 : _a2.get(annotationId);
    if (!editor) {
      return;
    }
    editor.setCanvas(annotationElementId, canvas);
    __privateGet(this, _missingCanvases).delete(annotationId);
  }
  addMissingCanvas(annotationId, editor) {
    (__privateGet(this, _missingCanvases) || __privateSet(this, _missingCanvases, /* @__PURE__ */ new Map())).set(annotationId, editor);
  }
};
_abortController = new WeakMap();
_activeEditor = new WeakMap();
_allEditableAnnotations = new WeakMap();
_allEditors = new WeakMap();
_allLayers = new WeakMap();
_altTextManager = new WeakMap();
_annotationStorage = new WeakMap();
_changedExistingAnnotations = new WeakMap();
_commandManager = new WeakMap();
_commentManager = new WeakMap();
_copyPasteAC = new WeakMap();
_currentDrawingSession = new WeakMap();
_currentPageIndex = new WeakMap();
_deletedAnnotationsElementIds = new WeakMap();
_draggingEditors = new WeakMap();
_editorTypes = new WeakMap();
_editorsToRescale = new WeakMap();
_enableHighlightFloatingButton = new WeakMap();
_enableUpdatedAddImage = new WeakMap();
_enableNewAltTextWhenAddingImage = new WeakMap();
_filterFactory = new WeakMap();
_focusMainContainerTimeoutId = new WeakMap();
_focusManagerAC = new WeakMap();
_highlightColors = new WeakMap();
_highlightWhenShiftUp = new WeakMap();
_floatingToolbar = new WeakMap();
_idManager = new WeakMap();
_isEnabled = new WeakMap();
_isPointerDown = new WeakMap();
_isWaiting = new WeakMap();
_keyboardManagerAC = new WeakMap();
_lastActiveElement = new WeakMap();
_mainHighlightColorPicker = new WeakMap();
_missingCanvases = new WeakMap();
_mlManager = new WeakMap();
_mode = new WeakMap();
_selectedEditors = new WeakMap();
_selectedTextNode = new WeakMap();
_signatureManager = new WeakMap();
_pageColors = new WeakMap();
_showAllStates = new WeakMap();
_pdfDocument = new WeakMap();
_previousStates = new WeakMap();
_translation = new WeakMap();
_translationTimeoutId = new WeakMap();
_container = new WeakMap();
_viewer = new WeakMap();
_viewerAlert = new WeakMap();
_updateModeCapability = new WeakMap();
_getAnchorElementForSelection = new WeakSet();
getAnchorElementForSelection_fn = function({
  anchorNode
}) {
  return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;
};
_getLayerForTextLayer = new WeakSet();
getLayerForTextLayer_fn = function(textLayer) {
  const {
    currentLayer
  } = this;
  if (currentLayer.hasTextLayer(textLayer)) {
    return currentLayer;
  }
  for (const layer of __privateGet(this, _allLayers).values()) {
    if (layer.hasTextLayer(textLayer)) {
      return layer;
    }
  }
  return null;
};
_displayFloatingToolbar = new WeakSet();
displayFloatingToolbar_fn = function() {
  const selection = document.getSelection();
  if (!selection || selection.isCollapsed) {
    return;
  }
  const anchorElement = __privateMethod(this, _getAnchorElementForSelection, getAnchorElementForSelection_fn).call(this, selection);
  const textLayer = anchorElement.closest(".textLayer");
  const boxes = this.getSelectionBoxes(textLayer);
  if (!boxes) {
    return;
  }
  __privateGet(this, _floatingToolbar) || __privateSet(this, _floatingToolbar, new FloatingToolbar(this));
  __privateGet(this, _floatingToolbar).show(textLayer, boxes, this.direction === "ltr");
};
_selectionChange = new WeakSet();
selectionChange_fn = function() {
  var _a2, _b, _c;
  const selection = document.getSelection();
  if (!selection || selection.isCollapsed) {
    if (__privateGet(this, _selectedTextNode)) {
      (_a2 = __privateGet(this, _floatingToolbar)) == null ? void 0 : _a2.hide();
      __privateSet(this, _selectedTextNode, null);
      __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
        hasSelectedText: false
      });
    }
    return;
  }
  const {
    anchorNode
  } = selection;
  if (anchorNode === __privateGet(this, _selectedTextNode)) {
    return;
  }
  const anchorElement = __privateMethod(this, _getAnchorElementForSelection, getAnchorElementForSelection_fn).call(this, selection);
  const textLayer = anchorElement.closest(".textLayer");
  if (!textLayer) {
    if (__privateGet(this, _selectedTextNode)) {
      (_b = __privateGet(this, _floatingToolbar)) == null ? void 0 : _b.hide();
      __privateSet(this, _selectedTextNode, null);
      __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
        hasSelectedText: false
      });
    }
    return;
  }
  (_c = __privateGet(this, _floatingToolbar)) == null ? void 0 : _c.hide();
  __privateSet(this, _selectedTextNode, anchorNode);
  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
    hasSelectedText: true
  });
  if (__privateGet(this, _mode) !== AnnotationEditorType.HIGHLIGHT && __privateGet(this, _mode) !== AnnotationEditorType.NONE) {
    return;
  }
  if (__privateGet(this, _mode) === AnnotationEditorType.HIGHLIGHT) {
    this.showAllEditors("highlight", true, true);
  }
  __privateSet(this, _highlightWhenShiftUp, this.isShiftKeyDown);
  if (!this.isShiftKeyDown) {
    const activeLayer = __privateGet(this, _mode) === AnnotationEditorType.HIGHLIGHT ? __privateMethod(this, _getLayerForTextLayer, getLayerForTextLayer_fn).call(this, textLayer) : null;
    activeLayer == null ? void 0 : activeLayer.toggleDrawing();
    if (__privateGet(this, _isPointerDown)) {
      const ac = new AbortController();
      const signal = this.combinedSignal(ac);
      const pointerup = (e) => {
        if (e.type === "pointerup" && e.button !== 0) {
          return;
        }
        ac.abort();
        activeLayer == null ? void 0 : activeLayer.toggleDrawing(true);
        if (e.type === "pointerup") {
          __privateMethod(this, _onSelectEnd, onSelectEnd_fn).call(this, "main_toolbar");
        }
      };
      window.addEventListener("pointerup", pointerup, {
        signal
      });
      window.addEventListener("blur", pointerup, {
        signal
      });
    } else {
      activeLayer == null ? void 0 : activeLayer.toggleDrawing(true);
      __privateMethod(this, _onSelectEnd, onSelectEnd_fn).call(this, "main_toolbar");
    }
  }
};
_onSelectEnd = new WeakSet();
onSelectEnd_fn = function(methodOfCreation = "") {
  if (__privateGet(this, _mode) === AnnotationEditorType.HIGHLIGHT) {
    this.highlightSelection(methodOfCreation);
  } else if (__privateGet(this, _enableHighlightFloatingButton)) {
    __privateMethod(this, _displayFloatingToolbar, displayFloatingToolbar_fn).call(this);
  }
};
_addSelectionListener = new WeakSet();
addSelectionListener_fn = function() {
  document.addEventListener("selectionchange", __privateMethod(this, _selectionChange, selectionChange_fn).bind(this), {
    signal: this._signal
  });
};
_addFocusManager = new WeakSet();
addFocusManager_fn = function() {
  if (__privateGet(this, _focusManagerAC)) {
    return;
  }
  __privateSet(this, _focusManagerAC, new AbortController());
  const signal = this.combinedSignal(__privateGet(this, _focusManagerAC));
  window.addEventListener("focus", this.focus.bind(this), {
    signal
  });
  window.addEventListener("blur", this.blur.bind(this), {
    signal
  });
};
_removeFocusManager = new WeakSet();
removeFocusManager_fn = function() {
  var _a2;
  (_a2 = __privateGet(this, _focusManagerAC)) == null ? void 0 : _a2.abort();
  __privateSet(this, _focusManagerAC, null);
};
_addKeyboardManager = new WeakSet();
addKeyboardManager_fn = function() {
  if (__privateGet(this, _keyboardManagerAC)) {
    return;
  }
  __privateSet(this, _keyboardManagerAC, new AbortController());
  const signal = this.combinedSignal(__privateGet(this, _keyboardManagerAC));
  window.addEventListener("keydown", this.keydown.bind(this), {
    signal
  });
  window.addEventListener("keyup", this.keyup.bind(this), {
    signal
  });
};
_removeKeyboardManager = new WeakSet();
removeKeyboardManager_fn = function() {
  var _a2;
  (_a2 = __privateGet(this, _keyboardManagerAC)) == null ? void 0 : _a2.abort();
  __privateSet(this, _keyboardManagerAC, null);
};
_addCopyPasteListeners = new WeakSet();
addCopyPasteListeners_fn = function() {
  if (__privateGet(this, _copyPasteAC)) {
    return;
  }
  __privateSet(this, _copyPasteAC, new AbortController());
  const signal = this.combinedSignal(__privateGet(this, _copyPasteAC));
  document.addEventListener("copy", this.copy.bind(this), {
    signal
  });
  document.addEventListener("cut", this.cut.bind(this), {
    signal
  });
  document.addEventListener("paste", this.paste.bind(this), {
    signal
  });
};
_removeCopyPasteListeners = new WeakSet();
removeCopyPasteListeners_fn = function() {
  var _a2;
  (_a2 = __privateGet(this, _copyPasteAC)) == null ? void 0 : _a2.abort();
  __privateSet(this, _copyPasteAC, null);
};
_addDragAndDropListeners = new WeakSet();
addDragAndDropListeners_fn = function() {
  const signal = this._signal;
  document.addEventListener("dragover", this.dragOver.bind(this), {
    signal
  });
  document.addEventListener("drop", this.drop.bind(this), {
    signal
  });
};
_dispatchUpdateStates = new WeakSet();
dispatchUpdateStates_fn = function(details) {
  const hasChanged = Object.entries(details).some(([key, value]) => __privateGet(this, _previousStates)[key] !== value);
  if (hasChanged) {
    this._eventBus.dispatch("annotationeditorstateschanged", {
      source: this,
      details: Object.assign(__privateGet(this, _previousStates), details)
    });
    if (__privateGet(this, _mode) === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {
      __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, [[AnnotationEditorParamsType.HIGHLIGHT_FREE, true]]);
    }
  }
};
_dispatchUpdateUI = new WeakSet();
dispatchUpdateUI_fn = function(details) {
  this._eventBus.dispatch("annotationeditorparamschanged", {
    source: this,
    details
  });
};
_enableAll = new WeakSet();
enableAll_fn = async function() {
  if (!__privateGet(this, _isEnabled)) {
    __privateSet(this, _isEnabled, true);
    const promises = [];
    for (const layer of __privateGet(this, _allLayers).values()) {
      promises.push(layer.enable());
    }
    await Promise.all(promises);
    for (const editor of __privateGet(this, _allEditors).values()) {
      editor.enable();
    }
  }
};
_disableAll = new WeakSet();
disableAll_fn = function() {
  this.unselectAll();
  if (__privateGet(this, _isEnabled)) {
    __privateSet(this, _isEnabled, false);
    for (const layer of __privateGet(this, _allLayers).values()) {
      layer.disable();
    }
    for (const editor of __privateGet(this, _allEditors).values()) {
      editor.disable();
    }
  }
};
_addEditorToLayer = new WeakSet();
addEditorToLayer_fn = function(editor) {
  const layer = __privateGet(this, _allLayers).get(editor.pageIndex);
  if (layer) {
    layer.addOrRebuild(editor);
  } else {
    this.addEditor(editor);
    this.addToAnnotationStorage(editor);
  }
};
_lastSelectedEditor = new WeakSet();
lastSelectedEditor_get = function() {
  let ed = null;
  for (ed of __privateGet(this, _selectedEditors)) {
  }
  return ed;
};
_isEmpty = new WeakSet();
isEmpty_fn = function() {
  if (__privateGet(this, _allEditors).size === 0) {
    return true;
  }
  if (__privateGet(this, _allEditors).size === 1) {
    for (const editor of __privateGet(this, _allEditors).values()) {
      return editor.isEmpty();
    }
  }
  return false;
};
_selectEditors = new WeakSet();
selectEditors_fn = function(editors) {
  for (const editor of __privateGet(this, _selectedEditors)) {
    editor.unselect();
  }
  __privateGet(this, _selectedEditors).clear();
  for (const editor of editors) {
    if (editor.isEmpty()) {
      continue;
    }
    __privateGet(this, _selectedEditors).add(editor);
    editor.select();
  }
  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
    hasSelectedEditor: this.hasSelection
  });
};
__publicField(_AnnotationEditorUIManager, "TRANSLATE_SMALL", 1);
__publicField(_AnnotationEditorUIManager, "TRANSLATE_BIG", 10);
var AnnotationEditorUIManager = _AnnotationEditorUIManager;
var _altText2, _altTextDecorative, _altTextButton, _altTextButtonLabel, _altTextTooltip, _altTextTooltipTimeout, _altTextWasFromKeyBoard, _badge, _editor2, _guessedText, _textWithDisclaimer, _useNewAltTextFlow, _l10nNewButton, _label, label_get, _setState, setState_fn;
var _AltText = class _AltText {
  constructor(editor) {
    __privateAdd(this, _label);
    __privateAdd(this, _setState);
    __privateAdd(this, _altText2, null);
    __privateAdd(this, _altTextDecorative, false);
    __privateAdd(this, _altTextButton, null);
    __privateAdd(this, _altTextButtonLabel, null);
    __privateAdd(this, _altTextTooltip, null);
    __privateAdd(this, _altTextTooltipTimeout, null);
    __privateAdd(this, _altTextWasFromKeyBoard, false);
    __privateAdd(this, _badge, null);
    __privateAdd(this, _editor2, null);
    __privateAdd(this, _guessedText, null);
    __privateAdd(this, _textWithDisclaimer, null);
    __privateAdd(this, _useNewAltTextFlow, false);
    __privateSet(this, _editor2, editor);
    __privateSet(this, _useNewAltTextFlow, editor._uiManager.useNewAltTextFlow);
    __privateGet(_AltText, _l10nNewButton) || __privateSet(_AltText, _l10nNewButton, Object.freeze({
      added: "pdfjs-editor-new-alt-text-added-button",
      "added-label": "pdfjs-editor-new-alt-text-added-button-label",
      missing: "pdfjs-editor-new-alt-text-missing-button",
      "missing-label": "pdfjs-editor-new-alt-text-missing-button-label",
      review: "pdfjs-editor-new-alt-text-to-review-button",
      "review-label": "pdfjs-editor-new-alt-text-to-review-button-label"
    }));
  }
  static initialize(l10n) {
    _AltText._l10n ?? (_AltText._l10n = l10n);
  }
  async render() {
    const altText = __privateSet(this, _altTextButton, document.createElement("button"));
    altText.className = "altText";
    altText.tabIndex = "0";
    const label = __privateSet(this, _altTextButtonLabel, document.createElement("span"));
    altText.append(label);
    if (__privateGet(this, _useNewAltTextFlow)) {
      altText.classList.add("new");
      altText.setAttribute("data-l10n-id", __privateGet(_AltText, _l10nNewButton).missing);
      label.setAttribute("data-l10n-id", __privateGet(_AltText, _l10nNewButton)["missing-label"]);
    } else {
      altText.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button");
      label.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button-label");
    }
    const signal = __privateGet(this, _editor2)._uiManager._signal;
    altText.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    altText.addEventListener("pointerdown", (event) => event.stopPropagation(), {
      signal
    });
    const onClick = (event) => {
      event.preventDefault();
      __privateGet(this, _editor2)._uiManager.editAltText(__privateGet(this, _editor2));
      if (__privateGet(this, _useNewAltTextFlow)) {
        __privateGet(this, _editor2)._reportTelemetry({
          action: "pdfjs.image.alt_text.image_status_label_clicked",
          data: {
            label: __privateGet(this, _label, label_get)
          }
        });
      }
    };
    altText.addEventListener("click", onClick, {
      capture: true,
      signal
    });
    altText.addEventListener("keydown", (event) => {
      if (event.target === altText && event.key === "Enter") {
        __privateSet(this, _altTextWasFromKeyBoard, true);
        onClick(event);
      }
    }, {
      signal
    });
    await __privateMethod(this, _setState, setState_fn).call(this);
    return altText;
  }
  finish() {
    if (!__privateGet(this, _altTextButton)) {
      return;
    }
    __privateGet(this, _altTextButton).focus({
      focusVisible: __privateGet(this, _altTextWasFromKeyBoard)
    });
    __privateSet(this, _altTextWasFromKeyBoard, false);
  }
  isEmpty() {
    if (__privateGet(this, _useNewAltTextFlow)) {
      return __privateGet(this, _altText2) === null;
    }
    return !__privateGet(this, _altText2) && !__privateGet(this, _altTextDecorative);
  }
  hasData() {
    if (__privateGet(this, _useNewAltTextFlow)) {
      return __privateGet(this, _altText2) !== null || !!__privateGet(this, _guessedText);
    }
    return this.isEmpty();
  }
  get guessedText() {
    return __privateGet(this, _guessedText);
  }
  async setGuessedText(guessedText) {
    if (__privateGet(this, _altText2) !== null) {
      return;
    }
    __privateSet(this, _guessedText, guessedText);
    __privateSet(this, _textWithDisclaimer, await _AltText._l10n.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer", {
      generatedAltText: guessedText
    }));
    __privateMethod(this, _setState, setState_fn).call(this);
  }
  toggleAltTextBadge(visibility = false) {
    var _a2;
    if (!__privateGet(this, _useNewAltTextFlow) || __privateGet(this, _altText2)) {
      (_a2 = __privateGet(this, _badge)) == null ? void 0 : _a2.remove();
      __privateSet(this, _badge, null);
      return;
    }
    if (!__privateGet(this, _badge)) {
      const badge = __privateSet(this, _badge, document.createElement("div"));
      badge.className = "noAltTextBadge";
      __privateGet(this, _editor2).div.append(badge);
    }
    __privateGet(this, _badge).classList.toggle("hidden", !visibility);
  }
  serialize(isForCopying) {
    let altText = __privateGet(this, _altText2);
    if (!isForCopying && __privateGet(this, _guessedText) === altText) {
      altText = __privateGet(this, _textWithDisclaimer);
    }
    return {
      altText,
      decorative: __privateGet(this, _altTextDecorative),
      guessedText: __privateGet(this, _guessedText),
      textWithDisclaimer: __privateGet(this, _textWithDisclaimer)
    };
  }
  get data() {
    return {
      altText: __privateGet(this, _altText2),
      decorative: __privateGet(this, _altTextDecorative)
    };
  }
  set data({
    altText,
    decorative,
    guessedText,
    textWithDisclaimer,
    cancel = false
  }) {
    if (guessedText) {
      __privateSet(this, _guessedText, guessedText);
      __privateSet(this, _textWithDisclaimer, textWithDisclaimer);
    }
    if (__privateGet(this, _altText2) === altText && __privateGet(this, _altTextDecorative) === decorative) {
      return;
    }
    if (!cancel) {
      __privateSet(this, _altText2, altText);
      __privateSet(this, _altTextDecorative, decorative);
    }
    __privateMethod(this, _setState, setState_fn).call(this);
  }
  toggle(enabled = false) {
    if (!__privateGet(this, _altTextButton)) {
      return;
    }
    if (!enabled && __privateGet(this, _altTextTooltipTimeout)) {
      clearTimeout(__privateGet(this, _altTextTooltipTimeout));
      __privateSet(this, _altTextTooltipTimeout, null);
    }
    __privateGet(this, _altTextButton).disabled = !enabled;
  }
  shown() {
    __privateGet(this, _editor2)._reportTelemetry({
      action: "pdfjs.image.alt_text.image_status_label_displayed",
      data: {
        label: __privateGet(this, _label, label_get)
      }
    });
  }
  destroy() {
    var _a2, _b;
    (_a2 = __privateGet(this, _altTextButton)) == null ? void 0 : _a2.remove();
    __privateSet(this, _altTextButton, null);
    __privateSet(this, _altTextButtonLabel, null);
    __privateSet(this, _altTextTooltip, null);
    (_b = __privateGet(this, _badge)) == null ? void 0 : _b.remove();
    __privateSet(this, _badge, null);
  }
};
_altText2 = new WeakMap();
_altTextDecorative = new WeakMap();
_altTextButton = new WeakMap();
_altTextButtonLabel = new WeakMap();
_altTextTooltip = new WeakMap();
_altTextTooltipTimeout = new WeakMap();
_altTextWasFromKeyBoard = new WeakMap();
_badge = new WeakMap();
_editor2 = new WeakMap();
_guessedText = new WeakMap();
_textWithDisclaimer = new WeakMap();
_useNewAltTextFlow = new WeakMap();
_l10nNewButton = new WeakMap();
_label = new WeakSet();
label_get = function() {
  return __privateGet(this, _altText2) && "added" || __privateGet(this, _altText2) === null && this.guessedText && "review" || "missing";
};
_setState = new WeakSet();
setState_fn = async function() {
  var _a2, _b, _c;
  const button = __privateGet(this, _altTextButton);
  if (!button) {
    return;
  }
  if (__privateGet(this, _useNewAltTextFlow)) {
    button.classList.toggle("done", !!__privateGet(this, _altText2));
    button.setAttribute("data-l10n-id", __privateGet(_AltText, _l10nNewButton)[__privateGet(this, _label, label_get)]);
    (_a2 = __privateGet(this, _altTextButtonLabel)) == null ? void 0 : _a2.setAttribute("data-l10n-id", __privateGet(_AltText, _l10nNewButton)[`${__privateGet(this, _label, label_get)}-label`]);
    if (!__privateGet(this, _altText2)) {
      (_b = __privateGet(this, _altTextTooltip)) == null ? void 0 : _b.remove();
      return;
    }
  } else {
    if (!__privateGet(this, _altText2) && !__privateGet(this, _altTextDecorative)) {
      button.classList.remove("done");
      (_c = __privateGet(this, _altTextTooltip)) == null ? void 0 : _c.remove();
      return;
    }
    button.classList.add("done");
    button.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-edit-button");
  }
  let tooltip = __privateGet(this, _altTextTooltip);
  if (!tooltip) {
    __privateSet(this, _altTextTooltip, tooltip = document.createElement("span"));
    tooltip.className = "tooltip";
    tooltip.setAttribute("role", "tooltip");
    tooltip.id = `alt-text-tooltip-${__privateGet(this, _editor2).id}`;
    const DELAY_TO_SHOW_TOOLTIP = 100;
    const signal = __privateGet(this, _editor2)._uiManager._signal;
    signal.addEventListener("abort", () => {
      clearTimeout(__privateGet(this, _altTextTooltipTimeout));
      __privateSet(this, _altTextTooltipTimeout, null);
    }, {
      once: true
    });
    button.addEventListener("mouseenter", () => {
      __privateSet(this, _altTextTooltipTimeout, setTimeout(() => {
        __privateSet(this, _altTextTooltipTimeout, null);
        __privateGet(this, _altTextTooltip).classList.add("show");
        __privateGet(this, _editor2)._reportTelemetry({
          action: "alt_text_tooltip"
        });
      }, DELAY_TO_SHOW_TOOLTIP));
    }, {
      signal
    });
    button.addEventListener("mouseleave", () => {
      var _a3;
      if (__privateGet(this, _altTextTooltipTimeout)) {
        clearTimeout(__privateGet(this, _altTextTooltipTimeout));
        __privateSet(this, _altTextTooltipTimeout, null);
      }
      (_a3 = __privateGet(this, _altTextTooltip)) == null ? void 0 : _a3.classList.remove("show");
    }, {
      signal
    });
  }
  if (__privateGet(this, _altTextDecorative)) {
    tooltip.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-decorative-tooltip");
  } else {
    tooltip.removeAttribute("data-l10n-id");
    tooltip.textContent = __privateGet(this, _altText2);
  }
  if (!tooltip.parentNode) {
    button.append(tooltip);
  }
  const element = __privateGet(this, _editor2).getElementForAltText();
  element == null ? void 0 : element.setAttribute("aria-describedby", tooltip.id);
};
__privateAdd(_AltText, _l10nNewButton, null);
__publicField(_AltText, "_l10n", null);
var AltText = _AltText;
var _commentStandaloneButton, _commentToolbarButton, _commentWasFromKeyBoard, _editor3, _initialText, _richText, _text, _date, _deleted, _popupPosition, _render2, render_fn2;
var Comment = class {
  constructor(editor) {
    __privateAdd(this, _render2);
    __privateAdd(this, _commentStandaloneButton, null);
    __privateAdd(this, _commentToolbarButton, null);
    __privateAdd(this, _commentWasFromKeyBoard, false);
    __privateAdd(this, _editor3, null);
    __privateAdd(this, _initialText, null);
    __privateAdd(this, _richText, null);
    __privateAdd(this, _text, null);
    __privateAdd(this, _date, null);
    __privateAdd(this, _deleted, false);
    __privateAdd(this, _popupPosition, null);
    __privateSet(this, _editor3, editor);
  }
  renderForToolbar() {
    const button = __privateSet(this, _commentToolbarButton, document.createElement("button"));
    button.className = "comment";
    return __privateMethod(this, _render2, render_fn2).call(this, button, false);
  }
  renderForStandalone() {
    const button = __privateSet(this, _commentStandaloneButton, document.createElement("button"));
    button.className = "annotationCommentButton";
    const position = __privateGet(this, _editor3).commentButtonPosition;
    if (position) {
      const {
        style
      } = button;
      style.insetInlineEnd = `calc(${100 * (__privateGet(this, _editor3)._uiManager.direction === "ltr" ? 1 - position[0] : position[0])}% - var(--comment-button-dim))`;
      style.top = `calc(${100 * position[1]}% - var(--comment-button-dim))`;
      const color = __privateGet(this, _editor3).commentButtonColor;
      if (color) {
        style.backgroundColor = color;
      }
    }
    return __privateMethod(this, _render2, render_fn2).call(this, button, true);
  }
  focusButton() {
    setTimeout(() => {
      var _a2;
      (_a2 = __privateGet(this, _commentStandaloneButton) ?? __privateGet(this, _commentToolbarButton)) == null ? void 0 : _a2.focus();
    }, 0);
  }
  onUpdatedColor() {
    if (!__privateGet(this, _commentStandaloneButton)) {
      return;
    }
    const color = __privateGet(this, _editor3).commentButtonColor;
    if (color) {
      __privateGet(this, _commentStandaloneButton).style.backgroundColor = color;
    }
    __privateGet(this, _editor3)._uiManager.updatePopupColor(__privateGet(this, _editor3));
  }
  get commentButtonWidth() {
    var _a2;
    return (((_a2 = __privateGet(this, _commentStandaloneButton)) == null ? void 0 : _a2.getBoundingClientRect().width) ?? 0) / __privateGet(this, _editor3).parent.boundingClientRect.width;
  }
  get commentPopupPositionInLayer() {
    if (__privateGet(this, _popupPosition)) {
      return __privateGet(this, _popupPosition);
    }
    if (!__privateGet(this, _commentStandaloneButton)) {
      return null;
    }
    const {
      x,
      y,
      height
    } = __privateGet(this, _commentStandaloneButton).getBoundingClientRect();
    const {
      x: parentX,
      y: parentY,
      width: parentWidth,
      height: parentHeight
    } = __privateGet(this, _editor3).parent.boundingClientRect;
    return [(x - parentX) / parentWidth, (y + height - parentY) / parentHeight];
  }
  set commentPopupPositionInLayer(pos) {
    __privateSet(this, _popupPosition, pos);
  }
  hasDefaultPopupPosition() {
    return __privateGet(this, _popupPosition) === null;
  }
  removeStandaloneCommentButton() {
    var _a2;
    (_a2 = __privateGet(this, _commentStandaloneButton)) == null ? void 0 : _a2.remove();
    __privateSet(this, _commentStandaloneButton, null);
  }
  removeToolbarCommentButton() {
    var _a2;
    (_a2 = __privateGet(this, _commentToolbarButton)) == null ? void 0 : _a2.remove();
    __privateSet(this, _commentToolbarButton, null);
  }
  setCommentButtonStates({
    selected,
    hasPopup
  }) {
    if (!__privateGet(this, _commentStandaloneButton)) {
      return;
    }
    __privateGet(this, _commentStandaloneButton).classList.toggle("selected", selected);
    __privateGet(this, _commentStandaloneButton).ariaExpanded = hasPopup;
  }
  edit(options) {
    const position = this.commentPopupPositionInLayer;
    let posX, posY;
    if (position) {
      [posX, posY] = position;
    } else {
      [posX, posY] = __privateGet(this, _editor3).commentButtonPosition;
      const {
        width,
        height,
        x,
        y
      } = __privateGet(this, _editor3);
      posX = x + posX * width;
      posY = y + posY * height;
    }
    const parentDimensions = __privateGet(this, _editor3).parent.boundingClientRect;
    const {
      x: parentX,
      y: parentY,
      width: parentWidth,
      height: parentHeight
    } = parentDimensions;
    __privateGet(this, _editor3)._uiManager.editComment(__privateGet(this, _editor3), parentX + posX * parentWidth, parentY + posY * parentHeight, {
      ...options,
      parentDimensions
    });
  }
  finish() {
    if (!__privateGet(this, _commentToolbarButton)) {
      return;
    }
    __privateGet(this, _commentToolbarButton).focus({
      focusVisible: __privateGet(this, _commentWasFromKeyBoard)
    });
    __privateSet(this, _commentWasFromKeyBoard, false);
  }
  isDeleted() {
    return __privateGet(this, _deleted) || __privateGet(this, _text) === "";
  }
  isEmpty() {
    return __privateGet(this, _text) === null;
  }
  hasBeenEdited() {
    return this.isDeleted() || __privateGet(this, _text) !== __privateGet(this, _initialText);
  }
  serialize() {
    return this.data;
  }
  get data() {
    return {
      text: __privateGet(this, _text),
      richText: __privateGet(this, _richText),
      date: __privateGet(this, _date),
      deleted: this.isDeleted()
    };
  }
  set data(text) {
    if (text !== __privateGet(this, _text)) {
      __privateSet(this, _richText, null);
    }
    if (text === null) {
      __privateSet(this, _text, "");
      __privateSet(this, _deleted, true);
      return;
    }
    __privateSet(this, _text, text);
    __privateSet(this, _date, /* @__PURE__ */ new Date());
    __privateSet(this, _deleted, false);
  }
  setInitialText(text, richText = null) {
    __privateSet(this, _initialText, text);
    this.data = text;
    __privateSet(this, _date, null);
    __privateSet(this, _richText, richText);
  }
  shown() {
  }
  destroy() {
    var _a2, _b;
    (_a2 = __privateGet(this, _commentToolbarButton)) == null ? void 0 : _a2.remove();
    __privateSet(this, _commentToolbarButton, null);
    (_b = __privateGet(this, _commentStandaloneButton)) == null ? void 0 : _b.remove();
    __privateSet(this, _commentStandaloneButton, null);
    __privateSet(this, _text, "");
    __privateSet(this, _richText, null);
    __privateSet(this, _date, null);
    __privateSet(this, _editor3, null);
    __privateSet(this, _commentWasFromKeyBoard, false);
    __privateSet(this, _deleted, false);
  }
};
_commentStandaloneButton = new WeakMap();
_commentToolbarButton = new WeakMap();
_commentWasFromKeyBoard = new WeakMap();
_editor3 = new WeakMap();
_initialText = new WeakMap();
_richText = new WeakMap();
_text = new WeakMap();
_date = new WeakMap();
_deleted = new WeakMap();
_popupPosition = new WeakMap();
_render2 = new WeakSet();
render_fn2 = function(comment, isStandalone) {
  if (!__privateGet(this, _editor3)._uiManager.hasCommentManager()) {
    return null;
  }
  comment.tabIndex = "0";
  comment.ariaHasPopup = "dialog";
  if (isStandalone) {
    comment.ariaControls = "commentPopup";
    comment.setAttribute("data-l10n-id", "pdfjs-show-comment-button");
  } else {
    comment.ariaControlsElements = [__privateGet(this, _editor3)._uiManager.getCommentDialogElement()];
    comment.setAttribute("data-l10n-id", "pdfjs-editor-edit-comment-button");
  }
  const signal = __privateGet(this, _editor3)._uiManager._signal;
  if (!(signal instanceof AbortSignal) || signal.aborted) {
    return comment;
  }
  comment.addEventListener("contextmenu", noContextMenu, {
    signal
  });
  if (isStandalone) {
    comment.addEventListener("focusin", (e) => {
      __privateGet(this, _editor3)._focusEventsAllowed = false;
      stopEvent(e);
    }, {
      capture: true,
      signal
    });
    comment.addEventListener("focusout", (e) => {
      __privateGet(this, _editor3)._focusEventsAllowed = true;
      stopEvent(e);
    }, {
      capture: true,
      signal
    });
  }
  comment.addEventListener("pointerdown", (event) => event.stopPropagation(), {
    signal
  });
  const onClick = (event) => {
    event.preventDefault();
    if (comment === __privateGet(this, _commentToolbarButton)) {
      this.edit();
    } else {
      __privateGet(this, _editor3).toggleComment(true);
    }
  };
  comment.addEventListener("click", onClick, {
    capture: true,
    signal
  });
  comment.addEventListener("keydown", (event) => {
    if (event.target === comment && event.key === "Enter") {
      __privateSet(this, _commentWasFromKeyBoard, true);
      onClick(event);
    }
  }, {
    signal
  });
  comment.addEventListener("pointerenter", () => {
    __privateGet(this, _editor3).toggleComment(false, true);
  }, {
    signal
  });
  comment.addEventListener("pointerleave", () => {
    __privateGet(this, _editor3).toggleComment(false, false);
  }, {
    signal
  });
  return comment;
};
var _container2, _isPinching, _isPinchingStopped, _isPinchingDisabled, _onPinchStart, _onPinching, _onPinchEnd, _pointerDownAC, _signal, _touchInfo, _touchManagerAC, _touchMoveAC, _onTouchStart, onTouchStart_fn, _onTouchMove, onTouchMove_fn, _onTouchEnd, onTouchEnd_fn;
var _TouchManager = class _TouchManager {
  constructor({
    container,
    isPinchingDisabled = null,
    isPinchingStopped = null,
    onPinchStart = null,
    onPinching = null,
    onPinchEnd = null,
    signal
  }) {
    __privateAdd(this, _onTouchStart);
    __privateAdd(this, _onTouchMove);
    __privateAdd(this, _onTouchEnd);
    __privateAdd(this, _container2, void 0);
    __privateAdd(this, _isPinching, false);
    __privateAdd(this, _isPinchingStopped, null);
    __privateAdd(this, _isPinchingDisabled, void 0);
    __privateAdd(this, _onPinchStart, void 0);
    __privateAdd(this, _onPinching, void 0);
    __privateAdd(this, _onPinchEnd, void 0);
    __privateAdd(this, _pointerDownAC, null);
    __privateAdd(this, _signal, void 0);
    __privateAdd(this, _touchInfo, null);
    __privateAdd(this, _touchManagerAC, void 0);
    __privateAdd(this, _touchMoveAC, null);
    __privateSet(this, _container2, container);
    __privateSet(this, _isPinchingStopped, isPinchingStopped);
    __privateSet(this, _isPinchingDisabled, isPinchingDisabled);
    __privateSet(this, _onPinchStart, onPinchStart);
    __privateSet(this, _onPinching, onPinching);
    __privateSet(this, _onPinchEnd, onPinchEnd);
    __privateSet(this, _touchManagerAC, new AbortController());
    __privateSet(this, _signal, AbortSignal.any([signal, __privateGet(this, _touchManagerAC).signal]));
    container.addEventListener("touchstart", __privateMethod(this, _onTouchStart, onTouchStart_fn).bind(this), {
      passive: false,
      signal: __privateGet(this, _signal)
    });
  }
  get MIN_TOUCH_DISTANCE_TO_PINCH() {
    return 35 / OutputScale.pixelRatio;
  }
  destroy() {
    var _a2, _b;
    (_a2 = __privateGet(this, _touchManagerAC)) == null ? void 0 : _a2.abort();
    __privateSet(this, _touchManagerAC, null);
    (_b = __privateGet(this, _pointerDownAC)) == null ? void 0 : _b.abort();
    __privateSet(this, _pointerDownAC, null);
  }
};
_container2 = new WeakMap();
_isPinching = new WeakMap();
_isPinchingStopped = new WeakMap();
_isPinchingDisabled = new WeakMap();
_onPinchStart = new WeakMap();
_onPinching = new WeakMap();
_onPinchEnd = new WeakMap();
_pointerDownAC = new WeakMap();
_signal = new WeakMap();
_touchInfo = new WeakMap();
_touchManagerAC = new WeakMap();
_touchMoveAC = new WeakMap();
_onTouchStart = new WeakSet();
onTouchStart_fn = function(evt) {
  var _a2, _b, _c;
  if ((_a2 = __privateGet(this, _isPinchingDisabled)) == null ? void 0 : _a2.call(this)) {
    return;
  }
  if (evt.touches.length === 1) {
    if (__privateGet(this, _pointerDownAC)) {
      return;
    }
    const pointerDownAC = __privateSet(this, _pointerDownAC, new AbortController());
    const signal = AbortSignal.any([__privateGet(this, _signal), pointerDownAC.signal]);
    const container = __privateGet(this, _container2);
    const opts = {
      capture: true,
      signal,
      passive: false
    };
    const cancelPointerDown = (e) => {
      var _a3;
      if (e.pointerType === "touch") {
        (_a3 = __privateGet(this, _pointerDownAC)) == null ? void 0 : _a3.abort();
        __privateSet(this, _pointerDownAC, null);
      }
    };
    container.addEventListener("pointerdown", (e) => {
      if (e.pointerType === "touch") {
        stopEvent(e);
        cancelPointerDown(e);
      }
    }, opts);
    container.addEventListener("pointerup", cancelPointerDown, opts);
    container.addEventListener("pointercancel", cancelPointerDown, opts);
    return;
  }
  if (!__privateGet(this, _touchMoveAC)) {
    __privateSet(this, _touchMoveAC, new AbortController());
    const signal = AbortSignal.any([__privateGet(this, _signal), __privateGet(this, _touchMoveAC).signal]);
    const container = __privateGet(this, _container2);
    const opt = {
      signal,
      capture: false,
      passive: false
    };
    container.addEventListener("touchmove", __privateMethod(this, _onTouchMove, onTouchMove_fn).bind(this), opt);
    const onTouchEnd = __privateMethod(this, _onTouchEnd, onTouchEnd_fn).bind(this);
    container.addEventListener("touchend", onTouchEnd, opt);
    container.addEventListener("touchcancel", onTouchEnd, opt);
    opt.capture = true;
    container.addEventListener("pointerdown", stopEvent, opt);
    container.addEventListener("pointermove", stopEvent, opt);
    container.addEventListener("pointercancel", stopEvent, opt);
    container.addEventListener("pointerup", stopEvent, opt);
    (_b = __privateGet(this, _onPinchStart)) == null ? void 0 : _b.call(this);
  }
  stopEvent(evt);
  if (evt.touches.length !== 2 || ((_c = __privateGet(this, _isPinchingStopped)) == null ? void 0 : _c.call(this))) {
    __privateSet(this, _touchInfo, null);
    return;
  }
  let [touch0, touch1] = evt.touches;
  if (touch0.identifier > touch1.identifier) {
    [touch0, touch1] = [touch1, touch0];
  }
  __privateSet(this, _touchInfo, {
    touch0X: touch0.screenX,
    touch0Y: touch0.screenY,
    touch1X: touch1.screenX,
    touch1Y: touch1.screenY
  });
};
_onTouchMove = new WeakSet();
onTouchMove_fn = function(evt) {
  var _a2;
  if (!__privateGet(this, _touchInfo) || evt.touches.length !== 2) {
    return;
  }
  stopEvent(evt);
  let [touch0, touch1] = evt.touches;
  if (touch0.identifier > touch1.identifier) {
    [touch0, touch1] = [touch1, touch0];
  }
  const {
    screenX: screen0X,
    screenY: screen0Y
  } = touch0;
  const {
    screenX: screen1X,
    screenY: screen1Y
  } = touch1;
  const touchInfo = __privateGet(this, _touchInfo);
  const {
    touch0X: pTouch0X,
    touch0Y: pTouch0Y,
    touch1X: pTouch1X,
    touch1Y: pTouch1Y
  } = touchInfo;
  const prevGapX = pTouch1X - pTouch0X;
  const prevGapY = pTouch1Y - pTouch0Y;
  const currGapX = screen1X - screen0X;
  const currGapY = screen1Y - screen0Y;
  const distance = Math.hypot(currGapX, currGapY) || 1;
  const pDistance = Math.hypot(prevGapX, prevGapY) || 1;
  if (!__privateGet(this, _isPinching) && Math.abs(pDistance - distance) <= _TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) {
    return;
  }
  touchInfo.touch0X = screen0X;
  touchInfo.touch0Y = screen0Y;
  touchInfo.touch1X = screen1X;
  touchInfo.touch1Y = screen1Y;
  if (!__privateGet(this, _isPinching)) {
    __privateSet(this, _isPinching, true);
    return;
  }
  const origin = [(screen0X + screen1X) / 2, (screen0Y + screen1Y) / 2];
  (_a2 = __privateGet(this, _onPinching)) == null ? void 0 : _a2.call(this, origin, pDistance, distance);
};
_onTouchEnd = new WeakSet();
onTouchEnd_fn = function(evt) {
  var _a2;
  if (evt.touches.length >= 2) {
    return;
  }
  if (__privateGet(this, _touchMoveAC)) {
    __privateGet(this, _touchMoveAC).abort();
    __privateSet(this, _touchMoveAC, null);
    (_a2 = __privateGet(this, _onPinchEnd)) == null ? void 0 : _a2.call(this);
  }
  if (!__privateGet(this, _touchInfo)) {
    return;
  }
  stopEvent(evt);
  __privateSet(this, _touchInfo, null);
  __privateSet(this, _isPinching, false);
};
var TouchManager = _TouchManager;
var _accessibilityData, _allResizerDivs, _altText3, _comment2, _commentStandaloneButton2, _disabled, _dragPointerId, _dragPointerType, _resizersDiv, _lastPointerCoords, _savedDimensions, _fakeAnnotation, _focusAC, _focusedResizerName, _hasBeenClicked, _initialRect, _isEditing, _isInEditMode, _isResizerEnabledForKeyboard, _moveInDOMTimeout, _prevDragX, _prevDragY, _telemetryTimeouts, _touchManager, _isDraggable, _zIndex, _translate, translate_fn, _rotatePoint, rotatePoint_fn, _getRotationMatrix, getRotationMatrix_fn, _createResizers, createResizers_fn, _resizerPointerdown, resizerPointerdown_fn, _resize, resize_fn, _addResizeToUndoStack, addResizeToUndoStack_fn, _resizerPointermove, resizerPointermove_fn, _touchPinchStartCallback, touchPinchStartCallback_fn, _touchPinchCallback, touchPinchCallback_fn, _touchPinchEndCallback, touchPinchEndCallback_fn, _selectOnPointerEvent, selectOnPointerEvent_fn, _setUpDragSession, setUpDragSession_fn, _addFocusListeners, addFocusListeners_fn, _resizerKeydown, resizerKeydown_fn, _resizerBlur, resizerBlur_fn, _resizerFocus, resizerFocus_fn, _setResizerTabIndex, setResizerTabIndex_fn, _stopResizing, stopResizing_fn;
var _AnnotationEditor = class _AnnotationEditor {
  constructor(parameters) {
    __privateAdd(this, _translate);
    __privateAdd(this, _getRotationMatrix);
    __privateAdd(this, _createResizers);
    __privateAdd(this, _resizerPointerdown);
    __privateAdd(this, _resize);
    __privateAdd(this, _addResizeToUndoStack);
    __privateAdd(this, _resizerPointermove);
    __privateAdd(this, _touchPinchStartCallback);
    __privateAdd(this, _touchPinchCallback);
    __privateAdd(this, _touchPinchEndCallback);
    __privateAdd(this, _selectOnPointerEvent);
    __privateAdd(this, _setUpDragSession);
    __privateAdd(this, _addFocusListeners);
    __privateAdd(this, _resizerKeydown);
    __privateAdd(this, _resizerBlur);
    __privateAdd(this, _resizerFocus);
    __privateAdd(this, _setResizerTabIndex);
    __privateAdd(this, _stopResizing);
    __privateAdd(this, _accessibilityData, null);
    __privateAdd(this, _allResizerDivs, null);
    __privateAdd(this, _altText3, null);
    __privateAdd(this, _comment2, null);
    __privateAdd(this, _commentStandaloneButton2, null);
    __privateAdd(this, _disabled, false);
    __privateAdd(this, _dragPointerId, null);
    __privateAdd(this, _dragPointerType, "");
    __privateAdd(this, _resizersDiv, null);
    __privateAdd(this, _lastPointerCoords, null);
    __privateAdd(this, _savedDimensions, null);
    __privateAdd(this, _fakeAnnotation, null);
    __privateAdd(this, _focusAC, null);
    __privateAdd(this, _focusedResizerName, "");
    __privateAdd(this, _hasBeenClicked, false);
    __privateAdd(this, _initialRect, null);
    __privateAdd(this, _isEditing, false);
    __privateAdd(this, _isInEditMode, false);
    __privateAdd(this, _isResizerEnabledForKeyboard, false);
    __privateAdd(this, _moveInDOMTimeout, null);
    __privateAdd(this, _prevDragX, 0);
    __privateAdd(this, _prevDragY, 0);
    __privateAdd(this, _telemetryTimeouts, null);
    __privateAdd(this, _touchManager, null);
    __publicField(this, "isSelected", false);
    __publicField(this, "_isCopy", false);
    __publicField(this, "_editToolbar", null);
    __publicField(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
    __publicField(this, "_initialData", null);
    __publicField(this, "_isVisible", true);
    __publicField(this, "_uiManager", null);
    __publicField(this, "_focusEventsAllowed", true);
    __privateAdd(this, _isDraggable, false);
    __privateAdd(this, _zIndex, _AnnotationEditor._zIndex++);
    this.parent = parameters.parent;
    this.id = parameters.id;
    this.width = this.height = null;
    this.pageIndex = parameters.parent.pageIndex;
    this.name = parameters.name;
    this.div = null;
    this._uiManager = parameters.uiManager;
    this.annotationElementId = null;
    this._willKeepAspectRatio = false;
    this._initialOptions.isCentered = parameters.isCentered;
    this._structTreeParentId = null;
    this.annotationElementId = parameters.annotationElementId || null;
    this.creationDate = parameters.creationDate || /* @__PURE__ */ new Date();
    this.modificationDate = parameters.modificationDate || null;
    const {
      rotation,
      rawDims: {
        pageWidth,
        pageHeight,
        pageX,
        pageY
      }
    } = this.parent.viewport;
    this.rotation = rotation;
    this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;
    this.pageDimensions = [pageWidth, pageHeight];
    this.pageTranslation = [pageX, pageY];
    const [width, height] = this.parentDimensions;
    this.x = parameters.x / width;
    this.y = parameters.y / height;
    this.isAttachedToDOM = false;
    this.deleted = false;
  }
  static get _resizerKeyboardManager() {
    const resize = _AnnotationEditor.prototype._resizeWithKeyboard;
    const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
    const big = AnnotationEditorUIManager.TRANSLATE_BIG;
    return shadow(this, "_resizerKeyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], resize, {
      args: [-small, 0]
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], resize, {
      args: [-big, 0]
    }], [["ArrowRight", "mac+ArrowRight"], resize, {
      args: [small, 0]
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], resize, {
      args: [big, 0]
    }], [["ArrowUp", "mac+ArrowUp"], resize, {
      args: [0, -small]
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], resize, {
      args: [0, -big]
    }], [["ArrowDown", "mac+ArrowDown"], resize, {
      args: [0, small]
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], resize, {
      args: [0, big]
    }], [["Escape", "mac+Escape"], _AnnotationEditor.prototype._stopResizingWithKeyboard]]));
  }
  get editorType() {
    return Object.getPrototypeOf(this).constructor._type;
  }
  get mode() {
    return Object.getPrototypeOf(this).constructor._editorType;
  }
  static get isDrawer() {
    return false;
  }
  static get _defaultLineColor() {
    return shadow(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }
  static deleteAnnotationElement(editor) {
    const fakeEditor = new FakeEditor({
      id: editor.parent.getNextId(),
      parent: editor.parent,
      uiManager: editor._uiManager
    });
    fakeEditor.annotationElementId = editor.annotationElementId;
    fakeEditor.deleted = true;
    fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
  }
  static initialize(l10n, _uiManager5) {
    _AnnotationEditor._l10n ?? (_AnnotationEditor._l10n = l10n);
    _AnnotationEditor._l10nResizer || (_AnnotationEditor._l10nResizer = Object.freeze({
      topLeft: "pdfjs-editor-resizer-top-left",
      topMiddle: "pdfjs-editor-resizer-top-middle",
      topRight: "pdfjs-editor-resizer-top-right",
      middleRight: "pdfjs-editor-resizer-middle-right",
      bottomRight: "pdfjs-editor-resizer-bottom-right",
      bottomMiddle: "pdfjs-editor-resizer-bottom-middle",
      bottomLeft: "pdfjs-editor-resizer-bottom-left",
      middleLeft: "pdfjs-editor-resizer-middle-left"
    }));
    if (_AnnotationEditor._borderLineWidth !== -1) {
      return;
    }
    const style = getComputedStyle(document.documentElement);
    _AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue("--outline-width")) || 0;
  }
  static updateDefaultParams(_type, _value) {
  }
  static get defaultPropertiesToUpdate() {
    return [];
  }
  static isHandlingMimeForPasting(mime) {
    return false;
  }
  static paste(item, parent) {
    unreachable("Not implemented");
  }
  get propertiesToUpdate() {
    return [];
  }
  get _isDraggable() {
    return __privateGet(this, _isDraggable);
  }
  set _isDraggable(value) {
    var _a2;
    __privateSet(this, _isDraggable, value);
    (_a2 = this.div) == null ? void 0 : _a2.classList.toggle("draggable", value);
  }
  get uid() {
    return this.annotationElementId || this.id;
  }
  get isEnterHandled() {
    return true;
  }
  center() {
    const [pageWidth, pageHeight] = this.pageDimensions;
    switch (this.parentRotation) {
      case 90:
        this.x -= this.height * pageHeight / (pageWidth * 2);
        this.y += this.width * pageWidth / (pageHeight * 2);
        break;
      case 180:
        this.x += this.width / 2;
        this.y += this.height / 2;
        break;
      case 270:
        this.x += this.height * pageHeight / (pageWidth * 2);
        this.y -= this.width * pageWidth / (pageHeight * 2);
        break;
      default:
        this.x -= this.width / 2;
        this.y -= this.height / 2;
        break;
    }
    this.fixAndSetPosition();
  }
  addCommands(params) {
    this._uiManager.addCommands(params);
  }
  get currentLayer() {
    return this._uiManager.currentLayer;
  }
  setInBackground() {
    this.div.style.zIndex = 0;
  }
  setInForeground() {
    this.div.style.zIndex = __privateGet(this, _zIndex);
  }
  setParent(parent) {
    var _a2;
    if (parent !== null) {
      this.pageIndex = parent.pageIndex;
      this.pageDimensions = parent.pageDimensions;
    } else {
      __privateMethod(this, _stopResizing, stopResizing_fn).call(this);
      (_a2 = __privateGet(this, _fakeAnnotation)) == null ? void 0 : _a2.remove();
      __privateSet(this, _fakeAnnotation, null);
    }
    this.parent = parent;
  }
  focusin(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    if (!__privateGet(this, _hasBeenClicked)) {
      this.parent.setSelected(this);
    } else {
      __privateSet(this, _hasBeenClicked, false);
    }
  }
  focusout(event) {
    var _a2;
    if (!this._focusEventsAllowed) {
      return;
    }
    if (!this.isAttachedToDOM) {
      return;
    }
    const target = event.relatedTarget;
    if (target == null ? void 0 : target.closest(`#${this.id}`)) {
      return;
    }
    event.preventDefault();
    if (!((_a2 = this.parent) == null ? void 0 : _a2.isMultipleSelection)) {
      this.commitOrRemove();
    }
  }
  commitOrRemove() {
    if (this.isEmpty()) {
      this.remove();
    } else {
      this.commit();
    }
  }
  commit() {
    if (!this.isInEditMode()) {
      return;
    }
    this.addToAnnotationStorage();
  }
  addToAnnotationStorage() {
    this._uiManager.addToAnnotationStorage(this);
  }
  setAt(x, y, tx, ty) {
    const [width, height] = this.parentDimensions;
    [tx, ty] = this.screenToPageTranslation(tx, ty);
    this.x = (x + tx) / width;
    this.y = (y + ty) / height;
    this.fixAndSetPosition();
  }
  _moveAfterPaste(baseX, baseY) {
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
    this._onTranslated();
  }
  translate(x, y) {
    __privateMethod(this, _translate, translate_fn).call(this, this.parentDimensions, x, y);
  }
  translateInPage(x, y) {
    __privateGet(this, _initialRect) || __privateSet(this, _initialRect, [this.x, this.y, this.width, this.height]);
    __privateMethod(this, _translate, translate_fn).call(this, this.pageDimensions, x, y);
    this.div.scrollIntoView({
      block: "nearest"
    });
  }
  translationDone() {
    this._onTranslated(this.x, this.y);
  }
  drag(tx, ty) {
    __privateGet(this, _initialRect) || __privateSet(this, _initialRect, [this.x, this.y, this.width, this.height]);
    const {
      div,
      parentDimensions: [parentWidth, parentHeight]
    } = this;
    this.x += tx / parentWidth;
    this.y += ty / parentHeight;
    if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
      const {
        x: x2,
        y: y2
      } = this.div.getBoundingClientRect();
      if (this.parent.findNewParent(this, x2, y2)) {
        this.x -= Math.floor(this.x);
        this.y -= Math.floor(this.y);
      }
    }
    let {
      x,
      y
    } = this;
    const [bx, by] = this.getBaseTranslation();
    x += bx;
    y += by;
    const {
      style
    } = div;
    style.left = `${(100 * x).toFixed(2)}%`;
    style.top = `${(100 * y).toFixed(2)}%`;
    this._onTranslating(x, y);
    div.scrollIntoView({
      block: "nearest"
    });
  }
  _onTranslating(x, y) {
  }
  _onTranslated(x, y) {
  }
  get _hasBeenMoved() {
    return !!__privateGet(this, _initialRect) && (__privateGet(this, _initialRect)[0] !== this.x || __privateGet(this, _initialRect)[1] !== this.y);
  }
  get _hasBeenResized() {
    return !!__privateGet(this, _initialRect) && (__privateGet(this, _initialRect)[2] !== this.width || __privateGet(this, _initialRect)[3] !== this.height);
  }
  getBaseTranslation() {
    const [parentWidth, parentHeight] = this.parentDimensions;
    const {
      _borderLineWidth
    } = _AnnotationEditor;
    const x = _borderLineWidth / parentWidth;
    const y = _borderLineWidth / parentHeight;
    switch (this.rotation) {
      case 90:
        return [-x, y];
      case 180:
        return [x, y];
      case 270:
        return [x, -y];
      default:
        return [-x, -y];
    }
  }
  get _mustFixPosition() {
    return true;
  }
  fixAndSetPosition(rotation = this.rotation) {
    const {
      div: {
        style
      },
      pageDimensions: [pageWidth, pageHeight]
    } = this;
    let {
      x,
      y,
      width,
      height
    } = this;
    width *= pageWidth;
    height *= pageHeight;
    x *= pageWidth;
    y *= pageHeight;
    if (this._mustFixPosition) {
      switch (rotation) {
        case 0:
          x = MathClamp(x, 0, pageWidth - width);
          y = MathClamp(y, 0, pageHeight - height);
          break;
        case 90:
          x = MathClamp(x, 0, pageWidth - height);
          y = MathClamp(y, width, pageHeight);
          break;
        case 180:
          x = MathClamp(x, width, pageWidth);
          y = MathClamp(y, height, pageHeight);
          break;
        case 270:
          x = MathClamp(x, height, pageWidth);
          y = MathClamp(y, 0, pageHeight - width);
          break;
      }
    }
    this.x = x /= pageWidth;
    this.y = y /= pageHeight;
    const [bx, by] = this.getBaseTranslation();
    x += bx;
    y += by;
    style.left = `${(100 * x).toFixed(2)}%`;
    style.top = `${(100 * y).toFixed(2)}%`;
    this.moveInDOM();
  }
  screenToPageTranslation(x, y) {
    var _a2;
    return __privateMethod(_a2 = _AnnotationEditor, _rotatePoint, rotatePoint_fn).call(_a2, x, y, this.parentRotation);
  }
  pageTranslationToScreen(x, y) {
    var _a2;
    return __privateMethod(_a2 = _AnnotationEditor, _rotatePoint, rotatePoint_fn).call(_a2, x, y, 360 - this.parentRotation);
  }
  get parentScale() {
    return this._uiManager.viewParameters.realScale;
  }
  get parentRotation() {
    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
  }
  get parentDimensions() {
    const {
      parentScale,
      pageDimensions: [pageWidth, pageHeight]
    } = this;
    return [pageWidth * parentScale, pageHeight * parentScale];
  }
  setDims() {
    const {
      div: {
        style
      },
      width,
      height
    } = this;
    style.width = `${(100 * width).toFixed(2)}%`;
    style.height = `${(100 * height).toFixed(2)}%`;
  }
  getInitialTranslation() {
    return [0, 0];
  }
  _onResized() {
  }
  static _round(x) {
    return Math.round(x * 1e4) / 1e4;
  }
  _onResizing() {
  }
  altTextFinish() {
    var _a2;
    (_a2 = __privateGet(this, _altText3)) == null ? void 0 : _a2.finish();
  }
  get toolbarButtons() {
    return null;
  }
  async addEditToolbar() {
    if (this._editToolbar || __privateGet(this, _isInEditMode)) {
      return this._editToolbar;
    }
    this._editToolbar = new EditorToolbar(this);
    this.div.append(this._editToolbar.render());
    const {
      toolbarButtons
    } = this;
    if (toolbarButtons) {
      for (const [name, tool] of toolbarButtons) {
        await this._editToolbar.addButton(name, tool);
      }
    }
    if (!this.hasComment) {
      this._editToolbar.addButton("comment", this.addCommentButton());
    }
    this._editToolbar.addButton("delete");
    return this._editToolbar;
  }
  addCommentButtonInToolbar() {
    var _a2;
    (_a2 = this._editToolbar) == null ? void 0 : _a2.addButtonBefore("comment", this.addCommentButton(), ".deleteButton");
  }
  removeCommentButtonFromToolbar() {
    var _a2;
    (_a2 = this._editToolbar) == null ? void 0 : _a2.removeButton("comment");
  }
  removeEditToolbar() {
    var _a2, _b;
    (_a2 = this._editToolbar) == null ? void 0 : _a2.remove();
    this._editToolbar = null;
    (_b = __privateGet(this, _altText3)) == null ? void 0 : _b.destroy();
  }
  addContainer(container) {
    var _a2;
    const editToolbarDiv = (_a2 = this._editToolbar) == null ? void 0 : _a2.div;
    if (editToolbarDiv) {
      editToolbarDiv.before(container);
    } else {
      this.div.append(container);
    }
  }
  getClientDimensions() {
    return this.div.getBoundingClientRect();
  }
  createAltText() {
    if (!__privateGet(this, _altText3)) {
      AltText.initialize(_AnnotationEditor._l10n);
      __privateSet(this, _altText3, new AltText(this));
      if (__privateGet(this, _accessibilityData)) {
        __privateGet(this, _altText3).data = __privateGet(this, _accessibilityData);
        __privateSet(this, _accessibilityData, null);
      }
    }
    return __privateGet(this, _altText3);
  }
  get altTextData() {
    var _a2;
    return (_a2 = __privateGet(this, _altText3)) == null ? void 0 : _a2.data;
  }
  set altTextData(data) {
    if (!__privateGet(this, _altText3)) {
      return;
    }
    __privateGet(this, _altText3).data = data;
  }
  get guessedAltText() {
    var _a2;
    return (_a2 = __privateGet(this, _altText3)) == null ? void 0 : _a2.guessedText;
  }
  async setGuessedAltText(text) {
    var _a2;
    await ((_a2 = __privateGet(this, _altText3)) == null ? void 0 : _a2.setGuessedText(text));
  }
  serializeAltText(isForCopying) {
    var _a2;
    return (_a2 = __privateGet(this, _altText3)) == null ? void 0 : _a2.serialize(isForCopying);
  }
  hasAltText() {
    return !!__privateGet(this, _altText3) && !__privateGet(this, _altText3).isEmpty();
  }
  hasAltTextData() {
    var _a2;
    return ((_a2 = __privateGet(this, _altText3)) == null ? void 0 : _a2.hasData()) ?? false;
  }
  focusCommentButton() {
    var _a2;
    (_a2 = __privateGet(this, _comment2)) == null ? void 0 : _a2.focusButton();
  }
  addCommentButton() {
    return __privateGet(this, _comment2) || __privateSet(this, _comment2, new Comment(this));
  }
  addStandaloneCommentButton() {
    if (__privateGet(this, _commentStandaloneButton2)) {
      if (this._uiManager.isEditingMode()) {
        __privateGet(this, _commentStandaloneButton2).classList.remove("hidden");
      }
      return;
    }
    if (!this.hasComment) {
      return;
    }
    __privateSet(this, _commentStandaloneButton2, __privateGet(this, _comment2).renderForStandalone());
    this.div.append(__privateGet(this, _commentStandaloneButton2));
  }
  removeStandaloneCommentButton() {
    __privateGet(this, _comment2).removeStandaloneCommentButton();
    __privateSet(this, _commentStandaloneButton2, null);
  }
  hideStandaloneCommentButton() {
    var _a2;
    (_a2 = __privateGet(this, _commentStandaloneButton2)) == null ? void 0 : _a2.classList.add("hidden");
  }
  get comment() {
    const {
      data: {
        richText,
        text,
        date,
        deleted
      }
    } = __privateGet(this, _comment2);
    return {
      text,
      richText,
      date,
      deleted,
      color: this.getNonHCMColor(),
      opacity: this.opacity ?? 1
    };
  }
  set comment(text) {
    __privateGet(this, _comment2) || __privateSet(this, _comment2, new Comment(this));
    __privateGet(this, _comment2).data = text;
    if (this.hasComment) {
      this.removeCommentButtonFromToolbar();
      this.addStandaloneCommentButton();
      this._uiManager.updateComment(this);
    } else {
      this.addCommentButtonInToolbar();
      this.removeStandaloneCommentButton();
      this._uiManager.removeComment(this);
    }
  }
  setCommentData({
    comment,
    popupRef,
    richText
  }) {
    if (!popupRef) {
      return;
    }
    __privateGet(this, _comment2) || __privateSet(this, _comment2, new Comment(this));
    __privateGet(this, _comment2).setInitialText(comment, richText);
    if (!this.annotationElementId) {
      return;
    }
    const storedData = this._uiManager.getAndRemoveDataFromAnnotationStorage(this.annotationElementId);
    if (storedData) {
      this.updateFromAnnotationLayer(storedData);
    }
  }
  get hasEditedComment() {
    var _a2;
    return (_a2 = __privateGet(this, _comment2)) == null ? void 0 : _a2.hasBeenEdited();
  }
  get hasDeletedComment() {
    var _a2;
    return (_a2 = __privateGet(this, _comment2)) == null ? void 0 : _a2.isDeleted();
  }
  get hasComment() {
    return !!__privateGet(this, _comment2) && !__privateGet(this, _comment2).isEmpty() && !__privateGet(this, _comment2).isDeleted();
  }
  async editComment(options) {
    __privateGet(this, _comment2) || __privateSet(this, _comment2, new Comment(this));
    __privateGet(this, _comment2).edit(options);
  }
  toggleComment(isSelected, visibility = void 0) {
    if (this.hasComment) {
      this._uiManager.toggleComment(this, isSelected, visibility);
    }
  }
  setSelectedCommentButton(selected) {
    __privateGet(this, _comment2).setSelectedButton(selected);
  }
  addComment(serialized) {
    if (this.hasEditedComment) {
      const DEFAULT_POPUP_WIDTH = 180;
      const DEFAULT_POPUP_HEIGHT = 100;
      const [, , , trY] = serialized.rect;
      const [pageWidth] = this.pageDimensions;
      const [pageX] = this.pageTranslation;
      const blX = pageX + pageWidth + 1;
      const blY = trY - DEFAULT_POPUP_HEIGHT;
      const trX = blX + DEFAULT_POPUP_WIDTH;
      serialized.popup = {
        contents: this.comment.text,
        deleted: this.comment.deleted,
        rect: [blX, blY, trX, trY]
      };
    }
  }
  updateFromAnnotationLayer({
    popup: {
      contents,
      deleted
    }
  }) {
    __privateGet(this, _comment2).data = deleted ? null : contents;
  }
  get parentBoundingClientRect() {
    return this.parent.boundingClientRect;
  }
  render() {
    var _a2;
    const div = this.div = document.createElement("div");
    div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
    div.className = this.name;
    div.setAttribute("id", this.id);
    div.tabIndex = __privateGet(this, _disabled) ? -1 : 0;
    div.setAttribute("role", "application");
    if (this.defaultL10nId) {
      div.setAttribute("data-l10n-id", this.defaultL10nId);
    }
    if (!this._isVisible) {
      div.classList.add("hidden");
    }
    this.setInForeground();
    __privateMethod(this, _addFocusListeners, addFocusListeners_fn).call(this);
    const [parentWidth, parentHeight] = this.parentDimensions;
    if (this.parentRotation % 180 !== 0) {
      div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;
      div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;
    }
    const [tx, ty] = this.getInitialTranslation();
    this.translate(tx, ty);
    bindEvents(this, div, ["keydown", "pointerdown", "dblclick"]);
    if (this.isResizable && this._uiManager._supportsPinchToZoom) {
      __privateGet(this, _touchManager) || __privateSet(this, _touchManager, new TouchManager({
        container: div,
        isPinchingDisabled: () => !this.isSelected,
        onPinchStart: __privateMethod(this, _touchPinchStartCallback, touchPinchStartCallback_fn).bind(this),
        onPinching: __privateMethod(this, _touchPinchCallback, touchPinchCallback_fn).bind(this),
        onPinchEnd: __privateMethod(this, _touchPinchEndCallback, touchPinchEndCallback_fn).bind(this),
        signal: this._uiManager._signal
      }));
    }
    this.addStandaloneCommentButton();
    (_a2 = this._uiManager._editorUndoBar) == null ? void 0 : _a2.hide();
    return div;
  }
  pointerdown(event) {
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      event.preventDefault();
      return;
    }
    __privateSet(this, _hasBeenClicked, true);
    if (this._isDraggable) {
      __privateMethod(this, _setUpDragSession, setUpDragSession_fn).call(this, event);
      return;
    }
    __privateMethod(this, _selectOnPointerEvent, selectOnPointerEvent_fn).call(this, event);
  }
  _onStartDragging() {
  }
  _onStopDragging() {
  }
  moveInDOM() {
    if (__privateGet(this, _moveInDOMTimeout)) {
      clearTimeout(__privateGet(this, _moveInDOMTimeout));
    }
    __privateSet(this, _moveInDOMTimeout, setTimeout(() => {
      var _a2;
      __privateSet(this, _moveInDOMTimeout, null);
      (_a2 = this.parent) == null ? void 0 : _a2.moveEditorInDOM(this);
    }, 0));
  }
  _setParentAndPosition(parent, x, y) {
    parent.changeParent(this);
    this.x = x;
    this.y = y;
    this.fixAndSetPosition();
    this._onTranslated();
  }
  getRect(tx, ty, rotation = this.rotation) {
    const scale = this.parentScale;
    const [pageWidth, pageHeight] = this.pageDimensions;
    const [pageX, pageY] = this.pageTranslation;
    const shiftX = tx / scale;
    const shiftY = ty / scale;
    const x = this.x * pageWidth;
    const y = this.y * pageHeight;
    const width = this.width * pageWidth;
    const height = this.height * pageHeight;
    switch (rotation) {
      case 0:
        return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY];
      case 90:
        return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY];
      case 180:
        return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY];
      case 270:
        return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getRectInCurrentCoords(rect, pageHeight) {
    const [x1, y1, x2, y2] = rect;
    const width = x2 - x1;
    const height = y2 - y1;
    switch (this.rotation) {
      case 0:
        return [x1, pageHeight - y2, width, height];
      case 90:
        return [x1, pageHeight - y1, height, width];
      case 180:
        return [x2, pageHeight - y1, width, height];
      case 270:
        return [x2, pageHeight - y2, height, width];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getPDFRect() {
    return this.getRect(0, 0);
  }
  getNonHCMColor() {
    return this.color && _AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));
  }
  onUpdatedColor() {
    var _a2;
    (_a2 = __privateGet(this, _comment2)) == null ? void 0 : _a2.onUpdatedColor();
  }
  getData() {
    const {
      comment: {
        text: str,
        color,
        date,
        opacity,
        deleted,
        richText
      },
      uid: id,
      pageIndex,
      creationDate,
      modificationDate
    } = this;
    return {
      id,
      pageIndex,
      rect: this.getPDFRect(),
      richText,
      contentsObj: {
        str
      },
      creationDate,
      modificationDate: date || modificationDate,
      popupRef: !deleted,
      color,
      opacity
    };
  }
  onceAdded(focus) {
  }
  isEmpty() {
    return false;
  }
  enableEditMode() {
    if (this.isInEditMode()) {
      return false;
    }
    this.parent.setEditingState(false);
    __privateSet(this, _isInEditMode, true);
    return true;
  }
  disableEditMode() {
    if (!this.isInEditMode()) {
      return false;
    }
    this.parent.setEditingState(true);
    __privateSet(this, _isInEditMode, false);
    return true;
  }
  isInEditMode() {
    return __privateGet(this, _isInEditMode);
  }
  shouldGetKeyboardEvents() {
    return __privateGet(this, _isResizerEnabledForKeyboard);
  }
  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }
  get isOnScreen() {
    const {
      top,
      left,
      bottom,
      right
    } = this.getClientDimensions();
    const {
      innerHeight,
      innerWidth
    } = window;
    return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;
  }
  rebuild() {
    __privateMethod(this, _addFocusListeners, addFocusListeners_fn).call(this);
  }
  rotate(_angle) {
  }
  resize() {
  }
  serializeDeleted() {
    var _a2;
    return {
      id: this.annotationElementId,
      deleted: true,
      pageIndex: this.pageIndex,
      popupRef: ((_a2 = this._initialData) == null ? void 0 : _a2.popupRef) || ""
    };
  }
  serialize(isForCopying = false, context = null) {
    var _a2;
    return {
      annotationType: this.mode,
      pageIndex: this.pageIndex,
      rect: this.getPDFRect(),
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId,
      popupRef: ((_a2 = this._initialData) == null ? void 0 : _a2.popupRef) || ""
    };
  }
  static async deserialize(data, parent, uiManager) {
    const editor = new this.prototype.constructor({
      parent,
      id: parent.getNextId(),
      uiManager,
      annotationElementId: data.annotationElementId,
      creationDate: data.creationDate,
      modificationDate: data.modificationDate
    });
    editor.rotation = data.rotation;
    __privateSet(editor, _accessibilityData, data.accessibilityData);
    editor._isCopy = data.isCopy || false;
    const [pageWidth, pageHeight] = editor.pageDimensions;
    const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
    editor.x = x / pageWidth;
    editor.y = y / pageHeight;
    editor.width = width / pageWidth;
    editor.height = height / pageHeight;
    return editor;
  }
  get hasBeenModified() {
    return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
  }
  remove() {
    var _a2, _b;
    (_a2 = __privateGet(this, _focusAC)) == null ? void 0 : _a2.abort();
    __privateSet(this, _focusAC, null);
    if (!this.isEmpty()) {
      this.commit();
    }
    if (this.parent) {
      this.parent.remove(this);
    } else {
      this._uiManager.removeEditor(this);
    }
    if (__privateGet(this, _moveInDOMTimeout)) {
      clearTimeout(__privateGet(this, _moveInDOMTimeout));
      __privateSet(this, _moveInDOMTimeout, null);
    }
    __privateMethod(this, _stopResizing, stopResizing_fn).call(this);
    this.removeEditToolbar();
    if (__privateGet(this, _telemetryTimeouts)) {
      for (const timeout of __privateGet(this, _telemetryTimeouts).values()) {
        clearTimeout(timeout);
      }
      __privateSet(this, _telemetryTimeouts, null);
    }
    this.parent = null;
    (_b = __privateGet(this, _touchManager)) == null ? void 0 : _b.destroy();
    __privateSet(this, _touchManager, null);
  }
  get isResizable() {
    return false;
  }
  makeResizable() {
    if (this.isResizable) {
      __privateMethod(this, _createResizers, createResizers_fn).call(this);
      __privateGet(this, _resizersDiv).classList.remove("hidden");
    }
  }
  get toolbarPosition() {
    return null;
  }
  get commentButtonPosition() {
    return this._uiManager.direction === "ltr" ? [1, 0] : [0, 0];
  }
  get commentButtonPositionInPage() {
    const {
      commentButtonPosition: [posX, posY]
    } = this;
    const [blX, blY, trX, trY] = this.getPDFRect();
    return [_AnnotationEditor._round(blX + (trX - blX) * posX), _AnnotationEditor._round(blY + (trY - blY) * (1 - posY))];
  }
  get commentButtonColor() {
    return this._uiManager.makeCommentColor(this.getNonHCMColor(), this.opacity);
  }
  get commentPopupPosition() {
    return __privateGet(this, _comment2).commentPopupPositionInLayer;
  }
  set commentPopupPosition(pos) {
    __privateGet(this, _comment2).commentPopupPositionInLayer = pos;
  }
  hasDefaultPopupPosition() {
    return __privateGet(this, _comment2).hasDefaultPopupPosition();
  }
  get commentButtonWidth() {
    return __privateGet(this, _comment2).commentButtonWidth;
  }
  get elementBeforePopup() {
    return this.div;
  }
  setCommentButtonStates(options) {
    __privateGet(this, _comment2).setCommentButtonStates(options);
  }
  keydown(event) {
    if (!this.isResizable || event.target !== this.div || event.key !== "Enter") {
      return;
    }
    this._uiManager.setSelected(this);
    __privateSet(this, _savedDimensions, {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    });
    const children = __privateGet(this, _resizersDiv).children;
    if (!__privateGet(this, _allResizerDivs)) {
      __privateSet(this, _allResizerDivs, Array.from(children));
      const boundResizerKeydown = __privateMethod(this, _resizerKeydown, resizerKeydown_fn).bind(this);
      const boundResizerBlur = __privateMethod(this, _resizerBlur, resizerBlur_fn).bind(this);
      const signal = this._uiManager._signal;
      for (const div of __privateGet(this, _allResizerDivs)) {
        const name = div.getAttribute("data-resizer-name");
        div.setAttribute("role", "spinbutton");
        div.addEventListener("keydown", boundResizerKeydown, {
          signal
        });
        div.addEventListener("blur", boundResizerBlur, {
          signal
        });
        div.addEventListener("focus", __privateMethod(this, _resizerFocus, resizerFocus_fn).bind(this, name), {
          signal
        });
        div.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[name]);
      }
    }
    const first = __privateGet(this, _allResizerDivs)[0];
    let firstPosition = 0;
    for (const div of children) {
      if (div === first) {
        break;
      }
      firstPosition++;
    }
    const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (__privateGet(this, _allResizerDivs).length / 4);
    if (nextFirstPosition !== firstPosition) {
      if (nextFirstPosition < firstPosition) {
        for (let i2 = 0; i2 < firstPosition - nextFirstPosition; i2++) {
          __privateGet(this, _resizersDiv).append(__privateGet(this, _resizersDiv).firstChild);
        }
      } else if (nextFirstPosition > firstPosition) {
        for (let i2 = 0; i2 < nextFirstPosition - firstPosition; i2++) {
          __privateGet(this, _resizersDiv).firstChild.before(__privateGet(this, _resizersDiv).lastChild);
        }
      }
      let i = 0;
      for (const child of children) {
        const div = __privateGet(this, _allResizerDivs)[i++];
        const name = div.getAttribute("data-resizer-name");
        child.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[name]);
      }
    }
    __privateMethod(this, _setResizerTabIndex, setResizerTabIndex_fn).call(this, 0);
    __privateSet(this, _isResizerEnabledForKeyboard, true);
    __privateGet(this, _resizersDiv).firstChild.focus({
      focusVisible: true
    });
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  _resizeWithKeyboard(x, y) {
    if (!__privateGet(this, _isResizerEnabledForKeyboard)) {
      return;
    }
    __privateMethod(this, _resizerPointermove, resizerPointermove_fn).call(this, __privateGet(this, _focusedResizerName), {
      deltaX: x,
      deltaY: y,
      fromKeyboard: true
    });
  }
  _stopResizingWithKeyboard() {
    __privateMethod(this, _stopResizing, stopResizing_fn).call(this);
    this.div.focus();
  }
  select() {
    var _a2, _b, _c;
    if (this.isSelected && this._editToolbar) {
      this._editToolbar.show();
      return;
    }
    this.isSelected = true;
    this.makeResizable();
    (_a2 = this.div) == null ? void 0 : _a2.classList.add("selectedEditor");
    if (!this._editToolbar) {
      this.addEditToolbar().then(() => {
        var _a3, _b2;
        if ((_a3 = this.div) == null ? void 0 : _a3.classList.contains("selectedEditor")) {
          (_b2 = this._editToolbar) == null ? void 0 : _b2.show();
        }
      });
      return;
    }
    (_b = this._editToolbar) == null ? void 0 : _b.show();
    (_c = __privateGet(this, _altText3)) == null ? void 0 : _c.toggleAltTextBadge(false);
  }
  focus() {
    if (this.div && !this.div.contains(document.activeElement)) {
      setTimeout(() => {
        var _a2;
        return (_a2 = this.div) == null ? void 0 : _a2.focus({
          preventScroll: true
        });
      }, 0);
    }
  }
  unselect() {
    var _a2, _b, _c, _d, _e;
    if (!this.isSelected) {
      return;
    }
    this.isSelected = false;
    (_a2 = __privateGet(this, _resizersDiv)) == null ? void 0 : _a2.classList.add("hidden");
    (_b = this.div) == null ? void 0 : _b.classList.remove("selectedEditor");
    if ((_c = this.div) == null ? void 0 : _c.contains(document.activeElement)) {
      this._uiManager.currentLayer.div.focus({
        preventScroll: true
      });
    }
    (_d = this._editToolbar) == null ? void 0 : _d.hide();
    (_e = __privateGet(this, _altText3)) == null ? void 0 : _e.toggleAltTextBadge(true);
    if (this.hasComment) {
      this._uiManager.toggleComment(this, false, false);
    }
  }
  updateParams(type, value) {
  }
  disableEditing() {
  }
  enableEditing() {
  }
  get canChangeContent() {
    return false;
  }
  enterInEditMode() {
    if (!this.canChangeContent) {
      return;
    }
    this.enableEditMode();
    this.div.focus();
  }
  dblclick(event) {
    if (event.target.nodeName === "BUTTON") {
      return;
    }
    this.enterInEditMode();
    this.parent.updateToolbar({
      mode: this.constructor._editorType,
      editId: this.id
    });
  }
  getElementForAltText() {
    return this.div;
  }
  get contentDiv() {
    return this.div;
  }
  get isEditing() {
    return __privateGet(this, _isEditing);
  }
  set isEditing(value) {
    __privateSet(this, _isEditing, value);
    if (!this.parent) {
      return;
    }
    if (value) {
      this.parent.setSelected(this);
      this.parent.setActiveEditor(this);
    } else {
      this.parent.setActiveEditor(null);
    }
  }
  static get MIN_SIZE() {
    return 16;
  }
  static canCreateNewEmptyEditor() {
    return true;
  }
  get telemetryInitialData() {
    return {
      action: "added"
    };
  }
  get telemetryFinalData() {
    return null;
  }
  _reportTelemetry(data, mustWait = false) {
    if (mustWait) {
      __privateGet(this, _telemetryTimeouts) || __privateSet(this, _telemetryTimeouts, /* @__PURE__ */ new Map());
      const {
        action
      } = data;
      let timeout = __privateGet(this, _telemetryTimeouts).get(action);
      if (timeout) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(() => {
        this._reportTelemetry(data);
        __privateGet(this, _telemetryTimeouts).delete(action);
        if (__privateGet(this, _telemetryTimeouts).size === 0) {
          __privateSet(this, _telemetryTimeouts, null);
        }
      }, _AnnotationEditor._telemetryTimeout);
      __privateGet(this, _telemetryTimeouts).set(action, timeout);
      return;
    }
    data.type || (data.type = this.editorType);
    this._uiManager._eventBus.dispatch("reporttelemetry", {
      source: this,
      details: {
        type: "editing",
        data
      }
    });
  }
  show(visible = this._isVisible) {
    this.div.classList.toggle("hidden", !visible);
    this._isVisible = visible;
  }
  enable() {
    if (this.div) {
      this.div.tabIndex = 0;
    }
    __privateSet(this, _disabled, false);
  }
  disable() {
    if (this.div) {
      this.div.tabIndex = -1;
    }
    __privateSet(this, _disabled, true);
  }
  updateFakeAnnotationElement(annotationLayer) {
    if (!__privateGet(this, _fakeAnnotation) && !this.deleted) {
      __privateSet(this, _fakeAnnotation, annotationLayer.addFakeAnnotation(this));
      return;
    }
    if (this.deleted) {
      __privateGet(this, _fakeAnnotation).remove();
      __privateSet(this, _fakeAnnotation, null);
      return;
    }
    if (this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized) {
      __privateGet(this, _fakeAnnotation).updateEdited({
        rect: this.getPDFRect(),
        popup: this.comment
      });
    }
  }
  renderAnnotationElement(annotation) {
    if (this.deleted) {
      annotation.hide();
      return null;
    }
    let content = annotation.container.querySelector(".annotationContent");
    if (!content) {
      content = document.createElement("div");
      content.classList.add("annotationContent", this.editorType);
      annotation.container.prepend(content);
    } else if (content.nodeName === "CANVAS") {
      const canvas = content;
      content = document.createElement("div");
      content.classList.add("annotationContent", this.editorType);
      canvas.before(content);
    }
    return content;
  }
  resetAnnotationElement(annotation) {
    const {
      firstChild
    } = annotation.container;
    if ((firstChild == null ? void 0 : firstChild.nodeName) === "DIV" && firstChild.classList.contains("annotationContent")) {
      firstChild.remove();
    }
  }
};
_accessibilityData = new WeakMap();
_allResizerDivs = new WeakMap();
_altText3 = new WeakMap();
_comment2 = new WeakMap();
_commentStandaloneButton2 = new WeakMap();
_disabled = new WeakMap();
_dragPointerId = new WeakMap();
_dragPointerType = new WeakMap();
_resizersDiv = new WeakMap();
_lastPointerCoords = new WeakMap();
_savedDimensions = new WeakMap();
_fakeAnnotation = new WeakMap();
_focusAC = new WeakMap();
_focusedResizerName = new WeakMap();
_hasBeenClicked = new WeakMap();
_initialRect = new WeakMap();
_isEditing = new WeakMap();
_isInEditMode = new WeakMap();
_isResizerEnabledForKeyboard = new WeakMap();
_moveInDOMTimeout = new WeakMap();
_prevDragX = new WeakMap();
_prevDragY = new WeakMap();
_telemetryTimeouts = new WeakMap();
_touchManager = new WeakMap();
_isDraggable = new WeakMap();
_zIndex = new WeakMap();
_translate = new WeakSet();
translate_fn = function([width, height], x, y) {
  [x, y] = this.screenToPageTranslation(x, y);
  this.x += x / width;
  this.y += y / height;
  this._onTranslating(this.x, this.y);
  this.fixAndSetPosition();
};
_rotatePoint = new WeakSet();
rotatePoint_fn = function(x, y, angle) {
  switch (angle) {
    case 90:
      return [y, -x];
    case 180:
      return [-x, -y];
    case 270:
      return [-y, x];
    default:
      return [x, y];
  }
};
_getRotationMatrix = new WeakSet();
getRotationMatrix_fn = function(rotation) {
  switch (rotation) {
    case 90: {
      const [pageWidth, pageHeight] = this.pageDimensions;
      return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];
    }
    case 180:
      return [-1, 0, 0, -1];
    case 270: {
      const [pageWidth, pageHeight] = this.pageDimensions;
      return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];
    }
    default:
      return [1, 0, 0, 1];
  }
};
_createResizers = new WeakSet();
createResizers_fn = function() {
  if (__privateGet(this, _resizersDiv)) {
    return;
  }
  __privateSet(this, _resizersDiv, document.createElement("div"));
  __privateGet(this, _resizersDiv).classList.add("resizers");
  const classes = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"];
  const signal = this._uiManager._signal;
  for (const name of classes) {
    const div = document.createElement("div");
    __privateGet(this, _resizersDiv).append(div);
    div.classList.add("resizer", name);
    div.setAttribute("data-resizer-name", name);
    div.addEventListener("pointerdown", __privateMethod(this, _resizerPointerdown, resizerPointerdown_fn).bind(this, name), {
      signal
    });
    div.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    div.tabIndex = -1;
  }
  this.div.prepend(__privateGet(this, _resizersDiv));
};
_resizerPointerdown = new WeakSet();
resizerPointerdown_fn = function(name, event) {
  var _a2;
  event.preventDefault();
  const {
    isMac
  } = util_FeatureTest.platform;
  if (event.button !== 0 || event.ctrlKey && isMac) {
    return;
  }
  (_a2 = __privateGet(this, _altText3)) == null ? void 0 : _a2.toggle(false);
  const savedDraggable = this._isDraggable;
  this._isDraggable = false;
  __privateSet(this, _lastPointerCoords, [event.screenX, event.screenY]);
  const ac = new AbortController();
  const signal = this._uiManager.combinedSignal(ac);
  this.parent.togglePointerEvents(false);
  window.addEventListener("pointermove", __privateMethod(this, _resizerPointermove, resizerPointermove_fn).bind(this, name), {
    passive: true,
    capture: true,
    signal
  });
  window.addEventListener("touchmove", stopEvent, {
    passive: false,
    signal
  });
  window.addEventListener("contextmenu", noContextMenu, {
    signal
  });
  __privateSet(this, _savedDimensions, {
    savedX: this.x,
    savedY: this.y,
    savedWidth: this.width,
    savedHeight: this.height
  });
  const savedParentCursor = this.parent.div.style.cursor;
  const savedCursor = this.div.style.cursor;
  this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;
  const pointerUpCallback = () => {
    var _a3;
    ac.abort();
    this.parent.togglePointerEvents(true);
    (_a3 = __privateGet(this, _altText3)) == null ? void 0 : _a3.toggle(true);
    this._isDraggable = savedDraggable;
    this.parent.div.style.cursor = savedParentCursor;
    this.div.style.cursor = savedCursor;
    __privateMethod(this, _addResizeToUndoStack, addResizeToUndoStack_fn).call(this);
  };
  window.addEventListener("pointerup", pointerUpCallback, {
    signal
  });
  window.addEventListener("blur", pointerUpCallback, {
    signal
  });
};
_resize = new WeakSet();
resize_fn = function(x, y, width, height) {
  this.width = width;
  this.height = height;
  this.x = x;
  this.y = y;
  this.setDims();
  this.fixAndSetPosition();
  this._onResized();
};
_addResizeToUndoStack = new WeakSet();
addResizeToUndoStack_fn = function() {
  if (!__privateGet(this, _savedDimensions)) {
    return;
  }
  const {
    savedX,
    savedY,
    savedWidth,
    savedHeight
  } = __privateGet(this, _savedDimensions);
  __privateSet(this, _savedDimensions, null);
  const newX = this.x;
  const newY = this.y;
  const newWidth = this.width;
  const newHeight = this.height;
  if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {
    return;
  }
  this.addCommands({
    cmd: __privateMethod(this, _resize, resize_fn).bind(this, newX, newY, newWidth, newHeight),
    undo: __privateMethod(this, _resize, resize_fn).bind(this, savedX, savedY, savedWidth, savedHeight),
    mustExec: true
  });
};
_resizerPointermove = new WeakSet();
resizerPointermove_fn = function(name, event) {
  const [parentWidth, parentHeight] = this.parentDimensions;
  const savedX = this.x;
  const savedY = this.y;
  const savedWidth = this.width;
  const savedHeight = this.height;
  const minWidth = _AnnotationEditor.MIN_SIZE / parentWidth;
  const minHeight = _AnnotationEditor.MIN_SIZE / parentHeight;
  const rotationMatrix = __privateMethod(this, _getRotationMatrix, getRotationMatrix_fn).call(this, this.rotation);
  const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];
  const invRotationMatrix = __privateMethod(this, _getRotationMatrix, getRotationMatrix_fn).call(this, 360 - this.rotation);
  const invTransf = (x, y) => [invRotationMatrix[0] * x + invRotationMatrix[2] * y, invRotationMatrix[1] * x + invRotationMatrix[3] * y];
  let getPoint;
  let getOpposite;
  let isDiagonal = false;
  let isHorizontal = false;
  switch (name) {
    case "topLeft":
      isDiagonal = true;
      getPoint = (w, h) => [0, 0];
      getOpposite = (w, h) => [w, h];
      break;
    case "topMiddle":
      getPoint = (w, h) => [w / 2, 0];
      getOpposite = (w, h) => [w / 2, h];
      break;
    case "topRight":
      isDiagonal = true;
      getPoint = (w, h) => [w, 0];
      getOpposite = (w, h) => [0, h];
      break;
    case "middleRight":
      isHorizontal = true;
      getPoint = (w, h) => [w, h / 2];
      getOpposite = (w, h) => [0, h / 2];
      break;
    case "bottomRight":
      isDiagonal = true;
      getPoint = (w, h) => [w, h];
      getOpposite = (w, h) => [0, 0];
      break;
    case "bottomMiddle":
      getPoint = (w, h) => [w / 2, h];
      getOpposite = (w, h) => [w / 2, 0];
      break;
    case "bottomLeft":
      isDiagonal = true;
      getPoint = (w, h) => [0, h];
      getOpposite = (w, h) => [w, 0];
      break;
    case "middleLeft":
      isHorizontal = true;
      getPoint = (w, h) => [0, h / 2];
      getOpposite = (w, h) => [w, h / 2];
      break;
  }
  const point = getPoint(savedWidth, savedHeight);
  const oppositePoint = getOpposite(savedWidth, savedHeight);
  let transfOppositePoint = transf(...oppositePoint);
  const oppositeX = _AnnotationEditor._round(savedX + transfOppositePoint[0]);
  const oppositeY = _AnnotationEditor._round(savedY + transfOppositePoint[1]);
  let ratioX = 1;
  let ratioY = 1;
  let deltaX, deltaY;
  if (!event.fromKeyboard) {
    const {
      screenX,
      screenY
    } = event;
    const [lastScreenX, lastScreenY] = __privateGet(this, _lastPointerCoords);
    [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);
    __privateGet(this, _lastPointerCoords)[0] = screenX;
    __privateGet(this, _lastPointerCoords)[1] = screenY;
  } else {
    ({
      deltaX,
      deltaY
    } = event);
  }
  [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);
  if (isDiagonal) {
    const oldDiag = Math.hypot(savedWidth, savedHeight);
    ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
  } else if (isHorizontal) {
    ratioX = MathClamp(Math.abs(oppositePoint[0] - point[0] - deltaX), minWidth, 1) / savedWidth;
  } else {
    ratioY = MathClamp(Math.abs(oppositePoint[1] - point[1] - deltaY), minHeight, 1) / savedHeight;
  }
  const newWidth = _AnnotationEditor._round(savedWidth * ratioX);
  const newHeight = _AnnotationEditor._round(savedHeight * ratioY);
  transfOppositePoint = transf(...getOpposite(newWidth, newHeight));
  const newX = oppositeX - transfOppositePoint[0];
  const newY = oppositeY - transfOppositePoint[1];
  __privateGet(this, _initialRect) || __privateSet(this, _initialRect, [this.x, this.y, this.width, this.height]);
  this.width = newWidth;
  this.height = newHeight;
  this.x = newX;
  this.y = newY;
  this.setDims();
  this.fixAndSetPosition();
  this._onResizing();
};
_touchPinchStartCallback = new WeakSet();
touchPinchStartCallback_fn = function() {
  var _a2;
  __privateSet(this, _savedDimensions, {
    savedX: this.x,
    savedY: this.y,
    savedWidth: this.width,
    savedHeight: this.height
  });
  (_a2 = __privateGet(this, _altText3)) == null ? void 0 : _a2.toggle(false);
  this.parent.togglePointerEvents(false);
};
_touchPinchCallback = new WeakSet();
touchPinchCallback_fn = function(_origin, prevDistance, distance) {
  const slowDownFactor = 0.7;
  let factor = slowDownFactor * (distance / prevDistance) + 1 - slowDownFactor;
  if (factor === 1) {
    return;
  }
  const rotationMatrix = __privateMethod(this, _getRotationMatrix, getRotationMatrix_fn).call(this, this.rotation);
  const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];
  const [parentWidth, parentHeight] = this.parentDimensions;
  const savedX = this.x;
  const savedY = this.y;
  const savedWidth = this.width;
  const savedHeight = this.height;
  const minWidth = _AnnotationEditor.MIN_SIZE / parentWidth;
  const minHeight = _AnnotationEditor.MIN_SIZE / parentHeight;
  factor = Math.max(Math.min(factor, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
  const newWidth = _AnnotationEditor._round(savedWidth * factor);
  const newHeight = _AnnotationEditor._round(savedHeight * factor);
  if (newWidth === savedWidth && newHeight === savedHeight) {
    return;
  }
  __privateGet(this, _initialRect) || __privateSet(this, _initialRect, [savedX, savedY, savedWidth, savedHeight]);
  const transfCenterPoint = transf(savedWidth / 2, savedHeight / 2);
  const centerX = _AnnotationEditor._round(savedX + transfCenterPoint[0]);
  const centerY = _AnnotationEditor._round(savedY + transfCenterPoint[1]);
  const newTransfCenterPoint = transf(newWidth / 2, newHeight / 2);
  this.x = centerX - newTransfCenterPoint[0];
  this.y = centerY - newTransfCenterPoint[1];
  this.width = newWidth;
  this.height = newHeight;
  this.setDims();
  this.fixAndSetPosition();
  this._onResizing();
};
_touchPinchEndCallback = new WeakSet();
touchPinchEndCallback_fn = function() {
  var _a2;
  (_a2 = __privateGet(this, _altText3)) == null ? void 0 : _a2.toggle(true);
  this.parent.togglePointerEvents(true);
  __privateMethod(this, _addResizeToUndoStack, addResizeToUndoStack_fn).call(this);
};
_selectOnPointerEvent = new WeakSet();
selectOnPointerEvent_fn = function(event) {
  const {
    isMac
  } = util_FeatureTest.platform;
  if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
    this.parent.toggleSelected(this);
  } else {
    this.parent.setSelected(this);
  }
};
_setUpDragSession = new WeakSet();
setUpDragSession_fn = function(event) {
  const {
    isSelected
  } = this;
  this._uiManager.setUpDragSession();
  let hasDraggingStarted = false;
  const ac = new AbortController();
  const signal = this._uiManager.combinedSignal(ac);
  const opts = {
    capture: true,
    passive: false,
    signal
  };
  const cancelDrag = (e) => {
    ac.abort();
    __privateSet(this, _dragPointerId, null);
    __privateSet(this, _hasBeenClicked, false);
    if (!this._uiManager.endDragSession()) {
      __privateMethod(this, _selectOnPointerEvent, selectOnPointerEvent_fn).call(this, e);
    }
    if (hasDraggingStarted) {
      this._onStopDragging();
    }
  };
  if (isSelected) {
    __privateSet(this, _prevDragX, event.clientX);
    __privateSet(this, _prevDragY, event.clientY);
    __privateSet(this, _dragPointerId, event.pointerId);
    __privateSet(this, _dragPointerType, event.pointerType);
    window.addEventListener("pointermove", (e) => {
      if (!hasDraggingStarted) {
        hasDraggingStarted = true;
        this._uiManager.toggleComment(this, true, false);
        this._onStartDragging();
      }
      const {
        clientX: x,
        clientY: y,
        pointerId
      } = e;
      if (pointerId !== __privateGet(this, _dragPointerId)) {
        stopEvent(e);
        return;
      }
      const [tx, ty] = this.screenToPageTranslation(x - __privateGet(this, _prevDragX), y - __privateGet(this, _prevDragY));
      __privateSet(this, _prevDragX, x);
      __privateSet(this, _prevDragY, y);
      this._uiManager.dragSelectedEditors(tx, ty);
    }, opts);
    window.addEventListener("touchmove", stopEvent, opts);
    window.addEventListener("pointerdown", (e) => {
      if (e.pointerType === __privateGet(this, _dragPointerType)) {
        if (__privateGet(this, _touchManager) || e.isPrimary) {
          cancelDrag(e);
        }
      }
      stopEvent(e);
    }, opts);
  }
  const pointerUpCallback = (e) => {
    if (!__privateGet(this, _dragPointerId) || __privateGet(this, _dragPointerId) === e.pointerId) {
      cancelDrag(e);
      return;
    }
    stopEvent(e);
  };
  window.addEventListener("pointerup", pointerUpCallback, {
    signal
  });
  window.addEventListener("blur", pointerUpCallback, {
    signal
  });
};
_addFocusListeners = new WeakSet();
addFocusListeners_fn = function() {
  if (__privateGet(this, _focusAC) || !this.div) {
    return;
  }
  __privateSet(this, _focusAC, new AbortController());
  const signal = this._uiManager.combinedSignal(__privateGet(this, _focusAC));
  this.div.addEventListener("focusin", this.focusin.bind(this), {
    signal
  });
  this.div.addEventListener("focusout", this.focusout.bind(this), {
    signal
  });
};
_resizerKeydown = new WeakSet();
resizerKeydown_fn = function(event) {
  _AnnotationEditor._resizerKeyboardManager.exec(this, event);
};
_resizerBlur = new WeakSet();
resizerBlur_fn = function(event) {
  var _a2;
  if (__privateGet(this, _isResizerEnabledForKeyboard) && ((_a2 = event.relatedTarget) == null ? void 0 : _a2.parentNode) !== __privateGet(this, _resizersDiv)) {
    __privateMethod(this, _stopResizing, stopResizing_fn).call(this);
  }
};
_resizerFocus = new WeakSet();
resizerFocus_fn = function(name) {
  __privateSet(this, _focusedResizerName, __privateGet(this, _isResizerEnabledForKeyboard) ? name : "");
};
_setResizerTabIndex = new WeakSet();
setResizerTabIndex_fn = function(value) {
  if (!__privateGet(this, _allResizerDivs)) {
    return;
  }
  for (const div of __privateGet(this, _allResizerDivs)) {
    div.tabIndex = value;
  }
};
_stopResizing = new WeakSet();
stopResizing_fn = function() {
  __privateSet(this, _isResizerEnabledForKeyboard, false);
  __privateMethod(this, _setResizerTabIndex, setResizerTabIndex_fn).call(this, -1);
  __privateMethod(this, _addResizeToUndoStack, addResizeToUndoStack_fn).call(this);
};
__privateAdd(_AnnotationEditor, _rotatePoint);
__publicField(_AnnotationEditor, "_l10n", null);
__publicField(_AnnotationEditor, "_l10nResizer", null);
__publicField(_AnnotationEditor, "_borderLineWidth", -1);
__publicField(_AnnotationEditor, "_colorManager", new ColorManager());
__publicField(_AnnotationEditor, "_zIndex", 1);
__publicField(_AnnotationEditor, "_telemetryTimeout", 1e3);
var AnnotationEditor = _AnnotationEditor;
var FakeEditor = class extends AnnotationEditor {
  constructor(params) {
    super(params);
    this.annotationElementId = params.annotationElementId;
    this.deleted = true;
  }
  serialize() {
    return this.serializeDeleted();
  }
};
var SEED = 3285377520;
var MASK_HIGH = 4294901760;
var MASK_LOW = 65535;
var MurmurHash3_64 = class {
  constructor(seed) {
    this.h1 = seed ? seed & 4294967295 : SEED;
    this.h2 = seed ? seed & 4294967295 : SEED;
  }
  update(input) {
    let data, length;
    if (typeof input === "string") {
      data = new Uint8Array(input.length * 2);
      length = 0;
      for (let i = 0, ii = input.length; i < ii; i++) {
        const code = input.charCodeAt(i);
        if (code <= 255) {
          data[length++] = code;
        } else {
          data[length++] = code >>> 8;
          data[length++] = code & 255;
        }
      }
    } else if (ArrayBuffer.isView(input)) {
      data = input.slice();
      length = data.byteLength;
    } else {
      throw new Error("Invalid data format, must be a string or TypedArray.");
    }
    const blockCounts = length >> 2;
    const tailLength = length - blockCounts * 4;
    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
    let k1 = 0, k2 = 0;
    let h1 = this.h1, h2 = this.h2;
    const C1 = 3432918353, C2 = 461845907;
    const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
    for (let i = 0; i < blockCounts; i++) {
      if (i & 1) {
        k1 = dataUint32[i];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1 = h1 * 5 + 3864292196;
      } else {
        k2 = dataUint32[i];
        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
        k2 = k2 << 15 | k2 >>> 17;
        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
        h2 ^= k2;
        h2 = h2 << 13 | h2 >>> 19;
        h2 = h2 * 5 + 3864292196;
      }
    }
    k1 = 0;
    switch (tailLength) {
      case 3:
        k1 ^= data[blockCounts * 4 + 2] << 16;
      case 2:
        k1 ^= data[blockCounts * 4 + 1] << 8;
      case 1:
        k1 ^= data[blockCounts * 4];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        if (blockCounts & 1) {
          h1 ^= k1;
        } else {
          h2 ^= k1;
        }
    }
    this.h1 = h1;
    this.h2 = h2;
  }
  hexdigest() {
    let h1 = this.h1, h2 = this.h2;
    h1 ^= h2 >>> 1;
    h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
    h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
    h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    return (h1 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
  }
};
var SerializableEmpty = Object.freeze({
  map: null,
  hash: "",
  transfer: void 0
});
var _modified, _modifiedIds, _editorsMap, _storage, _setModified, setModified_fn;
var AnnotationStorage = class {
  constructor() {
    __privateAdd(this, _setModified);
    __privateAdd(this, _modified, false);
    __privateAdd(this, _modifiedIds, null);
    __privateAdd(this, _editorsMap, null);
    __privateAdd(this, _storage, /* @__PURE__ */ new Map());
    this.onSetModified = null;
    this.onResetModified = null;
    this.onAnnotationEditor = null;
  }
  getValue(key, defaultValue) {
    const value = __privateGet(this, _storage).get(key);
    if (value === void 0) {
      return defaultValue;
    }
    return Object.assign(defaultValue, value);
  }
  getRawValue(key) {
    return __privateGet(this, _storage).get(key);
  }
  remove(key) {
    const storedValue = __privateGet(this, _storage).get(key);
    if (storedValue === void 0) {
      return;
    }
    if (storedValue instanceof AnnotationEditor) {
      __privateGet(this, _editorsMap).delete(storedValue.annotationElementId);
    }
    __privateGet(this, _storage).delete(key);
    if (__privateGet(this, _storage).size === 0) {
      this.resetModified();
    }
    if (typeof this.onAnnotationEditor === "function") {
      for (const value of __privateGet(this, _storage).values()) {
        if (value instanceof AnnotationEditor) {
          return;
        }
      }
      this.onAnnotationEditor(null);
    }
  }
  setValue(key, value) {
    const obj = __privateGet(this, _storage).get(key);
    let modified = false;
    if (obj !== void 0) {
      for (const [entry, val] of Object.entries(value)) {
        if (obj[entry] !== val) {
          modified = true;
          obj[entry] = val;
        }
      }
    } else {
      modified = true;
      __privateGet(this, _storage).set(key, value);
    }
    if (modified) {
      __privateMethod(this, _setModified, setModified_fn).call(this);
    }
    if (value instanceof AnnotationEditor) {
      (__privateGet(this, _editorsMap) || __privateSet(this, _editorsMap, /* @__PURE__ */ new Map())).set(value.annotationElementId, value);
      if (typeof this.onAnnotationEditor === "function") {
        this.onAnnotationEditor(value.constructor._type);
      }
    }
  }
  has(key) {
    return __privateGet(this, _storage).has(key);
  }
  get size() {
    return __privateGet(this, _storage).size;
  }
  resetModified() {
    if (__privateGet(this, _modified)) {
      __privateSet(this, _modified, false);
      if (typeof this.onResetModified === "function") {
        this.onResetModified();
      }
    }
  }
  get print() {
    return new PrintAnnotationStorage(this);
  }
  get serializable() {
    if (__privateGet(this, _storage).size === 0) {
      return SerializableEmpty;
    }
    const map = /* @__PURE__ */ new Map(), hash = new MurmurHash3_64(), transfer = [];
    const context = /* @__PURE__ */ Object.create(null);
    let hasBitmap = false;
    for (const [key, val] of __privateGet(this, _storage)) {
      const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;
      if (serialized) {
        map.set(key, serialized);
        hash.update(`${key}:${JSON.stringify(serialized)}`);
        hasBitmap || (hasBitmap = !!serialized.bitmap);
      }
    }
    if (hasBitmap) {
      for (const value of map.values()) {
        if (value.bitmap) {
          transfer.push(value.bitmap);
        }
      }
    }
    return map.size > 0 ? {
      map,
      hash: hash.hexdigest(),
      transfer
    } : SerializableEmpty;
  }
  get editorStats() {
    let stats = null;
    const typeToEditor = /* @__PURE__ */ new Map();
    let numberOfEditedComments = 0;
    let numberOfDeletedComments = 0;
    for (const value of __privateGet(this, _storage).values()) {
      if (!(value instanceof AnnotationEditor)) {
        if (value.popup) {
          if (value.popup.deleted) {
            numberOfDeletedComments += 1;
          } else {
            numberOfEditedComments += 1;
          }
        }
        continue;
      }
      if (value.isCommentDeleted) {
        numberOfDeletedComments += 1;
      } else if (value.hasEditedComment) {
        numberOfEditedComments += 1;
      }
      const editorStats = value.telemetryFinalData;
      if (!editorStats) {
        continue;
      }
      const {
        type
      } = editorStats;
      if (!typeToEditor.has(type)) {
        typeToEditor.set(type, Object.getPrototypeOf(value).constructor);
      }
      stats || (stats = /* @__PURE__ */ Object.create(null));
      const map = stats[type] || (stats[type] = /* @__PURE__ */ new Map());
      for (const [key, val] of Object.entries(editorStats)) {
        if (key === "type") {
          continue;
        }
        let counters = map.get(key);
        if (!counters) {
          counters = /* @__PURE__ */ new Map();
          map.set(key, counters);
        }
        const count = counters.get(val) ?? 0;
        counters.set(val, count + 1);
      }
    }
    if (numberOfDeletedComments > 0 || numberOfEditedComments > 0) {
      stats || (stats = /* @__PURE__ */ Object.create(null));
      stats.comments = {
        deleted: numberOfDeletedComments,
        edited: numberOfEditedComments
      };
    }
    if (!stats) {
      return null;
    }
    for (const [type, editor] of typeToEditor) {
      stats[type] = editor.computeTelemetryFinalData(stats[type]);
    }
    return stats;
  }
  resetModifiedIds() {
    __privateSet(this, _modifiedIds, null);
  }
  updateEditor(annotationId, data) {
    var _a2;
    const value = (_a2 = __privateGet(this, _editorsMap)) == null ? void 0 : _a2.get(annotationId);
    if (value) {
      value.updateFromAnnotationLayer(data);
      return true;
    }
    return false;
  }
  getEditor(annotationId) {
    var _a2;
    return ((_a2 = __privateGet(this, _editorsMap)) == null ? void 0 : _a2.get(annotationId)) || null;
  }
  get modifiedIds() {
    if (__privateGet(this, _modifiedIds)) {
      return __privateGet(this, _modifiedIds);
    }
    const ids = [];
    if (__privateGet(this, _editorsMap)) {
      for (const value of __privateGet(this, _editorsMap).values()) {
        if (!value.serialize()) {
          continue;
        }
        ids.push(value.annotationElementId);
      }
    }
    return __privateSet(this, _modifiedIds, {
      ids: new Set(ids),
      hash: ids.join(",")
    });
  }
  [Symbol.iterator]() {
    return __privateGet(this, _storage).entries();
  }
};
_modified = new WeakMap();
_modifiedIds = new WeakMap();
_editorsMap = new WeakMap();
_storage = new WeakMap();
_setModified = new WeakSet();
setModified_fn = function() {
  if (!__privateGet(this, _modified)) {
    __privateSet(this, _modified, true);
    if (typeof this.onSetModified === "function") {
      this.onSetModified();
    }
  }
};
var _serializable;
var PrintAnnotationStorage = class extends AnnotationStorage {
  constructor(parent) {
    super();
    __privateAdd(this, _serializable, void 0);
    const {
      map,
      hash,
      transfer
    } = parent.serializable;
    const clone = structuredClone(map, transfer ? {
      transfer
    } : null);
    __privateSet(this, _serializable, {
      map: clone,
      hash,
      transfer
    });
  }
  get print() {
    unreachable("Should not call PrintAnnotationStorage.print");
  }
  get serializable() {
    return __privateGet(this, _serializable);
  }
  get modifiedIds() {
    return shadow(this, "modifiedIds", {
      ids: /* @__PURE__ */ new Set(),
      hash: ""
    });
  }
};
_serializable = new WeakMap();
var _systemFonts;
var FontLoader = class {
  constructor({
    ownerDocument = globalThis.document,
    styleElement = null
  }) {
    __privateAdd(this, _systemFonts, /* @__PURE__ */ new Set());
    this._document = ownerDocument;
    this.nativeFontFaces = /* @__PURE__ */ new Set();
    this.styleElement = null;
    this.loadingRequests = [];
    this.loadTestFontId = 0;
  }
  addNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.add(nativeFontFace);
    this._document.fonts.add(nativeFontFace);
  }
  removeNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.delete(nativeFontFace);
    this._document.fonts.delete(nativeFontFace);
  }
  insertRule(rule) {
    if (!this.styleElement) {
      this.styleElement = this._document.createElement("style");
      this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
    }
    const styleSheet = this.styleElement.sheet;
    styleSheet.insertRule(rule, styleSheet.cssRules.length);
  }
  clear() {
    for (const nativeFontFace of this.nativeFontFaces) {
      this._document.fonts.delete(nativeFontFace);
    }
    this.nativeFontFaces.clear();
    __privateGet(this, _systemFonts).clear();
    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }
  async loadSystemFont({
    systemFontInfo: info2,
    disableFontFace,
    _inspectFont
  }) {
    if (!info2 || __privateGet(this, _systemFonts).has(info2.loadedName)) {
      return;
    }
    assert(!disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
    if (this.isFontLoadingAPISupported) {
      const {
        loadedName,
        src,
        style
      } = info2;
      const fontFace = new FontFace(loadedName, src, style);
      this.addNativeFontFace(fontFace);
      try {
        await fontFace.load();
        __privateGet(this, _systemFonts).add(loadedName);
        _inspectFont == null ? void 0 : _inspectFont(info2);
      } catch {
        warn(`Cannot load system font: ${info2.baseFontName}, installing it could help to improve PDF rendering.`);
        this.removeNativeFontFace(fontFace);
      }
      return;
    }
    unreachable("Not implemented: loadSystemFont without the Font Loading API.");
  }
  async bind(font) {
    if (font.attached || font.missingFile && !font.systemFontInfo) {
      return;
    }
    font.attached = true;
    if (font.systemFontInfo) {
      await this.loadSystemFont(font);
      return;
    }
    if (this.isFontLoadingAPISupported) {
      const nativeFontFace = font.createNativeFontFace();
      if (nativeFontFace) {
        this.addNativeFontFace(nativeFontFace);
        try {
          await nativeFontFace.loaded;
        } catch (ex) {
          warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
          font.disableFontFace = true;
          throw ex;
        }
      }
      return;
    }
    const rule = font.createFontFaceRule();
    if (rule) {
      this.insertRule(rule);
      if (this.isSyncFontLoadingSupported) {
        return;
      }
      await new Promise((resolve) => {
        const request = this._queueLoadingCallback(resolve);
        this._prepareFontLoadEvent(font, request);
      });
    }
  }
  get isFontLoadingAPISupported() {
    var _a2;
    const hasFonts = !!((_a2 = this._document) == null ? void 0 : _a2.fonts);
    return shadow(this, "isFontLoadingAPISupported", hasFonts);
  }
  get isSyncFontLoadingSupported() {
    return shadow(this, "isSyncFontLoadingSupported", isNodeJS || util_FeatureTest.platform.isFirefox);
  }
  _queueLoadingCallback(callback) {
    function completeRequest() {
      assert(!request.done, "completeRequest() cannot be called twice.");
      request.done = true;
      while (loadingRequests.length > 0 && loadingRequests[0].done) {
        const otherRequest = loadingRequests.shift();
        setTimeout(otherRequest.callback, 0);
      }
    }
    const {
      loadingRequests
    } = this;
    const request = {
      done: false,
      complete: completeRequest,
      callback
    };
    loadingRequests.push(request);
    return request;
  }
  get _loadTestFont() {
    const testFont = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
    return shadow(this, "_loadTestFont", testFont);
  }
  _prepareFontLoadEvent(font, request) {
    function int32(data2, offset) {
      return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
    }
    function spliceString(s, offset, remove, insert) {
      const chunk1 = s.substring(0, offset);
      const chunk2 = s.substring(offset + remove);
      return chunk1 + insert + chunk2;
    }
    let i, ii;
    const canvas = this._document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext("2d");
    let called = 0;
    function isFontReady(name, callback) {
      if (++called > 30) {
        warn("Load test font never loaded.");
        callback();
        return;
      }
      ctx.font = "30px " + name;
      ctx.fillText(".", 0, 20);
      const imageData = ctx.getImageData(0, 0, 1, 1);
      if (imageData.data[3] > 0) {
        callback();
        return;
      }
      setTimeout(isFontReady.bind(null, name, callback));
    }
    const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
    let data = this._loadTestFont;
    const COMMENT_OFFSET = 976;
    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
    const CFF_CHECKSUM_OFFSET = 16;
    const XXXX_VALUE = 1482184792;
    let checksum = int32(data, CFF_CHECKSUM_OFFSET);
    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
    }
    if (i < loadTestFontId.length) {
      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
    }
    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));
    const url = `url(data:font/opentype;base64,${btoa(data)});`;
    const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
    this.insertRule(rule);
    const div = this._document.createElement("div");
    div.style.visibility = "hidden";
    div.style.width = div.style.height = "10px";
    div.style.position = "absolute";
    div.style.top = div.style.left = "0px";
    for (const name of [font.loadedName, loadTestFontId]) {
      const span = this._document.createElement("span");
      span.textContent = "Hi";
      span.style.fontFamily = name;
      div.append(span);
    }
    this._document.body.append(div);
    isFontReady(loadTestFontId, () => {
      div.remove();
      request.complete();
    });
  }
};
_systemFonts = new WeakMap();
var _fontData;
var FontFaceObject = class {
  constructor(translatedData, inspectFont = null, extra, charProcOperatorList) {
    __privateAdd(this, _fontData, void 0);
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
    __privateSet(this, _fontData, translatedData);
    this._inspectFont = inspectFont;
    if (extra) {
      Object.assign(this, extra);
    }
    if (charProcOperatorList) {
      this.charProcOperatorList = charProcOperatorList;
    }
  }
  createNativeFontFace() {
    var _a2;
    if (!this.data || this.disableFontFace) {
      return null;
    }
    let nativeFontFace;
    if (!this.cssFontInfo) {
      nativeFontFace = new FontFace(this.loadedName, this.data, {});
    } else {
      const css = {
        weight: this.cssFontInfo.fontWeight
      };
      if (this.cssFontInfo.italicAngle) {
        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
      }
      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
    }
    (_a2 = this._inspectFont) == null ? void 0 : _a2.call(this, this);
    return nativeFontFace;
  }
  createFontFaceRule() {
    var _a2;
    if (!this.data || this.disableFontFace) {
      return null;
    }
    const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;
    let rule;
    if (!this.cssFontInfo) {
      rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
    } else {
      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
      if (this.cssFontInfo.italicAngle) {
        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
      }
      rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
    }
    (_a2 = this._inspectFont) == null ? void 0 : _a2.call(this, this, url);
    return rule;
  }
  getPathGenerator(objs, character) {
    if (this.compiledGlyphs[character] !== void 0) {
      return this.compiledGlyphs[character];
    }
    const objId = this.loadedName + "_path_" + character;
    let cmds;
    try {
      cmds = objs.get(objId);
    } catch (ex) {
      warn(`getPathGenerator - ignoring character: "${ex}".`);
    }
    const path = new Path2D(cmds || "");
    if (!this.fontExtraProperties) {
      objs.delete(objId);
    }
    return this.compiledGlyphs[character] = path;
  }
  get black() {
    return __privateGet(this, _fontData).black;
  }
  get bold() {
    return __privateGet(this, _fontData).bold;
  }
  get disableFontFace() {
    return __privateGet(this, _fontData).disableFontFace ?? false;
  }
  get fontExtraProperties() {
    return __privateGet(this, _fontData).fontExtraProperties ?? false;
  }
  get isInvalidPDFjsFont() {
    return __privateGet(this, _fontData).isInvalidPDFjsFont;
  }
  get isType3Font() {
    return __privateGet(this, _fontData).isType3Font;
  }
  get italic() {
    return __privateGet(this, _fontData).italic;
  }
  get missingFile() {
    return __privateGet(this, _fontData).missingFile;
  }
  get remeasure() {
    return __privateGet(this, _fontData).remeasure;
  }
  get vertical() {
    return __privateGet(this, _fontData).vertical;
  }
  get ascent() {
    return __privateGet(this, _fontData).ascent;
  }
  get defaultWidth() {
    return __privateGet(this, _fontData).defaultWidth;
  }
  get descent() {
    return __privateGet(this, _fontData).descent;
  }
  get bbox() {
    return __privateGet(this, _fontData).bbox;
  }
  get fontMatrix() {
    return __privateGet(this, _fontData).fontMatrix;
  }
  get fallbackName() {
    return __privateGet(this, _fontData).fallbackName;
  }
  get loadedName() {
    return __privateGet(this, _fontData).loadedName;
  }
  get mimetype() {
    return __privateGet(this, _fontData).mimetype;
  }
  get name() {
    return __privateGet(this, _fontData).name;
  }
  get data() {
    return __privateGet(this, _fontData).data;
  }
  clearData() {
    __privateGet(this, _fontData).clearData();
  }
  get cssFontInfo() {
    return __privateGet(this, _fontData).cssFontInfo;
  }
  get systemFontInfo() {
    return __privateGet(this, _fontData).systemFontInfo;
  }
  get defaultVMetrics() {
    return __privateGet(this, _fontData).defaultVMetrics;
  }
};
_fontData = new WeakMap();
function getUrlProp(val) {
  if (val instanceof URL) {
    return val.href;
  }
  if (typeof val === "string") {
    if (isNodeJS) {
      return val;
    }
    const url = URL.parse(val, window.location);
    if (url) {
      return url.href;
    }
  }
  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
}
function getDataProp(val) {
  if (isNodeJS && typeof Buffer !== "undefined" && val instanceof Buffer) {
    throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
  }
  if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {
    return val;
  }
  if (typeof val === "string") {
    return stringToBytes(val);
  }
  if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === "object" && !isNaN(val == null ? void 0 : val.length)) {
    return new Uint8Array(val);
  }
  throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
}
function getFactoryUrlProp(val) {
  if (typeof val !== "string") {
    return null;
  }
  if (val.endsWith("/")) {
    return val;
  }
  throw new Error(`Invalid factory url: "${val}" must include trailing slash.`);
}
var isRefProxy = (v) => typeof v === "object" && Number.isInteger(v == null ? void 0 : v.num) && v.num >= 0 && Number.isInteger(v == null ? void 0 : v.gen) && v.gen >= 0;
var isNameProxy = (v) => typeof v === "object" && typeof (v == null ? void 0 : v.name) === "string";
var isValidExplicitDest = _isValidExplicitDest.bind(null, isRefProxy, isNameProxy);
var _listeners, _deferred;
var LoopbackPort = class {
  constructor() {
    __privateAdd(this, _listeners, /* @__PURE__ */ new Map());
    __privateAdd(this, _deferred, Promise.resolve());
  }
  postMessage(obj, transfer) {
    const event = {
      data: structuredClone(obj, transfer ? {
        transfer
      } : null)
    };
    __privateGet(this, _deferred).then(() => {
      for (const [listener] of __privateGet(this, _listeners)) {
        listener.call(this, event);
      }
    });
  }
  addEventListener(name, listener, options = null) {
    let rmAbort = null;
    if ((options == null ? void 0 : options.signal) instanceof AbortSignal) {
      const {
        signal
      } = options;
      if (signal.aborted) {
        warn("LoopbackPort - cannot use an `aborted` signal.");
        return;
      }
      const onAbort = () => this.removeEventListener(name, listener);
      rmAbort = () => signal.removeEventListener("abort", onAbort);
      signal.addEventListener("abort", onAbort);
    }
    __privateGet(this, _listeners).set(listener, rmAbort);
  }
  removeEventListener(name, listener) {
    const rmAbort = __privateGet(this, _listeners).get(listener);
    rmAbort == null ? void 0 : rmAbort();
    __privateGet(this, _listeners).delete(listener);
  }
  terminate() {
    for (const [, rmAbort] of __privateGet(this, _listeners)) {
      rmAbort == null ? void 0 : rmAbort();
    }
    __privateGet(this, _listeners).clear();
  }
};
_listeners = new WeakMap();
_deferred = new WeakMap();
var CallbackKind = {
  DATA: 1,
  ERROR: 2
};
var StreamKind = {
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function onFn() {
}
function wrapReason(ex) {
  if (ex instanceof AbortException || ex instanceof InvalidPDFException || ex instanceof PasswordException || ex instanceof ResponseException || ex instanceof UnknownErrorException) {
    return ex;
  }
  if (!(ex instanceof Error || typeof ex === "object" && ex !== null)) {
    unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  }
  switch (ex.name) {
    case "AbortException":
      return new AbortException(ex.message);
    case "InvalidPDFException":
      return new InvalidPDFException(ex.message);
    case "PasswordException":
      return new PasswordException(ex.message, ex.code);
    case "ResponseException":
      return new ResponseException(ex.message, ex.status, ex.missing);
    case "UnknownErrorException":
      return new UnknownErrorException(ex.message, ex.details);
  }
  return new UnknownErrorException(ex.message, ex.toString());
}
var _messageAC, _onMessage, onMessage_fn, _createStreamSink, createStreamSink_fn, _processStreamMessage, processStreamMessage_fn, _deleteStreamController, deleteStreamController_fn;
var MessageHandler = class {
  constructor(sourceName, targetName, comObj) {
    __privateAdd(this, _onMessage);
    __privateAdd(this, _createStreamSink);
    __privateAdd(this, _processStreamMessage);
    __privateAdd(this, _deleteStreamController);
    __privateAdd(this, _messageAC, new AbortController());
    this.sourceName = sourceName;
    this.targetName = targetName;
    this.comObj = comObj;
    this.callbackId = 1;
    this.streamId = 1;
    this.streamSinks = /* @__PURE__ */ Object.create(null);
    this.streamControllers = /* @__PURE__ */ Object.create(null);
    this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
    this.actionHandler = /* @__PURE__ */ Object.create(null);
    comObj.addEventListener("message", __privateMethod(this, _onMessage, onMessage_fn).bind(this), {
      signal: __privateGet(this, _messageAC).signal
    });
  }
  on(actionName, handler) {
    const ah = this.actionHandler;
    if (ah[actionName]) {
      throw new Error(`There is already an actionName called "${actionName}"`);
    }
    ah[actionName] = handler;
  }
  send(actionName, data, transfers) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data
    }, transfers);
  }
  sendWithPromise(actionName, data, transfers) {
    const callbackId = this.callbackId++;
    const capability = Promise.withResolvers();
    this.callbackCapabilities[callbackId] = capability;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        callbackId,
        data
      }, transfers);
    } catch (ex) {
      capability.reject(ex);
    }
    return capability.promise;
  }
  sendWithStream(actionName, data, queueingStrategy, transfers) {
    const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
    return new ReadableStream({
      start: (controller) => {
        const startCapability = Promise.withResolvers();
        this.streamControllers[streamId] = {
          controller,
          startCall: startCapability,
          pullCall: null,
          cancelCall: null,
          isClosed: false
        };
        comObj.postMessage({
          sourceName,
          targetName,
          action: actionName,
          streamId,
          data,
          desiredSize: controller.desiredSize
        }, transfers);
        return startCapability.promise;
      },
      pull: (controller) => {
        const pullCapability = Promise.withResolvers();
        this.streamControllers[streamId].pullCall = pullCapability;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL,
          streamId,
          desiredSize: controller.desiredSize
        });
        return pullCapability.promise;
      },
      cancel: (reason) => {
        assert(reason instanceof Error, "cancel must have a valid reason");
        const cancelCapability = Promise.withResolvers();
        this.streamControllers[streamId].cancelCall = cancelCapability;
        this.streamControllers[streamId].isClosed = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL,
          streamId,
          reason: wrapReason(reason)
        });
        return cancelCapability.promise;
      }
    }, queueingStrategy);
  }
  destroy() {
    var _a2;
    (_a2 = __privateGet(this, _messageAC)) == null ? void 0 : _a2.abort();
    __privateSet(this, _messageAC, null);
  }
};
_messageAC = new WeakMap();
_onMessage = new WeakSet();
onMessage_fn = function({
  data
}) {
  if (data.targetName !== this.sourceName) {
    return;
  }
  if (data.stream) {
    __privateMethod(this, _processStreamMessage, processStreamMessage_fn).call(this, data);
    return;
  }
  if (data.callback) {
    const callbackId = data.callbackId;
    const capability = this.callbackCapabilities[callbackId];
    if (!capability) {
      throw new Error(`Cannot resolve callback ${callbackId}`);
    }
    delete this.callbackCapabilities[callbackId];
    if (data.callback === CallbackKind.DATA) {
      capability.resolve(data.data);
    } else if (data.callback === CallbackKind.ERROR) {
      capability.reject(wrapReason(data.reason));
    } else {
      throw new Error("Unexpected callback case");
    }
    return;
  }
  const action = this.actionHandler[data.action];
  if (!action) {
    throw new Error(`Unknown action from worker: ${data.action}`);
  }
  if (data.callbackId) {
    const sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
    Promise.try(action, data.data).then(function(result) {
      comObj.postMessage({
        sourceName,
        targetName,
        callback: CallbackKind.DATA,
        callbackId: data.callbackId,
        data: result
      });
    }, function(reason) {
      comObj.postMessage({
        sourceName,
        targetName,
        callback: CallbackKind.ERROR,
        callbackId: data.callbackId,
        reason: wrapReason(reason)
      });
    });
    return;
  }
  if (data.streamId) {
    __privateMethod(this, _createStreamSink, createStreamSink_fn).call(this, data);
    return;
  }
  action(data.data);
};
_createStreamSink = new WeakSet();
createStreamSink_fn = function(data) {
  const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
  const self = this, action = this.actionHandler[data.action];
  const streamSink = {
    enqueue(chunk, size = 1, transfers) {
      if (this.isCancelled) {
        return;
      }
      const lastDesiredSize = this.desiredSize;
      this.desiredSize -= size;
      if (lastDesiredSize > 0 && this.desiredSize <= 0) {
        this.sinkCapability = Promise.withResolvers();
        this.ready = this.sinkCapability.promise;
      }
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.ENQUEUE,
        streamId,
        chunk
      }, transfers);
    },
    close() {
      if (this.isCancelled) {
        return;
      }
      this.isCancelled = true;
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.CLOSE,
        streamId
      });
      delete self.streamSinks[streamId];
    },
    error(reason) {
      assert(reason instanceof Error, "error must have a valid reason");
      if (this.isCancelled) {
        return;
      }
      this.isCancelled = true;
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.ERROR,
        streamId,
        reason: wrapReason(reason)
      });
    },
    sinkCapability: Promise.withResolvers(),
    onPull: null,
    onCancel: null,
    isCancelled: false,
    desiredSize: data.desiredSize,
    ready: null
  };
  streamSink.sinkCapability.resolve();
  streamSink.ready = streamSink.sinkCapability.promise;
  this.streamSinks[streamId] = streamSink;
  Promise.try(action, data.data, streamSink).then(function() {
    comObj.postMessage({
      sourceName,
      targetName,
      stream: StreamKind.START_COMPLETE,
      streamId,
      success: true
    });
  }, function(reason) {
    comObj.postMessage({
      sourceName,
      targetName,
      stream: StreamKind.START_COMPLETE,
      streamId,
      reason: wrapReason(reason)
    });
  });
};
_processStreamMessage = new WeakSet();
processStreamMessage_fn = function(data) {
  const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
  const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
  switch (data.stream) {
    case StreamKind.START_COMPLETE:
      if (data.success) {
        streamController.startCall.resolve();
      } else {
        streamController.startCall.reject(wrapReason(data.reason));
      }
      break;
    case StreamKind.PULL_COMPLETE:
      if (data.success) {
        streamController.pullCall.resolve();
      } else {
        streamController.pullCall.reject(wrapReason(data.reason));
      }
      break;
    case StreamKind.PULL:
      if (!streamSink) {
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL_COMPLETE,
          streamId,
          success: true
        });
        break;
      }
      if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
        streamSink.sinkCapability.resolve();
      }
      streamSink.desiredSize = data.desiredSize;
      Promise.try(streamSink.onPull || onFn).then(function() {
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL_COMPLETE,
          streamId,
          success: true
        });
      }, function(reason) {
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL_COMPLETE,
          streamId,
          reason: wrapReason(reason)
        });
      });
      break;
    case StreamKind.ENQUEUE:
      assert(streamController, "enqueue should have stream controller");
      if (streamController.isClosed) {
        break;
      }
      streamController.controller.enqueue(data.chunk);
      break;
    case StreamKind.CLOSE:
      assert(streamController, "close should have stream controller");
      if (streamController.isClosed) {
        break;
      }
      streamController.isClosed = true;
      streamController.controller.close();
      __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
      break;
    case StreamKind.ERROR:
      assert(streamController, "error should have stream controller");
      streamController.controller.error(wrapReason(data.reason));
      __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
      break;
    case StreamKind.CANCEL_COMPLETE:
      if (data.success) {
        streamController.cancelCall.resolve();
      } else {
        streamController.cancelCall.reject(wrapReason(data.reason));
      }
      __privateMethod(this, _deleteStreamController, deleteStreamController_fn).call(this, streamController, streamId);
      break;
    case StreamKind.CANCEL:
      if (!streamSink) {
        break;
      }
      const dataReason = wrapReason(data.reason);
      Promise.try(streamSink.onCancel || onFn, dataReason).then(function() {
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL_COMPLETE,
          streamId,
          success: true
        });
      }, function(reason) {
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL_COMPLETE,
          streamId,
          reason: wrapReason(reason)
        });
      });
      streamSink.sinkCapability.reject(dataReason);
      streamSink.isCancelled = true;
      delete this.streamSinks[streamId];
      break;
    default:
      throw new Error("Unexpected stream case");
  }
};
_deleteStreamController = new WeakSet();
deleteStreamController_fn = async function(streamController, streamId) {
  var _a2, _b, _c;
  await Promise.allSettled([(_a2 = streamController.startCall) == null ? void 0 : _a2.promise, (_b = streamController.pullCall) == null ? void 0 : _b.promise, (_c = streamController.cancelCall) == null ? void 0 : _c.promise]);
  delete this.streamControllers[streamId];
};
var _enableHWA;
var BaseCanvasFactory = class {
  constructor({
    enableHWA = false
  }) {
    __privateAdd(this, _enableHWA, false);
    __privateSet(this, _enableHWA, enableHWA);
  }
  create(width, height) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }
    const canvas = this._createCanvas(width, height);
    return {
      canvas,
      context: canvas.getContext("2d", {
        willReadFrequently: !__privateGet(this, _enableHWA)
      })
    };
  }
  reset(canvasAndContext, width, height) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }
    canvasAndContext.canvas.width = width;
    canvasAndContext.canvas.height = height;
  }
  destroy(canvasAndContext) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }
    canvasAndContext.canvas.width = 0;
    canvasAndContext.canvas.height = 0;
    canvasAndContext.canvas = null;
    canvasAndContext.context = null;
  }
  _createCanvas(width, height) {
    unreachable("Abstract method `_createCanvas` called.");
  }
};
_enableHWA = new WeakMap();
var DOMCanvasFactory = class extends BaseCanvasFactory {
  constructor({
    ownerDocument = globalThis.document,
    enableHWA = false
  }) {
    super({
      enableHWA
    });
    this._document = ownerDocument;
  }
  _createCanvas(width, height) {
    const canvas = this._document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }
};
var BaseCMapReaderFactory = class {
  constructor({
    baseUrl = null,
    isCompressed = true
  }) {
    this.baseUrl = baseUrl;
    this.isCompressed = isCompressed;
  }
  async fetch({
    name
  }) {
    if (!this.baseUrl) {
      throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
    }
    if (!name) {
      throw new Error("CMap name must be specified.");
    }
    const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
    return this._fetch(url).then((cMapData) => ({
      cMapData,
      isCompressed: this.isCompressed
    })).catch((reason) => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
    });
  }
  async _fetch(url) {
    unreachable("Abstract method `_fetch` called.");
  }
};
var DOMCMapReaderFactory = class extends BaseCMapReaderFactory {
  async _fetch(url) {
    const data = await fetchData(url, this.isCompressed ? "arraybuffer" : "text");
    return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);
  }
};
var BaseFilterFactory = class {
  addFilter(maps) {
    return "none";
  }
  addHCMFilter(fgColor, bgColor) {
    return "none";
  }
  addAlphaFilter(map) {
    return "none";
  }
  addLuminosityFilter(map) {
    return "none";
  }
  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
    return "none";
  }
  destroy(keepHCM = false) {
  }
};
var _baseUrl, __cache, __defs, _docId, _document, __hcmCache, _id3, _cache2, cache_get, _hcmCache, hcmCache_get, _defs, defs_get, _createTables, createTables_fn, _createUrl, createUrl_fn, _addLuminosityConversion, addLuminosityConversion_fn, _addGrayConversion, addGrayConversion_fn, _createFilter, createFilter_fn, _appendFeFunc, appendFeFunc_fn, _addTransferMapConversion, addTransferMapConversion_fn, _addTransferMapAlphaConversion, addTransferMapAlphaConversion_fn, _getRGB, getRGB_fn;
var DOMFilterFactory = class extends BaseFilterFactory {
  constructor({
    docId,
    ownerDocument = globalThis.document
  }) {
    super();
    __privateAdd(this, _cache2);
    __privateAdd(this, _hcmCache);
    __privateAdd(this, _defs);
    __privateAdd(this, _createTables);
    __privateAdd(this, _createUrl);
    __privateAdd(this, _addLuminosityConversion);
    __privateAdd(this, _addGrayConversion);
    __privateAdd(this, _createFilter);
    __privateAdd(this, _appendFeFunc);
    __privateAdd(this, _addTransferMapConversion);
    __privateAdd(this, _addTransferMapAlphaConversion);
    __privateAdd(this, _getRGB);
    __privateAdd(this, _baseUrl, void 0);
    __privateAdd(this, __cache, void 0);
    __privateAdd(this, __defs, void 0);
    __privateAdd(this, _docId, void 0);
    __privateAdd(this, _document, void 0);
    __privateAdd(this, __hcmCache, void 0);
    __privateAdd(this, _id3, 0);
    __privateSet(this, _docId, docId);
    __privateSet(this, _document, ownerDocument);
  }
  addFilter(maps) {
    if (!maps) {
      return "none";
    }
    let value = __privateGet(this, _cache2, cache_get).get(maps);
    if (value) {
      return value;
    }
    const [tableR, tableG, tableB] = __privateMethod(this, _createTables, createTables_fn).call(this, maps);
    const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;
    value = __privateGet(this, _cache2, cache_get).get(key);
    if (value) {
      __privateGet(this, _cache2, cache_get).set(maps, value);
      return value;
    }
    const id = `g_${__privateGet(this, _docId)}_transfer_map_${__privateWrapper(this, _id3)._++}`;
    const url = __privateMethod(this, _createUrl, createUrl_fn).call(this, id);
    __privateGet(this, _cache2, cache_get).set(maps, url);
    __privateGet(this, _cache2, cache_get).set(key, url);
    const filter = __privateMethod(this, _createFilter, createFilter_fn).call(this, id);
    __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, tableR, tableG, tableB, filter);
    return url;
  }
  addHCMFilter(fgColor, bgColor) {
    var _a2;
    const key = `${fgColor}-${bgColor}`;
    const filterName = "base";
    let info2 = __privateGet(this, _hcmCache, hcmCache_get).get(filterName);
    if ((info2 == null ? void 0 : info2.key) === key) {
      return info2.url;
    }
    if (info2) {
      (_a2 = info2.filter) == null ? void 0 : _a2.remove();
      info2.key = key;
      info2.url = "none";
      info2.filter = null;
    } else {
      info2 = {
        key,
        url: "none",
        filter: null
      };
      __privateGet(this, _hcmCache, hcmCache_get).set(filterName, info2);
    }
    if (!fgColor || !bgColor) {
      return info2.url;
    }
    const fgRGB = __privateMethod(this, _getRGB, getRGB_fn).call(this, fgColor);
    fgColor = Util.makeHexColor(...fgRGB);
    const bgRGB = __privateMethod(this, _getRGB, getRGB_fn).call(this, bgColor);
    bgColor = Util.makeHexColor(...bgRGB);
    __privateGet(this, _defs, defs_get).style.color = "";
    if (fgColor === "#000000" && bgColor === "#ffffff" || fgColor === bgColor) {
      return info2.url;
    }
    const map = new Array(256);
    for (let i = 0; i <= 255; i++) {
      const x = i / 255;
      map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
    }
    const table = map.join(",");
    const id = `g_${__privateGet(this, _docId)}_hcm_filter`;
    const filter = info2.filter = __privateMethod(this, _createFilter, createFilter_fn).call(this, id);
    __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, table, table, table, filter);
    __privateMethod(this, _addGrayConversion, addGrayConversion_fn).call(this, filter);
    const getSteps = (c, n) => {
      const start = fgRGB[c] / 255;
      const end = bgRGB[c] / 255;
      const arr = new Array(n + 1);
      for (let i = 0; i <= n; i++) {
        arr[i] = start + i / n * (end - start);
      }
      return arr.join(",");
    };
    __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);
    info2.url = __privateMethod(this, _createUrl, createUrl_fn).call(this, id);
    return info2.url;
  }
  addAlphaFilter(map) {
    let value = __privateGet(this, _cache2, cache_get).get(map);
    if (value) {
      return value;
    }
    const [tableA] = __privateMethod(this, _createTables, createTables_fn).call(this, [map]);
    const key = `alpha_${tableA}`;
    value = __privateGet(this, _cache2, cache_get).get(key);
    if (value) {
      __privateGet(this, _cache2, cache_get).set(map, value);
      return value;
    }
    const id = `g_${__privateGet(this, _docId)}_alpha_map_${__privateWrapper(this, _id3)._++}`;
    const url = __privateMethod(this, _createUrl, createUrl_fn).call(this, id);
    __privateGet(this, _cache2, cache_get).set(map, url);
    __privateGet(this, _cache2, cache_get).set(key, url);
    const filter = __privateMethod(this, _createFilter, createFilter_fn).call(this, id);
    __privateMethod(this, _addTransferMapAlphaConversion, addTransferMapAlphaConversion_fn).call(this, tableA, filter);
    return url;
  }
  addLuminosityFilter(map) {
    let value = __privateGet(this, _cache2, cache_get).get(map || "luminosity");
    if (value) {
      return value;
    }
    let tableA, key;
    if (map) {
      [tableA] = __privateMethod(this, _createTables, createTables_fn).call(this, [map]);
      key = `luminosity_${tableA}`;
    } else {
      key = "luminosity";
    }
    value = __privateGet(this, _cache2, cache_get).get(key);
    if (value) {
      __privateGet(this, _cache2, cache_get).set(map, value);
      return value;
    }
    const id = `g_${__privateGet(this, _docId)}_luminosity_map_${__privateWrapper(this, _id3)._++}`;
    const url = __privateMethod(this, _createUrl, createUrl_fn).call(this, id);
    __privateGet(this, _cache2, cache_get).set(map, url);
    __privateGet(this, _cache2, cache_get).set(key, url);
    const filter = __privateMethod(this, _createFilter, createFilter_fn).call(this, id);
    __privateMethod(this, _addLuminosityConversion, addLuminosityConversion_fn).call(this, filter);
    if (map) {
      __privateMethod(this, _addTransferMapAlphaConversion, addTransferMapAlphaConversion_fn).call(this, tableA, filter);
    }
    return url;
  }
  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
    var _a2;
    const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;
    let info2 = __privateGet(this, _hcmCache, hcmCache_get).get(filterName);
    if ((info2 == null ? void 0 : info2.key) === key) {
      return info2.url;
    }
    if (info2) {
      (_a2 = info2.filter) == null ? void 0 : _a2.remove();
      info2.key = key;
      info2.url = "none";
      info2.filter = null;
    } else {
      info2 = {
        key,
        url: "none",
        filter: null
      };
      __privateGet(this, _hcmCache, hcmCache_get).set(filterName, info2);
    }
    if (!fgColor || !bgColor) {
      return info2.url;
    }
    const [fgRGB, bgRGB] = [fgColor, bgColor].map(__privateMethod(this, _getRGB, getRGB_fn).bind(this));
    let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);
    let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);
    let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(__privateMethod(this, _getRGB, getRGB_fn).bind(this));
    if (bgGray < fgGray) {
      [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];
    }
    __privateGet(this, _defs, defs_get).style.color = "";
    const getSteps = (fg, bg, n) => {
      const arr = new Array(256);
      const step = (bgGray - fgGray) / n;
      const newStart = fg / 255;
      const newStep = (bg - fg) / (255 * n);
      let prev = 0;
      for (let i = 0; i <= n; i++) {
        const k = Math.round(fgGray + i * step);
        const value = newStart + i * newStep;
        for (let j = prev; j <= k; j++) {
          arr[j] = value;
        }
        prev = k + 1;
      }
      for (let i = prev; i < 256; i++) {
        arr[i] = arr[prev - 1];
      }
      return arr.join(",");
    };
    const id = `g_${__privateGet(this, _docId)}_hcm_${filterName}_filter`;
    const filter = info2.filter = __privateMethod(this, _createFilter, createFilter_fn).call(this, id);
    __privateMethod(this, _addGrayConversion, addGrayConversion_fn).call(this, filter);
    __privateMethod(this, _addTransferMapConversion, addTransferMapConversion_fn).call(this, getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);
    info2.url = __privateMethod(this, _createUrl, createUrl_fn).call(this, id);
    return info2.url;
  }
  destroy(keepHCM = false) {
    var _a2, _b, _c, _d;
    if (keepHCM && ((_a2 = __privateGet(this, __hcmCache)) == null ? void 0 : _a2.size)) {
      return;
    }
    (_b = __privateGet(this, __defs)) == null ? void 0 : _b.parentNode.parentNode.remove();
    __privateSet(this, __defs, null);
    (_c = __privateGet(this, __cache)) == null ? void 0 : _c.clear();
    __privateSet(this, __cache, null);
    (_d = __privateGet(this, __hcmCache)) == null ? void 0 : _d.clear();
    __privateSet(this, __hcmCache, null);
    __privateSet(this, _id3, 0);
  }
};
_baseUrl = new WeakMap();
__cache = new WeakMap();
__defs = new WeakMap();
_docId = new WeakMap();
_document = new WeakMap();
__hcmCache = new WeakMap();
_id3 = new WeakMap();
_cache2 = new WeakSet();
cache_get = function() {
  return __privateGet(this, __cache) || __privateSet(this, __cache, /* @__PURE__ */ new Map());
};
_hcmCache = new WeakSet();
hcmCache_get = function() {
  return __privateGet(this, __hcmCache) || __privateSet(this, __hcmCache, /* @__PURE__ */ new Map());
};
_defs = new WeakSet();
defs_get = function() {
  if (!__privateGet(this, __defs)) {
    const div = __privateGet(this, _document).createElement("div");
    const {
      style
    } = div;
    style.visibility = "hidden";
    style.contain = "strict";
    style.width = style.height = 0;
    style.position = "absolute";
    style.top = style.left = 0;
    style.zIndex = -1;
    const svg = __privateGet(this, _document).createElementNS(SVG_NS, "svg");
    svg.setAttribute("width", 0);
    svg.setAttribute("height", 0);
    __privateSet(this, __defs, __privateGet(this, _document).createElementNS(SVG_NS, "defs"));
    div.append(svg);
    svg.append(__privateGet(this, __defs));
    __privateGet(this, _document).body.append(div);
  }
  return __privateGet(this, __defs);
};
_createTables = new WeakSet();
createTables_fn = function(maps) {
  if (maps.length === 1) {
    const mapR2 = maps[0];
    const buffer = new Array(256);
    for (let i = 0; i < 256; i++) {
      buffer[i] = mapR2[i] / 255;
    }
    const table = buffer.join(",");
    return [table, table, table];
  }
  const [mapR, mapG, mapB] = maps;
  const bufferR = new Array(256);
  const bufferG = new Array(256);
  const bufferB = new Array(256);
  for (let i = 0; i < 256; i++) {
    bufferR[i] = mapR[i] / 255;
    bufferG[i] = mapG[i] / 255;
    bufferB[i] = mapB[i] / 255;
  }
  return [bufferR.join(","), bufferG.join(","), bufferB.join(",")];
};
_createUrl = new WeakSet();
createUrl_fn = function(id) {
  if (__privateGet(this, _baseUrl) === void 0) {
    __privateSet(this, _baseUrl, "");
    const url = __privateGet(this, _document).URL;
    if (url !== __privateGet(this, _document).baseURI) {
      if (isDataScheme(url)) {
        warn('#createUrl: ignore "data:"-URL for performance reasons.');
      } else {
        __privateSet(this, _baseUrl, updateUrlHash(url, ""));
      }
    }
  }
  return `url(${__privateGet(this, _baseUrl)}#${id})`;
};
_addLuminosityConversion = new WeakSet();
addLuminosityConversion_fn = function(filter) {
  const feColorMatrix = __privateGet(this, _document).createElementNS(SVG_NS, "feColorMatrix");
  feColorMatrix.setAttribute("type", "matrix");
  feColorMatrix.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0");
  filter.append(feColorMatrix);
};
_addGrayConversion = new WeakSet();
addGrayConversion_fn = function(filter) {
  const feColorMatrix = __privateGet(this, _document).createElementNS(SVG_NS, "feColorMatrix");
  feColorMatrix.setAttribute("type", "matrix");
  feColorMatrix.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
  filter.append(feColorMatrix);
};
_createFilter = new WeakSet();
createFilter_fn = function(id) {
  const filter = __privateGet(this, _document).createElementNS(SVG_NS, "filter");
  filter.setAttribute("color-interpolation-filters", "sRGB");
  filter.setAttribute("id", id);
  __privateGet(this, _defs, defs_get).append(filter);
  return filter;
};
_appendFeFunc = new WeakSet();
appendFeFunc_fn = function(feComponentTransfer, func, table) {
  const feFunc = __privateGet(this, _document).createElementNS(SVG_NS, func);
  feFunc.setAttribute("type", "discrete");
  feFunc.setAttribute("tableValues", table);
  feComponentTransfer.append(feFunc);
};
_addTransferMapConversion = new WeakSet();
addTransferMapConversion_fn = function(rTable, gTable, bTable, filter) {
  const feComponentTransfer = __privateGet(this, _document).createElementNS(SVG_NS, "feComponentTransfer");
  filter.append(feComponentTransfer);
  __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncR", rTable);
  __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncG", gTable);
  __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncB", bTable);
};
_addTransferMapAlphaConversion = new WeakSet();
addTransferMapAlphaConversion_fn = function(aTable, filter) {
  const feComponentTransfer = __privateGet(this, _document).createElementNS(SVG_NS, "feComponentTransfer");
  filter.append(feComponentTransfer);
  __privateMethod(this, _appendFeFunc, appendFeFunc_fn).call(this, feComponentTransfer, "feFuncA", aTable);
};
_getRGB = new WeakSet();
getRGB_fn = function(color) {
  __privateGet(this, _defs, defs_get).style.color = color;
  return getRGB(getComputedStyle(__privateGet(this, _defs, defs_get)).getPropertyValue("color"));
};
var BaseStandardFontDataFactory = class {
  constructor({
    baseUrl = null
  }) {
    this.baseUrl = baseUrl;
  }
  async fetch({
    filename
  }) {
    if (!this.baseUrl) {
      throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
    }
    if (!filename) {
      throw new Error("Font filename must be specified.");
    }
    const url = `${this.baseUrl}${filename}`;
    return this._fetch(url).catch((reason) => {
      throw new Error(`Unable to load font data at: ${url}`);
    });
  }
  async _fetch(url) {
    unreachable("Abstract method `_fetch` called.");
  }
};
var DOMStandardFontDataFactory = class extends BaseStandardFontDataFactory {
  async _fetch(url) {
    const data = await fetchData(url, "arraybuffer");
    return new Uint8Array(data);
  }
};
var BaseWasmFactory = class {
  constructor({
    baseUrl = null
  }) {
    this.baseUrl = baseUrl;
  }
  async fetch({
    filename
  }) {
    if (!this.baseUrl) {
      throw new Error("Ensure that the `wasmUrl` API parameter is provided.");
    }
    if (!filename) {
      throw new Error("Wasm filename must be specified.");
    }
    const url = `${this.baseUrl}${filename}`;
    return this._fetch(url).catch((reason) => {
      throw new Error(`Unable to load wasm data at: ${url}`);
    });
  }
  async _fetch(url) {
    unreachable("Abstract method `_fetch` called.");
  }
};
var DOMWasmFactory = class extends BaseWasmFactory {
  async _fetch(url) {
    const data = await fetchData(url, "arraybuffer");
    return new Uint8Array(data);
  }
};
if (isNodeJS) {
  warn("Please use the `legacy` build in Node.js environments.");
}
async function node_utils_fetchData(url) {
  const fs = process.getBuiltinModule("fs");
  const data = await fs.promises.readFile(url);
  return new Uint8Array(data);
}
var NodeFilterFactory = class extends BaseFilterFactory {
};
var NodeCanvasFactory = class extends BaseCanvasFactory {
  _createCanvas(width, height) {
    const require2 = process.getBuiltinModule("module").createRequire(import.meta.url);
    const canvas = require2("@napi-rs/canvas");
    return canvas.createCanvas(width, height);
  }
};
var NodeCMapReaderFactory = class extends BaseCMapReaderFactory {
  async _fetch(url) {
    return node_utils_fetchData(url);
  }
};
var NodeStandardFontDataFactory = class extends BaseStandardFontDataFactory {
  async _fetch(url) {
    return node_utils_fetchData(url);
  }
};
var NodeWasmFactory = class extends BaseWasmFactory {
  async _fetch(url) {
    return node_utils_fetchData(url);
  }
};
var FORCED_DEPENDENCY_LABEL = "__forcedDependency";
var {
  floor,
  ceil
} = Math;
function expandBBox(array, index, minX, minY, maxX, maxY) {
  array[index * 4 + 0] = Math.min(array[index * 4 + 0], minX);
  array[index * 4 + 1] = Math.min(array[index * 4 + 1], minY);
  array[index * 4 + 2] = Math.max(array[index * 4 + 2], maxX);
  array[index * 4 + 3] = Math.max(array[index * 4 + 3], maxY);
}
var EMPTY_BBOX = new Uint32Array(new Uint8Array([255, 255, 0, 0]).buffer)[0];
var _bboxes, _coords;
var BBoxReader = class {
  constructor(bboxes, coords) {
    __privateAdd(this, _bboxes, void 0);
    __privateAdd(this, _coords, void 0);
    __privateSet(this, _bboxes, bboxes);
    __privateSet(this, _coords, coords);
  }
  get length() {
    return __privateGet(this, _bboxes).length;
  }
  isEmpty(i) {
    return __privateGet(this, _bboxes)[i] === EMPTY_BBOX;
  }
  minX(i) {
    return __privateGet(this, _coords)[i * 4 + 0] / 256;
  }
  minY(i) {
    return __privateGet(this, _coords)[i * 4 + 1] / 256;
  }
  maxX(i) {
    return (__privateGet(this, _coords)[i * 4 + 2] + 1) / 256;
  }
  maxY(i) {
    return (__privateGet(this, _coords)[i * 4 + 3] + 1) / 256;
  }
};
_bboxes = new WeakMap();
_coords = new WeakMap();
var ensureDebugMetadata = (map, key) => {
  if (!map) {
    return void 0;
  }
  let value = map.get(key);
  if (!value) {
    value = {
      dependencies: /* @__PURE__ */ new Set(),
      isRenderingOperation: false
    };
    map.set(key, value);
  }
  return value;
};
var _simple, _incremental, _namedDependencies, _savesStack, _markedContentStack, _baseTransformStack, _clipBox, _pendingBBox, _pendingBBoxIdx, _pendingDependencies, _operations, _fontBBoxTrustworthy, _canvasWidth, _canvasHeight, _bboxesCoords, _bboxes2, _debugMetadata, _initializeBBoxes, initializeBBoxes_fn;
var CanvasDependencyTracker = class {
  constructor(canvas, operationsCount, recordDebugMetadata = false) {
    __privateAdd(this, _initializeBBoxes);
    __privateAdd(this, _simple, {
      __proto__: null
    });
    __privateAdd(this, _incremental, {
      __proto__: null,
      transform: [],
      moveText: [],
      sameLineText: [],
      [FORCED_DEPENDENCY_LABEL]: []
    });
    __privateAdd(this, _namedDependencies, /* @__PURE__ */ new Map());
    __privateAdd(this, _savesStack, []);
    __privateAdd(this, _markedContentStack, []);
    __privateAdd(this, _baseTransformStack, [[1, 0, 0, 1, 0, 0]]);
    __privateAdd(this, _clipBox, [-Infinity, -Infinity, Infinity, Infinity]);
    __privateAdd(this, _pendingBBox, new Float64Array([Infinity, Infinity, -Infinity, -Infinity]));
    __privateAdd(this, _pendingBBoxIdx, -1);
    __privateAdd(this, _pendingDependencies, /* @__PURE__ */ new Set());
    __privateAdd(this, _operations, /* @__PURE__ */ new Map());
    __privateAdd(this, _fontBBoxTrustworthy, /* @__PURE__ */ new Map());
    __privateAdd(this, _canvasWidth, void 0);
    __privateAdd(this, _canvasHeight, void 0);
    __privateAdd(this, _bboxesCoords, void 0);
    __privateAdd(this, _bboxes2, void 0);
    __privateAdd(this, _debugMetadata, void 0);
    __privateSet(this, _canvasWidth, canvas.width);
    __privateSet(this, _canvasHeight, canvas.height);
    __privateMethod(this, _initializeBBoxes, initializeBBoxes_fn).call(this, operationsCount);
    if (recordDebugMetadata) {
      __privateSet(this, _debugMetadata, /* @__PURE__ */ new Map());
    }
  }
  growOperationsCount(operationsCount) {
    if (operationsCount >= __privateGet(this, _bboxes2).length) {
      __privateMethod(this, _initializeBBoxes, initializeBBoxes_fn).call(this, operationsCount, __privateGet(this, _bboxes2));
    }
  }
  save(opIdx) {
    __privateSet(this, _simple, {
      __proto__: __privateGet(this, _simple)
    });
    __privateSet(this, _incremental, {
      __proto__: __privateGet(this, _incremental),
      transform: {
        __proto__: __privateGet(this, _incremental).transform
      },
      moveText: {
        __proto__: __privateGet(this, _incremental).moveText
      },
      sameLineText: {
        __proto__: __privateGet(this, _incremental).sameLineText
      },
      [FORCED_DEPENDENCY_LABEL]: {
        __proto__: __privateGet(this, _incremental)[FORCED_DEPENDENCY_LABEL]
      }
    });
    __privateSet(this, _clipBox, {
      __proto__: __privateGet(this, _clipBox)
    });
    __privateGet(this, _savesStack).push(opIdx);
    return this;
  }
  restore(opIdx) {
    var _a2;
    const previous = Object.getPrototypeOf(__privateGet(this, _simple));
    if (previous === null) {
      return this;
    }
    __privateSet(this, _simple, previous);
    __privateSet(this, _incremental, Object.getPrototypeOf(__privateGet(this, _incremental)));
    __privateSet(this, _clipBox, Object.getPrototypeOf(__privateGet(this, _clipBox)));
    const lastSave = __privateGet(this, _savesStack).pop();
    if (lastSave !== void 0) {
      (_a2 = ensureDebugMetadata(__privateGet(this, _debugMetadata), opIdx)) == null ? void 0 : _a2.dependencies.add(lastSave);
      __privateGet(this, _bboxes2)[opIdx] = __privateGet(this, _bboxes2)[lastSave];
    }
    return this;
  }
  recordOpenMarker(idx) {
    __privateGet(this, _savesStack).push(idx);
    return this;
  }
  getOpenMarker() {
    if (__privateGet(this, _savesStack).length === 0) {
      return null;
    }
    return __privateGet(this, _savesStack).at(-1);
  }
  recordCloseMarker(opIdx) {
    var _a2;
    const lastSave = __privateGet(this, _savesStack).pop();
    if (lastSave !== void 0) {
      (_a2 = ensureDebugMetadata(__privateGet(this, _debugMetadata), opIdx)) == null ? void 0 : _a2.dependencies.add(lastSave);
      __privateGet(this, _bboxes2)[opIdx] = __privateGet(this, _bboxes2)[lastSave];
    }
    return this;
  }
  beginMarkedContent(opIdx) {
    __privateGet(this, _markedContentStack).push(opIdx);
    return this;
  }
  endMarkedContent(opIdx) {
    var _a2;
    const lastSave = __privateGet(this, _markedContentStack).pop();
    if (lastSave !== void 0) {
      (_a2 = ensureDebugMetadata(__privateGet(this, _debugMetadata), opIdx)) == null ? void 0 : _a2.dependencies.add(lastSave);
      __privateGet(this, _bboxes2)[opIdx] = __privateGet(this, _bboxes2)[lastSave];
    }
    return this;
  }
  pushBaseTransform(ctx) {
    __privateGet(this, _baseTransformStack).push(Util.multiplyByDOMMatrix(__privateGet(this, _baseTransformStack).at(-1), ctx.getTransform()));
    return this;
  }
  popBaseTransform() {
    if (__privateGet(this, _baseTransformStack).length > 1) {
      __privateGet(this, _baseTransformStack).pop();
    }
    return this;
  }
  recordSimpleData(name, idx) {
    __privateGet(this, _simple)[name] = idx;
    return this;
  }
  recordIncrementalData(name, idx) {
    __privateGet(this, _incremental)[name].push(idx);
    return this;
  }
  resetIncrementalData(name, idx) {
    __privateGet(this, _incremental)[name].length = 0;
    return this;
  }
  recordNamedData(name, idx) {
    __privateGet(this, _namedDependencies).set(name, idx);
    return this;
  }
  recordSimpleDataFromNamed(name, depName, fallbackIdx) {
    __privateGet(this, _simple)[name] = __privateGet(this, _namedDependencies).get(depName) ?? fallbackIdx;
  }
  recordFutureForcedDependency(name, idx) {
    this.recordIncrementalData(FORCED_DEPENDENCY_LABEL, idx);
    return this;
  }
  inheritSimpleDataAsFutureForcedDependencies(names) {
    for (const name of names) {
      if (name in __privateGet(this, _simple)) {
        this.recordFutureForcedDependency(name, __privateGet(this, _simple)[name]);
      }
    }
    return this;
  }
  inheritPendingDependenciesAsFutureForcedDependencies() {
    for (const dep of __privateGet(this, _pendingDependencies)) {
      this.recordFutureForcedDependency(FORCED_DEPENDENCY_LABEL, dep);
    }
    return this;
  }
  resetBBox(idx) {
    if (__privateGet(this, _pendingBBoxIdx) !== idx) {
      __privateSet(this, _pendingBBoxIdx, idx);
      __privateGet(this, _pendingBBox)[0] = Infinity;
      __privateGet(this, _pendingBBox)[1] = Infinity;
      __privateGet(this, _pendingBBox)[2] = -Infinity;
      __privateGet(this, _pendingBBox)[3] = -Infinity;
    }
    return this;
  }
  recordClipBox(idx, ctx, minX, maxX, minY, maxY) {
    const transform = Util.multiplyByDOMMatrix(__privateGet(this, _baseTransformStack).at(-1), ctx.getTransform());
    const clipBox = [Infinity, Infinity, -Infinity, -Infinity];
    Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, clipBox);
    const intersection = Util.intersect(__privateGet(this, _clipBox), clipBox);
    if (intersection) {
      __privateGet(this, _clipBox)[0] = intersection[0];
      __privateGet(this, _clipBox)[1] = intersection[1];
      __privateGet(this, _clipBox)[2] = intersection[2];
      __privateGet(this, _clipBox)[3] = intersection[3];
    } else {
      __privateGet(this, _clipBox)[0] = __privateGet(this, _clipBox)[1] = Infinity;
      __privateGet(this, _clipBox)[2] = __privateGet(this, _clipBox)[3] = -Infinity;
    }
    return this;
  }
  recordBBox(idx, ctx, minX, maxX, minY, maxY) {
    const clipBox = __privateGet(this, _clipBox);
    if (clipBox[0] === Infinity) {
      return this;
    }
    const transform = Util.multiplyByDOMMatrix(__privateGet(this, _baseTransformStack).at(-1), ctx.getTransform());
    if (clipBox[0] === -Infinity) {
      Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, __privateGet(this, _pendingBBox));
      return this;
    }
    const bbox = [Infinity, Infinity, -Infinity, -Infinity];
    Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, bbox);
    __privateGet(this, _pendingBBox)[0] = Math.min(__privateGet(this, _pendingBBox)[0], Math.max(bbox[0], clipBox[0]));
    __privateGet(this, _pendingBBox)[1] = Math.min(__privateGet(this, _pendingBBox)[1], Math.max(bbox[1], clipBox[1]));
    __privateGet(this, _pendingBBox)[2] = Math.max(__privateGet(this, _pendingBBox)[2], Math.min(bbox[2], clipBox[2]));
    __privateGet(this, _pendingBBox)[3] = Math.max(__privateGet(this, _pendingBBox)[3], Math.min(bbox[3], clipBox[3]));
    return this;
  }
  recordCharacterBBox(idx, ctx, font, scale = 1, x = 0, y = 0, getMeasure) {
    const fontBBox = font.bbox;
    let isBBoxTrustworthy;
    let computedBBox;
    if (fontBBox) {
      isBBoxTrustworthy = fontBBox[2] !== fontBBox[0] && fontBBox[3] !== fontBBox[1] && __privateGet(this, _fontBBoxTrustworthy).get(font);
      if (isBBoxTrustworthy !== false) {
        computedBBox = [0, 0, 0, 0];
        Util.axialAlignedBoundingBox(fontBBox, font.fontMatrix, computedBBox);
        if (scale !== 1 || x !== 0 || y !== 0) {
          Util.scaleMinMax([scale, 0, 0, -scale, x, y], computedBBox);
        }
        if (isBBoxTrustworthy) {
          return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);
        }
      }
    }
    if (!getMeasure) {
      return this.recordFullPageBBox(idx);
    }
    const measure = getMeasure();
    if (fontBBox && computedBBox && isBBoxTrustworthy === void 0) {
      isBBoxTrustworthy = computedBBox[0] <= x - measure.actualBoundingBoxLeft && computedBBox[2] >= x + measure.actualBoundingBoxRight && computedBBox[1] <= y - measure.actualBoundingBoxAscent && computedBBox[3] >= y + measure.actualBoundingBoxDescent;
      __privateGet(this, _fontBBoxTrustworthy).set(font, isBBoxTrustworthy);
      if (isBBoxTrustworthy) {
        return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);
      }
    }
    return this.recordBBox(idx, ctx, x - measure.actualBoundingBoxLeft, x + measure.actualBoundingBoxRight, y - measure.actualBoundingBoxAscent, y + measure.actualBoundingBoxDescent);
  }
  recordFullPageBBox(idx) {
    __privateGet(this, _pendingBBox)[0] = Math.max(0, __privateGet(this, _clipBox)[0]);
    __privateGet(this, _pendingBBox)[1] = Math.max(0, __privateGet(this, _clipBox)[1]);
    __privateGet(this, _pendingBBox)[2] = Math.min(__privateGet(this, _canvasWidth), __privateGet(this, _clipBox)[2]);
    __privateGet(this, _pendingBBox)[3] = Math.min(__privateGet(this, _canvasHeight), __privateGet(this, _clipBox)[3]);
    return this;
  }
  getSimpleIndex(dependencyName) {
    return __privateGet(this, _simple)[dependencyName];
  }
  recordDependencies(idx, dependencyNames) {
    const pendingDependencies = __privateGet(this, _pendingDependencies);
    const simple = __privateGet(this, _simple);
    const incremental = __privateGet(this, _incremental);
    for (const name of dependencyNames) {
      if (name in __privateGet(this, _simple)) {
        pendingDependencies.add(simple[name]);
      } else if (name in incremental) {
        incremental[name].forEach(pendingDependencies.add, pendingDependencies);
      }
    }
    return this;
  }
  recordNamedDependency(idx, name) {
    if (__privateGet(this, _namedDependencies).has(name)) {
      __privateGet(this, _pendingDependencies).add(__privateGet(this, _namedDependencies).get(name));
    }
    return this;
  }
  recordOperation(idx, preserve = false) {
    this.recordDependencies(idx, [FORCED_DEPENDENCY_LABEL]);
    if (__privateGet(this, _debugMetadata)) {
      const metadata = ensureDebugMetadata(__privateGet(this, _debugMetadata), idx);
      const {
        dependencies
      } = metadata;
      __privateGet(this, _pendingDependencies).forEach(dependencies.add, dependencies);
      __privateGet(this, _savesStack).forEach(dependencies.add, dependencies);
      __privateGet(this, _markedContentStack).forEach(dependencies.add, dependencies);
      dependencies.delete(idx);
      metadata.isRenderingOperation = true;
    }
    if (__privateGet(this, _pendingBBoxIdx) === idx) {
      const minX = floor(__privateGet(this, _pendingBBox)[0] * 256 / __privateGet(this, _canvasWidth));
      const minY = floor(__privateGet(this, _pendingBBox)[1] * 256 / __privateGet(this, _canvasHeight));
      const maxX = ceil(__privateGet(this, _pendingBBox)[2] * 256 / __privateGet(this, _canvasWidth));
      const maxY = ceil(__privateGet(this, _pendingBBox)[3] * 256 / __privateGet(this, _canvasHeight));
      expandBBox(__privateGet(this, _bboxesCoords), idx, minX, minY, maxX, maxY);
      for (const depIdx of __privateGet(this, _pendingDependencies)) {
        if (depIdx !== idx) {
          expandBBox(__privateGet(this, _bboxesCoords), depIdx, minX, minY, maxX, maxY);
        }
      }
      for (const saveIdx of __privateGet(this, _savesStack)) {
        if (saveIdx !== idx) {
          expandBBox(__privateGet(this, _bboxesCoords), saveIdx, minX, minY, maxX, maxY);
        }
      }
      for (const saveIdx of __privateGet(this, _markedContentStack)) {
        if (saveIdx !== idx) {
          expandBBox(__privateGet(this, _bboxesCoords), saveIdx, minX, minY, maxX, maxY);
        }
      }
      if (!preserve) {
        __privateGet(this, _pendingDependencies).clear();
        __privateSet(this, _pendingBBoxIdx, -1);
      }
    }
    return this;
  }
  recordShowTextOperation(idx, preserve = false) {
    const deps = Array.from(__privateGet(this, _pendingDependencies));
    this.recordOperation(idx, preserve);
    this.recordIncrementalData("sameLineText", idx);
    for (const dep of deps) {
      this.recordIncrementalData("sameLineText", dep);
    }
    return this;
  }
  bboxToClipBoxDropOperation(idx, preserve = false) {
    if (__privateGet(this, _pendingBBoxIdx) === idx) {
      __privateSet(this, _pendingBBoxIdx, -1);
      __privateGet(this, _clipBox)[0] = Math.max(__privateGet(this, _clipBox)[0], __privateGet(this, _pendingBBox)[0]);
      __privateGet(this, _clipBox)[1] = Math.max(__privateGet(this, _clipBox)[1], __privateGet(this, _pendingBBox)[1]);
      __privateGet(this, _clipBox)[2] = Math.min(__privateGet(this, _clipBox)[2], __privateGet(this, _pendingBBox)[2]);
      __privateGet(this, _clipBox)[3] = Math.min(__privateGet(this, _clipBox)[3], __privateGet(this, _pendingBBox)[3]);
      if (!preserve) {
        __privateGet(this, _pendingDependencies).clear();
      }
    }
    return this;
  }
  _takePendingDependencies() {
    const pendingDependencies = __privateGet(this, _pendingDependencies);
    __privateSet(this, _pendingDependencies, /* @__PURE__ */ new Set());
    return pendingDependencies;
  }
  _extractOperation(idx) {
    const operation = __privateGet(this, _operations).get(idx);
    __privateGet(this, _operations).delete(idx);
    return operation;
  }
  _pushPendingDependencies(dependencies) {
    for (const dep of dependencies) {
      __privateGet(this, _pendingDependencies).add(dep);
    }
  }
  take() {
    __privateGet(this, _fontBBoxTrustworthy).clear();
    return new BBoxReader(__privateGet(this, _bboxes2), __privateGet(this, _bboxesCoords));
  }
  takeDebugMetadata() {
    return __privateGet(this, _debugMetadata);
  }
};
_simple = new WeakMap();
_incremental = new WeakMap();
_namedDependencies = new WeakMap();
_savesStack = new WeakMap();
_markedContentStack = new WeakMap();
_baseTransformStack = new WeakMap();
_clipBox = new WeakMap();
_pendingBBox = new WeakMap();
_pendingBBoxIdx = new WeakMap();
_pendingDependencies = new WeakMap();
_operations = new WeakMap();
_fontBBoxTrustworthy = new WeakMap();
_canvasWidth = new WeakMap();
_canvasHeight = new WeakMap();
_bboxesCoords = new WeakMap();
_bboxes2 = new WeakMap();
_debugMetadata = new WeakMap();
_initializeBBoxes = new WeakSet();
initializeBBoxes_fn = function(operationsCount, oldBBoxes) {
  const buffer = new ArrayBuffer(operationsCount * 4);
  __privateSet(this, _bboxesCoords, new Uint8ClampedArray(buffer));
  __privateSet(this, _bboxes2, new Uint32Array(buffer));
  if (oldBBoxes && oldBBoxes.length > 0) {
    __privateGet(this, _bboxes2).set(oldBBoxes);
    __privateGet(this, _bboxes2).fill(EMPTY_BBOX, oldBBoxes.length);
  } else {
    __privateGet(this, _bboxes2).fill(EMPTY_BBOX);
  }
};
var _dependencyTracker, _opIdx, _ignoreBBoxes, _nestingLevel, _savesLevel;
var _CanvasNestedDependencyTracker = class _CanvasNestedDependencyTracker {
  constructor(dependencyTracker, opIdx, ignoreBBoxes) {
    __privateAdd(this, _dependencyTracker, void 0);
    __privateAdd(this, _opIdx, void 0);
    __privateAdd(this, _ignoreBBoxes, void 0);
    __privateAdd(this, _nestingLevel, 0);
    __privateAdd(this, _savesLevel, 0);
    if (dependencyTracker instanceof _CanvasNestedDependencyTracker && __privateGet(dependencyTracker, _ignoreBBoxes) === !!ignoreBBoxes) {
      return dependencyTracker;
    }
    __privateSet(this, _dependencyTracker, dependencyTracker);
    __privateSet(this, _opIdx, opIdx);
    __privateSet(this, _ignoreBBoxes, !!ignoreBBoxes);
  }
  growOperationsCount() {
    throw new Error("Unreachable");
  }
  save(opIdx) {
    __privateWrapper(this, _savesLevel)._++;
    __privateGet(this, _dependencyTracker).save(__privateGet(this, _opIdx));
    return this;
  }
  restore(opIdx) {
    if (__privateGet(this, _savesLevel) > 0) {
      __privateGet(this, _dependencyTracker).restore(__privateGet(this, _opIdx));
      __privateWrapper(this, _savesLevel)._--;
    }
    return this;
  }
  recordOpenMarker(idx) {
    __privateWrapper(this, _nestingLevel)._++;
    return this;
  }
  getOpenMarker() {
    return __privateGet(this, _nestingLevel) > 0 ? __privateGet(this, _opIdx) : __privateGet(this, _dependencyTracker).getOpenMarker();
  }
  recordCloseMarker(idx) {
    __privateWrapper(this, _nestingLevel)._--;
    return this;
  }
  beginMarkedContent(opIdx) {
    return this;
  }
  endMarkedContent(opIdx) {
    return this;
  }
  pushBaseTransform(ctx) {
    __privateGet(this, _dependencyTracker).pushBaseTransform(ctx);
    return this;
  }
  popBaseTransform() {
    __privateGet(this, _dependencyTracker).popBaseTransform();
    return this;
  }
  recordSimpleData(name, idx) {
    __privateGet(this, _dependencyTracker).recordSimpleData(name, __privateGet(this, _opIdx));
    return this;
  }
  recordIncrementalData(name, idx) {
    __privateGet(this, _dependencyTracker).recordIncrementalData(name, __privateGet(this, _opIdx));
    return this;
  }
  resetIncrementalData(name, idx) {
    __privateGet(this, _dependencyTracker).resetIncrementalData(name, __privateGet(this, _opIdx));
    return this;
  }
  recordNamedData(name, idx) {
    return this;
  }
  recordSimpleDataFromNamed(name, depName, fallbackIdx) {
    __privateGet(this, _dependencyTracker).recordSimpleDataFromNamed(name, depName, __privateGet(this, _opIdx));
    return this;
  }
  recordFutureForcedDependency(name, idx) {
    __privateGet(this, _dependencyTracker).recordFutureForcedDependency(name, __privateGet(this, _opIdx));
    return this;
  }
  inheritSimpleDataAsFutureForcedDependencies(names) {
    __privateGet(this, _dependencyTracker).inheritSimpleDataAsFutureForcedDependencies(names);
    return this;
  }
  inheritPendingDependenciesAsFutureForcedDependencies() {
    __privateGet(this, _dependencyTracker).inheritPendingDependenciesAsFutureForcedDependencies();
    return this;
  }
  resetBBox(idx) {
    if (!__privateGet(this, _ignoreBBoxes)) {
      __privateGet(this, _dependencyTracker).resetBBox(__privateGet(this, _opIdx));
    }
    return this;
  }
  recordClipBox(idx, ctx, minX, maxX, minY, maxY) {
    if (!__privateGet(this, _ignoreBBoxes)) {
      __privateGet(this, _dependencyTracker).recordClipBox(__privateGet(this, _opIdx), ctx, minX, maxX, minY, maxY);
    }
    return this;
  }
  recordBBox(idx, ctx, minX, maxX, minY, maxY) {
    if (!__privateGet(this, _ignoreBBoxes)) {
      __privateGet(this, _dependencyTracker).recordBBox(__privateGet(this, _opIdx), ctx, minX, maxX, minY, maxY);
    }
    return this;
  }
  recordCharacterBBox(idx, ctx, font, scale, x, y, getMeasure) {
    if (!__privateGet(this, _ignoreBBoxes)) {
      __privateGet(this, _dependencyTracker).recordCharacterBBox(__privateGet(this, _opIdx), ctx, font, scale, x, y, getMeasure);
    }
    return this;
  }
  recordFullPageBBox(idx) {
    if (!__privateGet(this, _ignoreBBoxes)) {
      __privateGet(this, _dependencyTracker).recordFullPageBBox(__privateGet(this, _opIdx));
    }
    return this;
  }
  getSimpleIndex(dependencyName) {
    return __privateGet(this, _dependencyTracker).getSimpleIndex(dependencyName);
  }
  recordDependencies(idx, dependencyNames) {
    __privateGet(this, _dependencyTracker).recordDependencies(__privateGet(this, _opIdx), dependencyNames);
    return this;
  }
  recordNamedDependency(idx, name) {
    __privateGet(this, _dependencyTracker).recordNamedDependency(__privateGet(this, _opIdx), name);
    return this;
  }
  recordOperation(idx) {
    __privateGet(this, _dependencyTracker).recordOperation(__privateGet(this, _opIdx), true);
    return this;
  }
  recordShowTextOperation(idx) {
    __privateGet(this, _dependencyTracker).recordShowTextOperation(__privateGet(this, _opIdx), true);
    return this;
  }
  bboxToClipBoxDropOperation(idx) {
    if (!__privateGet(this, _ignoreBBoxes)) {
      __privateGet(this, _dependencyTracker).bboxToClipBoxDropOperation(__privateGet(this, _opIdx), true);
    }
    return this;
  }
  take() {
    throw new Error("Unreachable");
  }
  takeDebugMetadata() {
    throw new Error("Unreachable");
  }
};
_dependencyTracker = new WeakMap();
_opIdx = new WeakMap();
_ignoreBBoxes = new WeakMap();
_nestingLevel = new WeakMap();
_savesLevel = new WeakMap();
var CanvasNestedDependencyTracker = _CanvasNestedDependencyTracker;
var Dependencies = {
  stroke: ["path", "transform", "filter", "strokeColor", "strokeAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "dash"],
  fill: ["path", "transform", "filter", "fillColor", "fillAlpha", "globalCompositeOperation", "SMask"],
  imageXObject: ["transform", "SMask", "filter", "fillAlpha", "strokeAlpha", "globalCompositeOperation"],
  rawFillPath: ["filter", "fillColor", "fillAlpha"],
  showText: ["transform", "leading", "charSpacing", "wordSpacing", "hScale", "textRise", "moveText", "textMatrix", "font", "fontObj", "filter", "fillColor", "textRenderingMode", "SMask", "fillAlpha", "strokeAlpha", "globalCompositeOperation", "sameLineText"],
  transform: ["transform"],
  transformAndFill: ["transform", "fillColor"]
};
var PathType = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
function applyBoundingBox(ctx, bbox) {
  if (!bbox) {
    return;
  }
  const width = bbox[2] - bbox[0];
  const height = bbox[3] - bbox[1];
  const region = new Path2D();
  region.rect(bbox[0], bbox[1], width, height);
  ctx.clip(region);
}
var BaseShadingPattern = class {
  isModifyingCurrentTransform() {
    return false;
  }
  getPattern() {
    unreachable("Abstract method `getPattern` called.");
  }
};
var RadialAxialShadingPattern = class extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._type = IR[1];
    this._bbox = IR[2];
    this._colorStops = IR[3];
    this._p0 = IR[4];
    this._p1 = IR[5];
    this._r0 = IR[6];
    this._r1 = IR[7];
    this.matrix = null;
  }
  _createGradient(ctx) {
    let grad;
    if (this._type === "axial") {
      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
    } else if (this._type === "radial") {
      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
    }
    for (const colorStop of this._colorStops) {
      grad.addColorStop(colorStop[0], colorStop[1]);
    }
    return grad;
  }
  getPattern(ctx, owner, inverse, pathType) {
    let pattern;
    if (pathType === PathType.STROKE || pathType === PathType.FILL) {
      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [0, 0, 0, 0];
      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
      const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height);
      const tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.beginPath();
      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
      inverse = Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
      tmpCtx.transform(...owner.baseTransform);
      if (this.matrix) {
        tmpCtx.transform(...this.matrix);
      }
      applyBoundingBox(tmpCtx, this._bbox);
      tmpCtx.fillStyle = this._createGradient(tmpCtx);
      tmpCtx.fill();
      pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
      const domMatrix = new DOMMatrix(inverse);
      pattern.setTransform(domMatrix);
    } else {
      applyBoundingBox(ctx, this._bbox);
      pattern = this._createGradient(ctx);
    }
    return pattern;
  }
};
function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
  const coords = context.coords, colors = context.colors;
  const bytes = data.data, rowSize = data.width * 4;
  let tmp;
  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }
  if (coords[p2 + 1] > coords[p3 + 1]) {
    tmp = p2;
    p2 = p3;
    p3 = tmp;
    tmp = c2;
    c2 = c3;
    c3 = tmp;
  }
  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }
  const x1 = (coords[p1] + context.offsetX) * context.scaleX;
  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
  const x2 = (coords[p2] + context.offsetX) * context.scaleX;
  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
  const x3 = (coords[p3] + context.offsetX) * context.scaleX;
  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
  if (y1 >= y3) {
    return;
  }
  const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
  const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
  const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
  const minY = Math.round(y1), maxY = Math.round(y3);
  let xa, car, cag, cab;
  let xb, cbr, cbg, cbb;
  for (let y = minY; y <= maxY; y++) {
    if (y < y2) {
      const k2 = y < y1 ? 0 : (y1 - y) / (y1 - y2);
      xa = x1 - (x1 - x2) * k2;
      car = c1r - (c1r - c2r) * k2;
      cag = c1g - (c1g - c2g) * k2;
      cab = c1b - (c1b - c2b) * k2;
    } else {
      let k2;
      if (y > y3) {
        k2 = 1;
      } else if (y2 === y3) {
        k2 = 0;
      } else {
        k2 = (y2 - y) / (y2 - y3);
      }
      xa = x2 - (x2 - x3) * k2;
      car = c2r - (c2r - c3r) * k2;
      cag = c2g - (c2g - c3g) * k2;
      cab = c2b - (c2b - c3b) * k2;
    }
    let k;
    if (y < y1) {
      k = 0;
    } else if (y > y3) {
      k = 1;
    } else {
      k = (y1 - y) / (y1 - y3);
    }
    xb = x1 - (x1 - x3) * k;
    cbr = c1r - (c1r - c3r) * k;
    cbg = c1g - (c1g - c3g) * k;
    cbb = c1b - (c1b - c3b) * k;
    const x1_ = Math.round(Math.min(xa, xb));
    const x2_ = Math.round(Math.max(xa, xb));
    let j = rowSize * y + x1_ * 4;
    for (let x = x1_; x <= x2_; x++) {
      k = (xa - x) / (xa - xb);
      if (k < 0) {
        k = 0;
      } else if (k > 1) {
        k = 1;
      }
      bytes[j++] = car - (car - cbr) * k | 0;
      bytes[j++] = cag - (cag - cbg) * k | 0;
      bytes[j++] = cab - (cab - cbb) * k | 0;
      bytes[j++] = 255;
    }
  }
}
function drawFigure(data, figure, context) {
  const ps = figure.coords;
  const cs = figure.colors;
  let i, ii;
  switch (figure.type) {
    case "lattice":
      const verticesPerRow = figure.verticesPerRow;
      const rows = Math.floor(ps.length / verticesPerRow) - 1;
      const cols = verticesPerRow - 1;
      for (i = 0; i < rows; i++) {
        let q = i * verticesPerRow;
        for (let j = 0; j < cols; j++, q++) {
          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
        }
      }
      break;
    case "triangles":
      for (i = 0, ii = ps.length; i < ii; i += 3) {
        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
      }
      break;
    default:
      throw new Error("illegal figure");
  }
}
var MeshShadingPattern = class extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._coords = IR[2];
    this._colors = IR[3];
    this._figures = IR[4];
    this._bounds = IR[5];
    this._bbox = IR[6];
    this._background = IR[7];
    this.matrix = null;
  }
  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
    const EXPECTED_SCALE = 1.1;
    const MAX_PATTERN_SIZE = 3e3;
    const BORDER_SIZE = 2;
    const offsetX = Math.floor(this._bounds[0]);
    const offsetY = Math.floor(this._bounds[1]);
    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const scaleX = boundsWidth / width;
    const scaleY = boundsHeight / height;
    const context = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -offsetX,
      offsetY: -offsetY,
      scaleX: 1 / scaleX,
      scaleY: 1 / scaleY
    };
    const paddedWidth = width + BORDER_SIZE * 2;
    const paddedHeight = height + BORDER_SIZE * 2;
    const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight);
    const tmpCtx = tmpCanvas.context;
    const data = tmpCtx.createImageData(width, height);
    if (backgroundColor) {
      const bytes = data.data;
      for (let i = 0, ii = bytes.length; i < ii; i += 4) {
        bytes[i] = backgroundColor[0];
        bytes[i + 1] = backgroundColor[1];
        bytes[i + 2] = backgroundColor[2];
        bytes[i + 3] = 255;
      }
    }
    for (const figure of this._figures) {
      drawFigure(data, figure, context);
    }
    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
    const canvas = tmpCanvas.canvas;
    return {
      canvas,
      offsetX: offsetX - BORDER_SIZE * scaleX,
      offsetY: offsetY - BORDER_SIZE * scaleY,
      scaleX,
      scaleY
    };
  }
  isModifyingCurrentTransform() {
    return true;
  }
  getPattern(ctx, owner, inverse, pathType) {
    applyBoundingBox(ctx, this._bbox);
    const scale = new Float32Array(2);
    if (pathType === PathType.SHADING) {
      Util.singularValueDecompose2dScale(getCurrentTransform(ctx), scale);
    } else if (this.matrix) {
      Util.singularValueDecompose2dScale(this.matrix, scale);
      const [matrixScaleX, matrixScaleY] = scale;
      Util.singularValueDecompose2dScale(owner.baseTransform, scale);
      scale[0] *= matrixScaleX;
      scale[1] *= matrixScaleY;
    } else {
      Util.singularValueDecompose2dScale(owner.baseTransform, scale);
    }
    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
    if (pathType !== PathType.SHADING) {
      ctx.setTransform(...owner.baseTransform);
      if (this.matrix) {
        ctx.transform(...this.matrix);
      }
    }
    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
  }
};
var DummyShadingPattern = class extends BaseShadingPattern {
  getPattern() {
    return "hotpink";
  }
};
function getShadingPattern(IR) {
  switch (IR[0]) {
    case "RadialAxial":
      return new RadialAxialShadingPattern(IR);
    case "Mesh":
      return new MeshShadingPattern(IR);
    case "Dummy":
      return new DummyShadingPattern();
  }
  throw new Error(`Unknown IR type: ${IR[0]}`);
}
var PaintType = {
  COLORED: 1,
  UNCOLORED: 2
};
var _TilingPattern = class _TilingPattern {
  constructor(IR, ctx, canvasGraphicsFactory, baseTransform) {
    this.color = IR[1];
    this.operatorList = IR[2];
    this.matrix = IR[3];
    this.bbox = IR[4];
    this.xstep = IR[5];
    this.ystep = IR[6];
    this.paintType = IR[7];
    this.tilingType = IR[8];
    this.ctx = ctx;
    this.canvasGraphicsFactory = canvasGraphicsFactory;
    this.baseTransform = baseTransform;
  }
  createPatternCanvas(owner, opIdx) {
    var _a2, _b;
    const {
      bbox,
      operatorList,
      paintType,
      tilingType,
      color,
      canvasGraphicsFactory
    } = this;
    let {
      xstep,
      ystep
    } = this;
    xstep = Math.abs(xstep);
    ystep = Math.abs(ystep);
    info("TilingType: " + tilingType);
    const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
    const width = x1 - x0;
    const height = y1 - y0;
    const scale = new Float32Array(2);
    Util.singularValueDecompose2dScale(this.matrix, scale);
    const [matrixScaleX, matrixScaleY] = scale;
    Util.singularValueDecompose2dScale(this.baseTransform, scale);
    const combinedScaleX = matrixScaleX * scale[0];
    const combinedScaleY = matrixScaleY * scale[1];
    let canvasWidth = width, canvasHeight = height, redrawHorizontally = false, redrawVertically = false;
    const xScaledStep = Math.ceil(xstep * combinedScaleX);
    const yScaledStep = Math.ceil(ystep * combinedScaleY);
    const xScaledWidth = Math.ceil(width * combinedScaleX);
    const yScaledHeight = Math.ceil(height * combinedScaleY);
    if (xScaledStep >= xScaledWidth) {
      canvasWidth = xstep;
    } else {
      redrawHorizontally = true;
    }
    if (yScaledStep >= yScaledHeight) {
      canvasHeight = ystep;
    } else {
      redrawVertically = true;
    }
    const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);
    const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);
    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size);
    const tmpCtx = tmpCanvas.context;
    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx, opIdx);
    graphics.groupLevel = owner.groupLevel;
    this.setFillAndStrokeStyleToContext(graphics, paintType, color);
    tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);
    graphics.transform(0, dimx.scale, 0, 0, dimy.scale, 0, 0);
    tmpCtx.save();
    (_a2 = graphics.dependencyTracker) == null ? void 0 : _a2.save();
    this.clipBbox(graphics, x0, y0, x1, y1);
    graphics.baseTransform = getCurrentTransform(graphics.ctx);
    graphics.executeOperatorList(operatorList);
    graphics.endDrawing();
    (_b = graphics.dependencyTracker) == null ? void 0 : _b.restore();
    tmpCtx.restore();
    if (redrawHorizontally || redrawVertically) {
      const image = tmpCanvas.canvas;
      if (redrawHorizontally) {
        canvasWidth = xstep;
      }
      if (redrawVertically) {
        canvasHeight = ystep;
      }
      const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);
      const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);
      const xSize = dimx2.size;
      const ySize = dimy2.size;
      const tmpCanvas2 = owner.cachedCanvases.getCanvas("pattern-workaround", xSize, ySize);
      const tmpCtx2 = tmpCanvas2.context;
      const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;
      const jj = redrawVertically ? Math.floor(height / ystep) : 0;
      for (let i = 0; i <= ii; i++) {
        for (let j = 0; j <= jj; j++) {
          tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);
        }
      }
      return {
        canvas: tmpCanvas2.canvas,
        scaleX: dimx2.scale,
        scaleY: dimy2.scale,
        offsetX: x0,
        offsetY: y0
      };
    }
    return {
      canvas: tmpCanvas.canvas,
      scaleX: dimx.scale,
      scaleY: dimy.scale,
      offsetX: x0,
      offsetY: y0
    };
  }
  getSizeAndScale(step, realOutputSize, scale) {
    const maxSize = Math.max(_TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
    let size = Math.ceil(step * scale);
    if (size >= maxSize) {
      size = maxSize;
    } else {
      scale = size / step;
    }
    return {
      scale,
      size
    };
  }
  clipBbox(graphics, x0, y0, x1, y1) {
    const bboxWidth = x1 - x0;
    const bboxHeight = y1 - y0;
    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
    Util.axialAlignedBoundingBox([x0, y0, x1, y1], getCurrentTransform(graphics.ctx), graphics.current.minMax);
    graphics.clip();
    graphics.endPath();
  }
  setFillAndStrokeStyleToContext(graphics, paintType, color) {
    const context = graphics.ctx, current = graphics.current;
    switch (paintType) {
      case PaintType.COLORED:
        const {
          fillStyle,
          strokeStyle
        } = this.ctx;
        context.fillStyle = current.fillColor = fillStyle;
        context.strokeStyle = current.strokeColor = strokeStyle;
        break;
      case PaintType.UNCOLORED:
        context.fillStyle = context.strokeStyle = color;
        current.fillColor = current.strokeColor = color;
        break;
      default:
        throw new FormatError(`Unsupported paint type: ${paintType}`);
    }
  }
  isModifyingCurrentTransform() {
    return false;
  }
  getPattern(ctx, owner, inverse, pathType, opIdx) {
    let matrix = inverse;
    if (pathType !== PathType.SHADING) {
      matrix = Util.transform(matrix, owner.baseTransform);
      if (this.matrix) {
        matrix = Util.transform(matrix, this.matrix);
      }
    }
    const temporaryPatternCanvas = this.createPatternCanvas(owner, opIdx);
    let domMatrix = new DOMMatrix(matrix);
    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
    pattern.setTransform(domMatrix);
    return pattern;
  }
};
__publicField(_TilingPattern, "MAX_PATTERN_SIZE", 3e3);
var TilingPattern = _TilingPattern;
function convertBlackAndWhiteToRGBA({
  src,
  srcPos = 0,
  dest,
  width,
  height,
  nonBlackColor = 4294967295,
  inverseDecode = false
}) {
  const black = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
  const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];
  const widthInSource = width >> 3;
  const widthRemainder = width & 7;
  const srcLength = src.length;
  dest = new Uint32Array(dest.buffer);
  let destPos = 0;
  for (let i = 0; i < height; i++) {
    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
      const elem2 = srcPos < srcLength ? src[srcPos] : 255;
      dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
    }
    if (widthRemainder === 0) {
      continue;
    }
    const elem = srcPos < srcLength ? src[srcPos++] : 255;
    for (let j = 0; j < widthRemainder; j++) {
      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
    }
  }
  return {
    srcPos,
    destPos
  };
}
var MIN_FONT_SIZE = 16;
var MAX_FONT_SIZE = 100;
var EXECUTION_TIME = 15;
var EXECUTION_STEPS = 10;
var FULL_CHUNK_HEIGHT = 16;
var SCALE_MATRIX = new DOMMatrix();
var XY = new Float32Array(2);
var MIN_MAX_INIT = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);
function mirrorContextOperations(ctx, destCtx) {
  if (ctx._removeMirroring) {
    throw new Error("Context is already forwarding operations.");
  }
  ctx.__originalSave = ctx.save;
  ctx.__originalRestore = ctx.restore;
  ctx.__originalRotate = ctx.rotate;
  ctx.__originalScale = ctx.scale;
  ctx.__originalTranslate = ctx.translate;
  ctx.__originalTransform = ctx.transform;
  ctx.__originalSetTransform = ctx.setTransform;
  ctx.__originalResetTransform = ctx.resetTransform;
  ctx.__originalClip = ctx.clip;
  ctx.__originalMoveTo = ctx.moveTo;
  ctx.__originalLineTo = ctx.lineTo;
  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
  ctx.__originalRect = ctx.rect;
  ctx.__originalClosePath = ctx.closePath;
  ctx.__originalBeginPath = ctx.beginPath;
  ctx._removeMirroring = () => {
    ctx.save = ctx.__originalSave;
    ctx.restore = ctx.__originalRestore;
    ctx.rotate = ctx.__originalRotate;
    ctx.scale = ctx.__originalScale;
    ctx.translate = ctx.__originalTranslate;
    ctx.transform = ctx.__originalTransform;
    ctx.setTransform = ctx.__originalSetTransform;
    ctx.resetTransform = ctx.__originalResetTransform;
    ctx.clip = ctx.__originalClip;
    ctx.moveTo = ctx.__originalMoveTo;
    ctx.lineTo = ctx.__originalLineTo;
    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
    ctx.rect = ctx.__originalRect;
    ctx.closePath = ctx.__originalClosePath;
    ctx.beginPath = ctx.__originalBeginPath;
    delete ctx._removeMirroring;
  };
  ctx.save = function() {
    destCtx.save();
    this.__originalSave();
  };
  ctx.restore = function() {
    destCtx.restore();
    this.__originalRestore();
  };
  ctx.translate = function(x, y) {
    destCtx.translate(x, y);
    this.__originalTranslate(x, y);
  };
  ctx.scale = function(x, y) {
    destCtx.scale(x, y);
    this.__originalScale(x, y);
  };
  ctx.transform = function(a, b, c, d, e, f) {
    destCtx.transform(a, b, c, d, e, f);
    this.__originalTransform(a, b, c, d, e, f);
  };
  ctx.setTransform = function(a, b, c, d, e, f) {
    destCtx.setTransform(a, b, c, d, e, f);
    this.__originalSetTransform(a, b, c, d, e, f);
  };
  ctx.resetTransform = function() {
    destCtx.resetTransform();
    this.__originalResetTransform();
  };
  ctx.rotate = function(angle) {
    destCtx.rotate(angle);
    this.__originalRotate(angle);
  };
  ctx.clip = function(rule) {
    destCtx.clip(rule);
    this.__originalClip(rule);
  };
  ctx.moveTo = function(x, y) {
    destCtx.moveTo(x, y);
    this.__originalMoveTo(x, y);
  };
  ctx.lineTo = function(x, y) {
    destCtx.lineTo(x, y);
    this.__originalLineTo(x, y);
  };
  ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  };
  ctx.rect = function(x, y, width, height) {
    destCtx.rect(x, y, width, height);
    this.__originalRect(x, y, width, height);
  };
  ctx.closePath = function() {
    destCtx.closePath();
    this.__originalClosePath();
  };
  ctx.beginPath = function() {
    destCtx.beginPath();
    this.__originalBeginPath();
  };
}
var CachedCanvases = class {
  constructor(canvasFactory) {
    this.canvasFactory = canvasFactory;
    this.cache = /* @__PURE__ */ Object.create(null);
  }
  getCanvas(id, width, height) {
    let canvasEntry;
    if (this.cache[id] !== void 0) {
      canvasEntry = this.cache[id];
      this.canvasFactory.reset(canvasEntry, width, height);
    } else {
      canvasEntry = this.canvasFactory.create(width, height);
      this.cache[id] = canvasEntry;
    }
    return canvasEntry;
  }
  delete(id) {
    delete this.cache[id];
  }
  clear() {
    for (const id in this.cache) {
      const canvasEntry = this.cache[id];
      this.canvasFactory.destroy(canvasEntry);
      delete this.cache[id];
    }
  }
};
function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
  const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);
  if (b === 0 && c === 0) {
    const tlX = destX * a + tx;
    const rTlX = Math.round(tlX);
    const tlY = destY * d + ty;
    const rTlY = Math.round(tlY);
    const brX = (destX + destW) * a + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destY + destH) * d + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
    ctx.setTransform(a, b, c, d, tx, ty);
    return [rWidth, rHeight];
  }
  if (a === 0 && d === 0) {
    const tlX = destY * c + tx;
    const rTlX = Math.round(tlX);
    const tlY = destX * b + ty;
    const rTlY = Math.round(tlY);
    const brX = (destY + destH) * c + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destX + destW) * b + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
    ctx.setTransform(a, b, c, d, tx, ty);
    return [rHeight, rWidth];
  }
  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
  const scaleX = Math.hypot(a, b);
  const scaleY = Math.hypot(c, d);
  return [scaleX * destW, scaleY * destH];
}
var CanvasExtraState = class {
  constructor(width, height, preInit) {
    __publicField(this, "alphaIsShape", false);
    __publicField(this, "fontSize", 0);
    __publicField(this, "fontSizeScale", 1);
    __publicField(this, "textMatrix", null);
    __publicField(this, "textMatrixScale", 1);
    __publicField(this, "fontMatrix", FONT_IDENTITY_MATRIX);
    __publicField(this, "leading", 0);
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "lineX", 0);
    __publicField(this, "lineY", 0);
    __publicField(this, "charSpacing", 0);
    __publicField(this, "wordSpacing", 0);
    __publicField(this, "textHScale", 1);
    __publicField(this, "textRenderingMode", TextRenderingMode.FILL);
    __publicField(this, "textRise", 0);
    __publicField(this, "fillColor", "#000000");
    __publicField(this, "strokeColor", "#000000");
    __publicField(this, "patternFill", false);
    __publicField(this, "patternStroke", false);
    __publicField(this, "fillAlpha", 1);
    __publicField(this, "strokeAlpha", 1);
    __publicField(this, "lineWidth", 1);
    __publicField(this, "activeSMask", null);
    __publicField(this, "transferMaps", "none");
    preInit == null ? void 0 : preInit(this);
    this.clipBox = new Float32Array([0, 0, width, height]);
    this.minMax = MIN_MAX_INIT.slice();
  }
  clone() {
    const clone = Object.create(this);
    clone.clipBox = this.clipBox.slice();
    clone.minMax = this.minMax.slice();
    return clone;
  }
  getPathBoundingBox(pathType = PathType.FILL, transform = null) {
    const box = this.minMax.slice();
    if (pathType === PathType.STROKE) {
      if (!transform) {
        unreachable("Stroke bounding box must include transform.");
      }
      Util.singularValueDecompose2dScale(transform, XY);
      const xStrokePad = XY[0] * this.lineWidth / 2;
      const yStrokePad = XY[1] * this.lineWidth / 2;
      box[0] -= xStrokePad;
      box[1] -= yStrokePad;
      box[2] += xStrokePad;
      box[3] += yStrokePad;
    }
    return box;
  }
  updateClipFromPath() {
    const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());
    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
  }
  isEmptyClip() {
    return this.minMax[0] === Infinity;
  }
  startNewPathAndClipBox(box) {
    this.clipBox.set(box, 0);
    this.minMax.set(MIN_MAX_INIT, 0);
  }
  getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {
    return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
  }
};
function putBinaryImageData(ctx, imgData) {
  if (imgData instanceof ImageData) {
    ctx.putImageData(imgData, 0, 0);
    return;
  }
  const height = imgData.height, width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0, destPos;
  const src = imgData.data;
  const dest = chunkImgData.data;
  let i, j, thisChunkHeight, elemsInThisChunk;
  if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {
    const srcLength = src.byteLength;
    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
    const dest32DataLength = dest32.length;
    const fullSrcDiff = width + 7 >> 3;
    const white = 4294967295;
    const black = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
    for (i = 0; i < totalChunks; i++) {
      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
      destPos = 0;
      for (j = 0; j < thisChunkHeight; j++) {
        const srcDiff = srcLength - srcPos;
        let k = 0;
        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
        const kEndUnrolled = kEnd & ~7;
        let mask = 0;
        let srcByte = 0;
        for (; k < kEndUnrolled; k += 8) {
          srcByte = src[srcPos++];
          dest32[destPos++] = srcByte & 128 ? white : black;
          dest32[destPos++] = srcByte & 64 ? white : black;
          dest32[destPos++] = srcByte & 32 ? white : black;
          dest32[destPos++] = srcByte & 16 ? white : black;
          dest32[destPos++] = srcByte & 8 ? white : black;
          dest32[destPos++] = srcByte & 4 ? white : black;
          dest32[destPos++] = srcByte & 2 ? white : black;
          dest32[destPos++] = srcByte & 1 ? white : black;
        }
        for (; k < kEnd; k++) {
          if (mask === 0) {
            srcByte = src[srcPos++];
            mask = 128;
          }
          dest32[destPos++] = srcByte & mask ? white : black;
          mask >>= 1;
        }
      }
      while (destPos < dest32DataLength) {
        dest32[destPos++] = 0;
      }
      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {
    j = 0;
    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
    for (i = 0; i < fullChunks; i++) {
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      srcPos += elemsInThisChunk;
      ctx.putImageData(chunkImgData, 0, j);
      j += FULL_CHUNK_HEIGHT;
    }
    if (i < totalChunks) {
      elemsInThisChunk = width * partialChunkHeight * 4;
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      ctx.putImageData(chunkImgData, 0, j);
    }
  } else if (imgData.kind === util_ImageKind.RGB_24BPP) {
    thisChunkHeight = FULL_CHUNK_HEIGHT;
    elemsInThisChunk = width * thisChunkHeight;
    for (i = 0; i < totalChunks; i++) {
      if (i >= fullChunks) {
        thisChunkHeight = partialChunkHeight;
        elemsInThisChunk = width * thisChunkHeight;
      }
      destPos = 0;
      for (j = elemsInThisChunk; j--; ) {
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = 255;
      }
      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else {
    throw new Error(`bad image kind: ${imgData.kind}`);
  }
}
function putBinaryImageMask(ctx, imgData) {
  if (imgData.bitmap) {
    ctx.drawImage(imgData.bitmap, 0, 0);
    return;
  }
  const height = imgData.height, width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0;
  const src = imgData.data;
  const dest = chunkImgData.data;
  for (let i = 0; i < totalChunks; i++) {
    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
    ({
      srcPos
    } = convertBlackAndWhiteToRGBA({
      src,
      srcPos,
      dest,
      width,
      height: thisChunkHeight,
      nonBlackColor: 0
    }));
    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
  }
}
function copyCtxState(sourceCtx, destCtx) {
  const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const property of properties) {
    if (sourceCtx[property] !== void 0) {
      destCtx[property] = sourceCtx[property];
    }
  }
  if (sourceCtx.setLineDash !== void 0) {
    destCtx.setLineDash(sourceCtx.getLineDash());
    destCtx.lineDashOffset = sourceCtx.lineDashOffset;
  }
}
function resetCtxToDefault(ctx) {
  ctx.strokeStyle = ctx.fillStyle = "#000000";
  ctx.fillRule = "nonzero";
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;
  ctx.lineCap = "butt";
  ctx.lineJoin = "miter";
  ctx.miterLimit = 10;
  ctx.globalCompositeOperation = "source-over";
  ctx.font = "10px sans-serif";
  if (ctx.setLineDash !== void 0) {
    ctx.setLineDash([]);
    ctx.lineDashOffset = 0;
  }
  const {
    filter
  } = ctx;
  if (filter !== "none" && filter !== "") {
    ctx.filter = "none";
  }
}
function getImageSmoothingEnabled(transform, interpolate) {
  if (interpolate) {
    return true;
  }
  Util.singularValueDecompose2dScale(transform, XY);
  const actualScale = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);
  return XY[0] <= actualScale && XY[1] <= actualScale;
}
var LINE_CAP_STYLES = ["butt", "round", "square"];
var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
var NORMAL_CLIP = {};
var EO_CLIP = {};
var _restoreInitialState, restoreInitialState_fn, _drawFilter, drawFilter_fn, _getScaledPath, getScaledPath_fn;
var _CanvasGraphics = class _CanvasGraphics {
  constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {
    optionalContentConfig,
    markedContentStack = null
  }, annotationCanvasMap, pageColors, dependencyTracker) {
    __privateAdd(this, _restoreInitialState);
    __privateAdd(this, _drawFilter);
    __privateAdd(this, _getScaledPath);
    this.ctx = canvasCtx;
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.stateStack = [];
    this.pendingClip = null;
    this.pendingEOFill = false;
    this.res = null;
    this.xobjs = null;
    this.commonObjs = commonObjs;
    this.objs = objs;
    this.canvasFactory = canvasFactory;
    this.filterFactory = filterFactory;
    this.groupStack = [];
    this.baseTransform = null;
    this.baseTransformStack = [];
    this.groupLevel = 0;
    this.smaskStack = [];
    this.smaskCounter = 0;
    this.tempSMask = null;
    this.suspendedCtx = null;
    this.contentVisible = true;
    this.markedContentStack = markedContentStack || [];
    this.optionalContentConfig = optionalContentConfig;
    this.cachedCanvases = new CachedCanvases(this.canvasFactory);
    this.cachedPatterns = /* @__PURE__ */ new Map();
    this.annotationCanvasMap = annotationCanvasMap;
    this.viewportScale = 1;
    this.outputScaleX = 1;
    this.outputScaleY = 1;
    this.pageColors = pageColors;
    this._cachedScaleForStroking = [-1, 0];
    this._cachedGetSinglePixelWidth = null;
    this._cachedBitmapsMap = /* @__PURE__ */ new Map();
    this.dependencyTracker = dependencyTracker ?? null;
  }
  getObject(opIdx, data, fallback = null) {
    var _a2;
    if (typeof data === "string") {
      (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordNamedDependency(opIdx, data);
      return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
    }
    return fallback;
  }
  beginDrawing({
    transform,
    viewport,
    transparency = false,
    background = null
  }) {
    const width = this.ctx.canvas.width;
    const height = this.ctx.canvas.height;
    const savedFillStyle = this.ctx.fillStyle;
    this.ctx.fillStyle = background || "#ffffff";
    this.ctx.fillRect(0, 0, width, height);
    this.ctx.fillStyle = savedFillStyle;
    if (transparency) {
      const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
      this.compositeCtx = this.ctx;
      this.transparentCanvas = transparentCanvas.canvas;
      this.ctx = transparentCanvas.context;
      this.ctx.save();
      this.ctx.transform(...getCurrentTransform(this.compositeCtx));
    }
    this.ctx.save();
    resetCtxToDefault(this.ctx);
    if (transform) {
      this.ctx.transform(...transform);
      this.outputScaleX = transform[0];
      this.outputScaleY = transform[0];
    }
    this.ctx.transform(...viewport.transform);
    this.viewportScale = viewport.scale;
    this.baseTransform = getCurrentTransform(this.ctx);
  }
  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper, operationsFilter) {
    var _a2;
    const argsArray = operatorList.argsArray;
    const fnArray = operatorList.fnArray;
    let i = executionStartIdx || 0;
    const argsArrayLen = argsArray.length;
    if (argsArrayLen === i) {
      return i;
    }
    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
    let steps = 0;
    const commonObjs = this.commonObjs;
    const objs = this.objs;
    let fnId, fnArgs;
    while (true) {
      if (stepper !== void 0 && i === stepper.nextBreakPoint) {
        stepper.breakIt(i, continueCallback);
        return i;
      }
      if (!operationsFilter || operationsFilter(i)) {
        fnId = fnArray[i];
        fnArgs = argsArray[i] ?? null;
        if (fnId !== OPS.dependency) {
          if (fnArgs === null) {
            this[fnId](i);
          } else {
            this[fnId](i, ...fnArgs);
          }
        } else {
          for (const depObjId of fnArgs) {
            (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordNamedData(depObjId, i);
            const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
            if (!objsPool.has(depObjId)) {
              objsPool.get(depObjId, continueCallback);
              return i;
            }
          }
        }
      }
      i++;
      if (i === argsArrayLen) {
        return i;
      }
      if (chunkOperations && ++steps > EXECUTION_STEPS) {
        if (Date.now() > endTime) {
          continueCallback();
          return i;
        }
        steps = 0;
      }
    }
  }
  endDrawing() {
    __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
    this.cachedCanvases.clear();
    this.cachedPatterns.clear();
    for (const cache of this._cachedBitmapsMap.values()) {
      for (const canvas of cache.values()) {
        if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
          canvas.width = canvas.height = 0;
        }
      }
      cache.clear();
    }
    this._cachedBitmapsMap.clear();
    __privateMethod(this, _drawFilter, drawFilter_fn).call(this);
  }
  _scaleImage(img, inverseTransform) {
    const width = img.width ?? img.displayWidth;
    const height = img.height ?? img.displayHeight;
    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
    let paintWidth = width, paintHeight = height;
    let tmpCanvasId = "prescale1";
    let tmpCanvas, tmpCtx;
    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
      let newWidth = paintWidth, newHeight = paintHeight;
      if (widthScale > 2 && paintWidth > 1) {
        newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);
        widthScale /= paintWidth / newWidth;
      }
      if (heightScale > 2 && paintHeight > 1) {
        newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;
        heightScale /= paintHeight / newHeight;
      }
      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
      tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, newWidth, newHeight);
      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
      img = tmpCanvas.canvas;
      paintWidth = newWidth;
      paintHeight = newHeight;
      tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
    }
    return {
      img,
      paintWidth,
      paintHeight
    };
  }
  _createMaskCanvas(opIdx, img) {
    var _a2, _b;
    const ctx = this.ctx;
    const {
      width,
      height
    } = img;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    const currentTransform = getCurrentTransform(ctx);
    let cache, cacheKey, scaled, maskCanvas;
    if ((img.bitmap || img.data) && img.count > 1) {
      const mainKey = img.bitmap || img.data.buffer;
      cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);
      cache = this._cachedBitmapsMap.get(mainKey);
      if (!cache) {
        cache = /* @__PURE__ */ new Map();
        this._cachedBitmapsMap.set(mainKey, cache);
      }
      const cachedImage = cache.get(cacheKey);
      if (cachedImage && !isPatternFill) {
        const offsetX2 = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
        const offsetY2 = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
        (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordDependencies(opIdx, Dependencies.transformAndFill);
        return {
          canvas: cachedImage,
          offsetX: offsetX2,
          offsetY: offsetY2
        };
      }
      scaled = cachedImage;
    }
    if (!scaled) {
      maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      putBinaryImageMask(maskCanvas.context, img);
    }
    let maskToCanvas = Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
    maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
    const minMax = MIN_MAX_INIT.slice();
    Util.axialAlignedBoundingBox([0, 0, width, height], maskToCanvas, minMax);
    const [minX, minY, maxX, maxY] = minMax;
    const drawnWidth = Math.round(maxX - minX) || 1;
    const drawnHeight = Math.round(maxY - minY) || 1;
    const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
    const fillCtx = fillCanvas.context;
    const offsetX = minX;
    const offsetY = minY;
    fillCtx.translate(-offsetX, -offsetY);
    fillCtx.transform(...maskToCanvas);
    if (!scaled) {
      scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));
      scaled = scaled.img;
      if (cache && isPatternFill) {
        cache.set(cacheKey, scaled);
      }
    }
    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);
    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
    fillCtx.globalCompositeOperation = "source-in";
    const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL, opIdx) : fillColor;
    fillCtx.fillRect(0, 0, width, height);
    if (cache && !isPatternFill) {
      this.cachedCanvases.delete("fillCanvas");
      cache.set(cacheKey, fillCanvas.canvas);
    }
    (_b = this.dependencyTracker) == null ? void 0 : _b.recordDependencies(opIdx, Dependencies.transformAndFill);
    return {
      canvas: fillCanvas.canvas,
      offsetX: Math.round(offsetX),
      offsetY: Math.round(offsetY)
    };
  }
  setLineWidth(opIdx, width) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("lineWidth", opIdx);
    if (width !== this.current.lineWidth) {
      this._cachedScaleForStroking[0] = -1;
    }
    this.current.lineWidth = width;
    this.ctx.lineWidth = width;
  }
  setLineCap(opIdx, style) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("lineCap", opIdx);
    this.ctx.lineCap = LINE_CAP_STYLES[style];
  }
  setLineJoin(opIdx, style) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("lineJoin", opIdx);
    this.ctx.lineJoin = LINE_JOIN_STYLES[style];
  }
  setMiterLimit(opIdx, limit) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("miterLimit", opIdx);
    this.ctx.miterLimit = limit;
  }
  setDash(opIdx, dashArray, dashPhase) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("dash", opIdx);
    const ctx = this.ctx;
    if (ctx.setLineDash !== void 0) {
      ctx.setLineDash(dashArray);
      ctx.lineDashOffset = dashPhase;
    }
  }
  setRenderingIntent(opIdx, intent) {
  }
  setFlatness(opIdx, flatness) {
  }
  setGState(opIdx, states) {
    var _a2, _b, _c, _d, _e;
    for (const [key, value] of states) {
      switch (key) {
        case "LW":
          this.setLineWidth(opIdx, value);
          break;
        case "LC":
          this.setLineCap(opIdx, value);
          break;
        case "LJ":
          this.setLineJoin(opIdx, value);
          break;
        case "ML":
          this.setMiterLimit(opIdx, value);
          break;
        case "D":
          this.setDash(opIdx, value[0], value[1]);
          break;
        case "RI":
          this.setRenderingIntent(opIdx, value);
          break;
        case "FL":
          this.setFlatness(opIdx, value);
          break;
        case "Font":
          this.setFont(opIdx, value[0], value[1]);
          break;
        case "CA":
          (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("strokeAlpha", opIdx);
          this.current.strokeAlpha = value;
          break;
        case "ca":
          (_b = this.dependencyTracker) == null ? void 0 : _b.recordSimpleData("fillAlpha", opIdx);
          this.ctx.globalAlpha = this.current.fillAlpha = value;
          break;
        case "BM":
          (_c = this.dependencyTracker) == null ? void 0 : _c.recordSimpleData("globalCompositeOperation", opIdx);
          this.ctx.globalCompositeOperation = value;
          break;
        case "SMask":
          (_d = this.dependencyTracker) == null ? void 0 : _d.recordSimpleData("SMask", opIdx);
          this.current.activeSMask = value ? this.tempSMask : null;
          this.tempSMask = null;
          this.checkSMaskState();
          break;
        case "TR":
          (_e = this.dependencyTracker) == null ? void 0 : _e.recordSimpleData("filter", opIdx);
          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);
          break;
      }
    }
  }
  get inSMaskMode() {
    return !!this.suspendedCtx;
  }
  checkSMaskState() {
    const inSMaskMode = this.inSMaskMode;
    if (this.current.activeSMask && !inSMaskMode) {
      this.beginSMaskMode();
    } else if (!this.current.activeSMask && inSMaskMode) {
      this.endSMaskMode();
    }
  }
  beginSMaskMode(opIdx) {
    if (this.inSMaskMode) {
      throw new Error("beginSMaskMode called while already in smask mode");
    }
    const drawnWidth = this.ctx.canvas.width;
    const drawnHeight = this.ctx.canvas.height;
    const cacheId = "smaskGroupAt" + this.groupLevel;
    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    this.suspendedCtx = this.ctx;
    const ctx = this.ctx = scratchCanvas.context;
    ctx.setTransform(this.suspendedCtx.getTransform());
    copyCtxState(this.suspendedCtx, ctx);
    mirrorContextOperations(ctx, this.suspendedCtx);
    this.setGState(opIdx, [["BM", "source-over"]]);
  }
  endSMaskMode() {
    if (!this.inSMaskMode) {
      throw new Error("endSMaskMode called while not in smask mode");
    }
    this.ctx._removeMirroring();
    copyCtxState(this.ctx, this.suspendedCtx);
    this.ctx = this.suspendedCtx;
    this.suspendedCtx = null;
  }
  compose(dirtyBox) {
    if (!this.current.activeSMask) {
      return;
    }
    if (!dirtyBox) {
      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    } else {
      dirtyBox[0] = Math.floor(dirtyBox[0]);
      dirtyBox[1] = Math.floor(dirtyBox[1]);
      dirtyBox[2] = Math.ceil(dirtyBox[2]);
      dirtyBox[3] = Math.ceil(dirtyBox[3]);
    }
    const smask = this.current.activeSMask;
    const suspendedCtx = this.suspendedCtx;
    this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    this.ctx.restore();
  }
  composeSMask(ctx, smask, layerCtx, layerBox) {
    const layerOffsetX = layerBox[0];
    const layerOffsetY = layerBox[1];
    const layerWidth = layerBox[2] - layerOffsetX;
    const layerHeight = layerBox[3] - layerOffsetY;
    if (layerWidth === 0 || layerHeight === 0) {
      return;
    }
    this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = "source-over";
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(layerCtx.canvas, 0, 0);
    ctx.restore();
  }
  genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
    let maskCanvas = maskCtx.canvas;
    let maskX = layerOffsetX - maskOffsetX;
    let maskY = layerOffsetY - maskOffsetY;
    if (backdrop) {
      if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {
        const canvas = this.cachedCanvases.getCanvas("maskExtension", width, height);
        const ctx = canvas.context;
        ctx.drawImage(maskCanvas, -maskX, -maskY);
        ctx.globalCompositeOperation = "destination-atop";
        ctx.fillStyle = backdrop;
        ctx.fillRect(0, 0, width, height);
        ctx.globalCompositeOperation = "source-over";
        maskCanvas = canvas.canvas;
        maskX = maskY = 0;
      } else {
        maskCtx.save();
        maskCtx.globalAlpha = 1;
        maskCtx.setTransform(1, 0, 0, 1, 0, 0);
        const clip2 = new Path2D();
        clip2.rect(maskX, maskY, width, height);
        maskCtx.clip(clip2);
        maskCtx.globalCompositeOperation = "destination-atop";
        maskCtx.fillStyle = backdrop;
        maskCtx.fillRect(maskX, maskY, width, height);
        maskCtx.restore();
      }
    }
    layerCtx.save();
    layerCtx.globalAlpha = 1;
    layerCtx.setTransform(1, 0, 0, 1, 0, 0);
    if (subtype === "Alpha" && transferMap) {
      layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);
    } else if (subtype === "Luminosity") {
      layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);
    }
    const clip = new Path2D();
    clip.rect(layerOffsetX, layerOffsetY, width, height);
    layerCtx.clip(clip);
    layerCtx.globalCompositeOperation = "destination-in";
    layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);
    layerCtx.restore();
  }
  save(opIdx) {
    var _a2;
    if (this.inSMaskMode) {
      copyCtxState(this.ctx, this.suspendedCtx);
    }
    this.ctx.save();
    const old = this.current;
    this.stateStack.push(old);
    this.current = old.clone();
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.save(opIdx);
  }
  restore(opIdx) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.restore(opIdx);
    if (this.stateStack.length === 0) {
      if (this.inSMaskMode) {
        this.endSMaskMode();
      }
      return;
    }
    this.current = this.stateStack.pop();
    this.ctx.restore();
    if (this.inSMaskMode) {
      copyCtxState(this.suspendedCtx, this.ctx);
    }
    this.checkSMaskState();
    this.pendingClip = null;
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
  }
  transform(opIdx, a, b, c, d, e, f) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordIncrementalData("transform", opIdx);
    this.ctx.transform(a, b, c, d, e, f);
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
  }
  constructPath(opIdx, op, data, minMax) {
    let [path] = data;
    if (!minMax) {
      path || (path = data[0] = new Path2D());
      this[op](opIdx, path);
      return;
    }
    if (this.dependencyTracker !== null) {
      const outerExtraSize = op === OPS.stroke ? this.current.lineWidth / 2 : 0;
      this.dependencyTracker.resetBBox(opIdx).recordBBox(opIdx, this.ctx, minMax[0] - outerExtraSize, minMax[2] + outerExtraSize, minMax[1] - outerExtraSize, minMax[3] + outerExtraSize).recordDependencies(opIdx, ["transform"]);
    }
    if (!(path instanceof Path2D)) {
      const path2d = data[0] = new Path2D();
      for (let i = 0, ii = path.length; i < ii; ) {
        switch (path[i++]) {
          case DrawOPS.moveTo:
            path2d.moveTo(path[i++], path[i++]);
            break;
          case DrawOPS.lineTo:
            path2d.lineTo(path[i++], path[i++]);
            break;
          case DrawOPS.curveTo:
            path2d.bezierCurveTo(path[i++], path[i++], path[i++], path[i++], path[i++], path[i++]);
            break;
          case DrawOPS.closePath:
            path2d.closePath();
            break;
          default:
            warn(`Unrecognized drawing path operator: ${path[i - 1]}`);
            break;
        }
      }
      path = path2d;
    }
    Util.axialAlignedBoundingBox(minMax, getCurrentTransform(this.ctx), this.current.minMax);
    this[op](opIdx, path);
    this._pathStartIdx = opIdx;
  }
  closePath(opIdx) {
    this.ctx.closePath();
  }
  stroke(opIdx, path, consumePath = true) {
    var _a2;
    const ctx = this.ctx;
    const strokeColor = this.current.strokeColor;
    ctx.globalAlpha = this.current.strokeAlpha;
    if (this.contentVisible) {
      if (typeof strokeColor === "object" && (strokeColor == null ? void 0 : strokeColor.getPattern)) {
        const baseTransform = strokeColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;
        ctx.save();
        ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);
        if (baseTransform) {
          const newPath = new Path2D();
          newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));
          path = newPath;
        }
        this.rescaleAndStroke(path, false);
        ctx.restore();
      } else {
        this.rescaleAndStroke(path, true);
      }
    }
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordDependencies(opIdx, Dependencies.stroke);
    if (consumePath) {
      this.consumePath(opIdx, path, this.current.getClippedPathBoundingBox(PathType.STROKE, getCurrentTransform(this.ctx)));
    }
    ctx.globalAlpha = this.current.fillAlpha;
  }
  closeStroke(opIdx, path) {
    this.stroke(opIdx, path);
  }
  fill(opIdx, path, consumePath = true) {
    var _a2, _b, _c;
    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    let needRestore = false;
    if (isPatternFill) {
      const baseTransform = fillColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;
      (_a2 = this.dependencyTracker) == null ? void 0 : _a2.save(opIdx);
      ctx.save();
      ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);
      if (baseTransform) {
        const newPath = new Path2D();
        newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));
        path = newPath;
      }
      needRestore = true;
    }
    const intersect = this.current.getClippedPathBoundingBox();
    if (this.contentVisible && intersect !== null) {
      if (this.pendingEOFill) {
        ctx.fill(path, "evenodd");
        this.pendingEOFill = false;
      } else {
        ctx.fill(path);
      }
    }
    (_b = this.dependencyTracker) == null ? void 0 : _b.recordDependencies(opIdx, Dependencies.fill);
    if (needRestore) {
      ctx.restore();
      (_c = this.dependencyTracker) == null ? void 0 : _c.restore(opIdx);
    }
    if (consumePath) {
      this.consumePath(opIdx, path, intersect);
    }
  }
  eoFill(opIdx, path) {
    this.pendingEOFill = true;
    this.fill(opIdx, path);
  }
  fillStroke(opIdx, path) {
    this.fill(opIdx, path, false);
    this.stroke(opIdx, path, false);
    this.consumePath(opIdx, path);
  }
  eoFillStroke(opIdx, path) {
    this.pendingEOFill = true;
    this.fillStroke(opIdx, path);
  }
  closeFillStroke(opIdx, path) {
    this.fillStroke(opIdx, path);
  }
  closeEOFillStroke(opIdx, path) {
    this.pendingEOFill = true;
    this.fillStroke(opIdx, path);
  }
  endPath(opIdx, path) {
    this.consumePath(opIdx, path);
  }
  rawFillPath(opIdx, path) {
    var _a2;
    this.ctx.fill(path);
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordDependencies(opIdx, Dependencies.rawFillPath).recordOperation(opIdx);
  }
  clip(opIdx) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordFutureForcedDependency("clipMode", opIdx);
    this.pendingClip = NORMAL_CLIP;
  }
  eoClip(opIdx) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordFutureForcedDependency("clipMode", opIdx);
    this.pendingClip = EO_CLIP;
  }
  beginText(opIdx) {
    var _a2;
    this.current.textMatrix = null;
    this.current.textMatrixScale = 1;
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordOpenMarker(opIdx).resetIncrementalData("sameLineText").resetIncrementalData("moveText", opIdx);
  }
  endText(opIdx) {
    const paths = this.pendingTextPaths;
    const ctx = this.ctx;
    if (this.dependencyTracker) {
      const {
        dependencyTracker
      } = this;
      if (paths !== void 0) {
        dependencyTracker.recordFutureForcedDependency("textClip", dependencyTracker.getOpenMarker()).recordFutureForcedDependency("textClip", opIdx);
      }
      dependencyTracker.recordCloseMarker(opIdx);
    }
    if (paths !== void 0) {
      const newPath = new Path2D();
      const invTransf = ctx.getTransform().invertSelf();
      for (const {
        transform,
        x,
        y,
        fontSize,
        path
      } of paths) {
        if (!path) {
          continue;
        }
        newPath.addPath(path, new DOMMatrix(transform).preMultiplySelf(invTransf).translate(x, y).scale(fontSize, -fontSize));
      }
      ctx.clip(newPath);
    }
    delete this.pendingTextPaths;
  }
  setCharSpacing(opIdx, spacing) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("charSpacing", opIdx);
    this.current.charSpacing = spacing;
  }
  setWordSpacing(opIdx, spacing) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("wordSpacing", opIdx);
    this.current.wordSpacing = spacing;
  }
  setHScale(opIdx, scale) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("hScale", opIdx);
    this.current.textHScale = scale / 100;
  }
  setLeading(opIdx, leading) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("leading", opIdx);
    this.current.leading = -leading;
  }
  setFont(opIdx, fontRefName, size) {
    var _a2, _b;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("font", opIdx).recordSimpleDataFromNamed("fontObj", fontRefName, opIdx);
    const fontObj = this.commonObjs.get(fontRefName);
    const current = this.current;
    if (!fontObj) {
      throw new Error(`Can't find font for ${fontRefName}`);
    }
    current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
      warn("Invalid font matrix for font " + fontRefName);
    }
    if (size < 0) {
      size = -size;
      current.fontDirection = -1;
    } else {
      current.fontDirection = 1;
    }
    this.current.font = fontObj;
    this.current.fontSize = size;
    if (fontObj.isType3Font) {
      return;
    }
    const name = fontObj.loadedName || "sans-serif";
    const typeface = ((_b = fontObj.systemFontInfo) == null ? void 0 : _b.css) || `"${name}", ${fontObj.fallbackName}`;
    let bold = "normal";
    if (fontObj.black) {
      bold = "900";
    } else if (fontObj.bold) {
      bold = "bold";
    }
    const italic = fontObj.italic ? "italic" : "normal";
    let browserFontSize = size;
    if (size < MIN_FONT_SIZE) {
      browserFontSize = MIN_FONT_SIZE;
    } else if (size > MAX_FONT_SIZE) {
      browserFontSize = MAX_FONT_SIZE;
    }
    this.current.fontSizeScale = size / browserFontSize;
    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
  }
  setTextRenderingMode(opIdx, mode) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("textRenderingMode", opIdx);
    this.current.textRenderingMode = mode;
  }
  setTextRise(opIdx, rise) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("textRise", opIdx);
    this.current.textRise = rise;
  }
  moveText(opIdx, x, y) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.resetIncrementalData("sameLineText").recordIncrementalData("moveText", opIdx);
    this.current.x = this.current.lineX += x;
    this.current.y = this.current.lineY += y;
  }
  setLeadingMoveText(opIdx, x, y) {
    this.setLeading(opIdx, -y);
    this.moveText(opIdx, x, y);
  }
  setTextMatrix(opIdx, matrix) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("textMatrix", opIdx);
    const {
      current
    } = this;
    current.textMatrix = matrix;
    current.textMatrixScale = Math.hypot(matrix[0], matrix[1]);
    current.x = current.lineX = 0;
    current.y = current.lineY = 0;
  }
  nextLine(opIdx) {
    var _a2;
    this.moveText(opIdx, 0, this.current.leading);
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordIncrementalData("moveText", this.dependencyTracker.getSimpleIndex("leading") ?? opIdx);
  }
  paintChar(opIdx, character, x, y, patternFillTransform, patternStrokeTransform) {
    var _a2, _b, _c, _d;
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const textRenderingMode = current.textRenderingMode;
    const fontSize = current.fontSize / current.fontSizeScale;
    const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
    const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);
    const patternFill = current.patternFill && !font.missingFile;
    const patternStroke = current.patternStroke && !font.missingFile;
    let path;
    if ((font.disableFontFace || isAddToPathSet || patternFill || patternStroke) && !font.missingFile) {
      path = font.getPathGenerator(this.commonObjs, character);
    }
    if (path && (font.disableFontFace || patternFill || patternStroke)) {
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(fontSize, -fontSize);
      (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordCharacterBBox(opIdx, ctx, font);
      let currentTransform;
      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        if (patternFillTransform) {
          currentTransform = ctx.getTransform();
          ctx.setTransform(...patternFillTransform);
          const scaledPath = __privateMethod(this, _getScaledPath, getScaledPath_fn).call(this, path, currentTransform, patternFillTransform);
          ctx.fill(scaledPath);
        } else {
          ctx.fill(path);
        }
      }
      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        if (patternStrokeTransform) {
          currentTransform || (currentTransform = ctx.getTransform());
          ctx.setTransform(...patternStrokeTransform);
          const {
            a,
            b,
            c,
            d
          } = currentTransform;
          const invPatternTransform = Util.inverseTransform(patternStrokeTransform);
          const transf = Util.transform([a, b, c, d, 0, 0], invPatternTransform);
          Util.singularValueDecompose2dScale(transf, XY);
          ctx.lineWidth *= Math.max(XY[0], XY[1]) / fontSize;
          ctx.stroke(__privateMethod(this, _getScaledPath, getScaledPath_fn).call(this, path, currentTransform, patternStrokeTransform));
        } else {
          ctx.lineWidth /= fontSize;
          ctx.stroke(path);
        }
      }
      ctx.restore();
    } else {
      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        ctx.fillText(character, x, y);
        (_b = this.dependencyTracker) == null ? void 0 : _b.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, () => ctx.measureText(character));
      }
      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        if (this.dependencyTracker) {
          (_c = this.dependencyTracker) == null ? void 0 : _c.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, () => ctx.measureText(character)).recordDependencies(opIdx, Dependencies.stroke);
        }
        ctx.strokeText(character, x, y);
      }
    }
    if (isAddToPathSet) {
      const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
      paths.push({
        transform: getCurrentTransform(ctx),
        x,
        y,
        fontSize,
        path
      });
      (_d = this.dependencyTracker) == null ? void 0 : _d.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y);
    }
  }
  get isFontSubpixelAAEnabled() {
    const {
      context: ctx
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    ctx.scale(1.5, 1);
    ctx.fillText("I", 0, 10);
    const data = ctx.getImageData(0, 0, 10, 10).data;
    let enabled = false;
    for (let i = 3; i < data.length; i += 4) {
      if (data[i] > 0 && data[i] < 255) {
        enabled = true;
        break;
      }
    }
    return shadow(this, "isFontSubpixelAAEnabled", enabled);
  }
  showText(opIdx, glyphs) {
    var _a2, _b, _c, _d;
    if (this.dependencyTracker) {
      this.dependencyTracker.recordDependencies(opIdx, Dependencies.showText).resetBBox(opIdx);
      if (this.current.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG) {
        this.dependencyTracker.recordFutureForcedDependency("textClip", opIdx).inheritPendingDependenciesAsFutureForcedDependencies();
      }
    }
    const current = this.current;
    const font = current.font;
    if (font.isType3Font) {
      this.showType3Text(opIdx, glyphs);
      (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordShowTextOperation(opIdx);
      return void 0;
    }
    const fontSize = current.fontSize;
    if (fontSize === 0) {
      (_b = this.dependencyTracker) == null ? void 0 : _b.recordOperation(opIdx);
      return void 0;
    }
    const ctx = this.ctx;
    const fontSizeScale = current.fontSizeScale;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const fontDirection = current.fontDirection;
    const textHScale = current.textHScale * fontDirection;
    const glyphsLength = glyphs.length;
    const vertical = font.vertical;
    const spacingDir = vertical ? 1 : -1;
    const defaultVMetrics = font.defaultVMetrics;
    const widthAdvanceScale = fontSize * current.fontMatrix[0];
    const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
    ctx.save();
    if (current.textMatrix) {
      ctx.transform(...current.textMatrix);
    }
    ctx.translate(current.x, current.y + current.textRise);
    if (fontDirection > 0) {
      ctx.scale(textHScale, -1);
    } else {
      ctx.scale(textHScale, 1);
    }
    let patternFillTransform, patternStrokeTransform;
    if (current.patternFill) {
      ctx.save();
      const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);
      patternFillTransform = getCurrentTransform(ctx);
      ctx.restore();
      ctx.fillStyle = pattern;
    }
    if (current.patternStroke) {
      ctx.save();
      const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);
      patternStrokeTransform = getCurrentTransform(ctx);
      ctx.restore();
      ctx.strokeStyle = pattern;
    }
    let lineWidth = current.lineWidth;
    const scale = current.textMatrixScale;
    if (scale === 0 || lineWidth === 0) {
      const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        lineWidth = this.getSinglePixelWidth();
      }
    } else {
      lineWidth /= scale;
    }
    if (fontSizeScale !== 1) {
      ctx.scale(fontSizeScale, fontSizeScale);
      lineWidth /= fontSizeScale;
    }
    ctx.lineWidth = lineWidth;
    if (font.isInvalidPDFjsFont) {
      const chars = [];
      let width = 0;
      for (const glyph of glyphs) {
        chars.push(glyph.unicode);
        width += glyph.width;
      }
      const joinedChars = chars.join("");
      ctx.fillText(joinedChars, 0, 0);
      if (this.dependencyTracker !== null) {
        const measure = ctx.measureText(joinedChars);
        this.dependencyTracker.recordBBox(opIdx, this.ctx, -measure.actualBoundingBoxLeft, measure.actualBoundingBoxRight, -measure.actualBoundingBoxAscent, measure.actualBoundingBoxDescent).recordShowTextOperation(opIdx);
      }
      current.x += width * widthAdvanceScale * textHScale;
      ctx.restore();
      this.compose();
      return void 0;
    }
    let x = 0, i;
    for (i = 0; i < glyphsLength; ++i) {
      const glyph = glyphs[i];
      if (typeof glyph === "number") {
        x += spacingDir * glyph * fontSize / 1e3;
        continue;
      }
      let restoreNeeded = false;
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const character = glyph.fontChar;
      const accent = glyph.accent;
      let scaledX, scaledY;
      let width = glyph.width;
      if (vertical) {
        const vmetric = glyph.vmetric || defaultVMetrics;
        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
        const vy = vmetric[2] * widthAdvanceScale;
        width = vmetric ? -vmetric[0] : width;
        scaledX = vx / fontSizeScale;
        scaledY = (x + vy) / fontSizeScale;
      } else {
        scaledX = x / fontSizeScale;
        scaledY = 0;
      }
      let measure;
      if (font.remeasure && width > 0) {
        measure = ctx.measureText(character);
        const measuredWidth = measure.width * 1e3 / fontSize * fontSizeScale;
        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
          const characterScaleX = width / measuredWidth;
          restoreNeeded = true;
          ctx.save();
          ctx.scale(characterScaleX, 1);
          scaledX /= characterScaleX;
        } else if (width !== measuredWidth) {
          scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
        }
      }
      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
        if (simpleFillText && !accent) {
          ctx.fillText(character, scaledX, scaledY);
          (_c = this.dependencyTracker) == null ? void 0 : _c.recordCharacterBBox(opIdx, ctx, measure ? {
            bbox: null
          } : font, fontSize / fontSizeScale, scaledX, scaledY, () => measure ?? ctx.measureText(character));
        } else {
          this.paintChar(opIdx, character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);
          if (accent) {
            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
            this.paintChar(opIdx, accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);
          }
        }
      }
      const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
      x += charWidth;
      if (restoreNeeded) {
        ctx.restore();
      }
    }
    if (vertical) {
      current.y -= x;
    } else {
      current.x += x * textHScale;
    }
    ctx.restore();
    this.compose();
    (_d = this.dependencyTracker) == null ? void 0 : _d.recordShowTextOperation(opIdx);
    return void 0;
  }
  showType3Text(opIdx, glyphs) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const fontSize = current.fontSize;
    const fontDirection = current.fontDirection;
    const spacingDir = font.vertical ? 1 : -1;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const textHScale = current.textHScale * fontDirection;
    const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
    const glyphsLength = glyphs.length;
    const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;
    let i, glyph, width, spacingLength;
    if (isTextInvisible || fontSize === 0) {
      return;
    }
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
    ctx.save();
    if (current.textMatrix) {
      ctx.transform(...current.textMatrix);
    }
    ctx.translate(current.x, current.y + current.textRise);
    ctx.scale(textHScale, fontDirection);
    const dependencyTracker = this.dependencyTracker;
    this.dependencyTracker = dependencyTracker ? new CanvasNestedDependencyTracker(dependencyTracker, opIdx) : null;
    for (i = 0; i < glyphsLength; ++i) {
      glyph = glyphs[i];
      if (typeof glyph === "number") {
        spacingLength = spacingDir * glyph * fontSize / 1e3;
        this.ctx.translate(spacingLength, 0);
        current.x += spacingLength * textHScale;
        continue;
      }
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const operatorList = font.charProcOperatorList[glyph.operatorListId];
      if (!operatorList) {
        warn(`Type3 character "${glyph.operatorListId}" is not available.`);
      } else if (this.contentVisible) {
        this.save();
        ctx.scale(fontSize, fontSize);
        ctx.transform(...fontMatrix);
        this.executeOperatorList(operatorList);
        this.restore();
      }
      const p = [glyph.width, 0];
      Util.applyTransform(p, fontMatrix);
      width = p[0] * fontSize + spacing;
      ctx.translate(width, 0);
      current.x += width * textHScale;
    }
    ctx.restore();
    if (dependencyTracker) {
      this.dependencyTracker = dependencyTracker;
    }
  }
  setCharWidth(opIdx, xWidth, yWidth) {
  }
  setCharWidthAndBounds(opIdx, xWidth, yWidth, llx, lly, urx, ury) {
    var _a2;
    const clip = new Path2D();
    clip.rect(llx, lly, urx - llx, ury - lly);
    this.ctx.clip(clip);
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordBBox(opIdx, this.ctx, llx, urx, lly, ury).recordClipBox(opIdx, this.ctx, llx, urx, lly, ury);
    this.endPath(opIdx);
  }
  getColorN_Pattern(opIdx, IR) {
    let pattern;
    if (IR[0] === "TilingPattern") {
      const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
      const canvasGraphicsFactory = {
        createCanvasGraphics: (ctx, renderingOpIdx) => new _CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
          optionalContentConfig: this.optionalContentConfig,
          markedContentStack: this.markedContentStack
        }, void 0, void 0, this.dependencyTracker ? new CanvasNestedDependencyTracker(this.dependencyTracker, renderingOpIdx, true) : null)
      };
      pattern = new TilingPattern(IR, this.ctx, canvasGraphicsFactory, baseTransform);
    } else {
      pattern = this._getPattern(opIdx, IR[1], IR[2]);
    }
    return pattern;
  }
  setStrokeColorN(opIdx, ...args) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("strokeColor", opIdx);
    this.current.strokeColor = this.getColorN_Pattern(opIdx, args);
    this.current.patternStroke = true;
  }
  setFillColorN(opIdx, ...args) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("fillColor", opIdx);
    this.current.fillColor = this.getColorN_Pattern(opIdx, args);
    this.current.patternFill = true;
  }
  setStrokeRGBColor(opIdx, color) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("strokeColor", opIdx);
    this.ctx.strokeStyle = this.current.strokeColor = color;
    this.current.patternStroke = false;
  }
  setStrokeTransparent(opIdx) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("strokeColor", opIdx);
    this.ctx.strokeStyle = this.current.strokeColor = "transparent";
    this.current.patternStroke = false;
  }
  setFillRGBColor(opIdx, color) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("fillColor", opIdx);
    this.ctx.fillStyle = this.current.fillColor = color;
    this.current.patternFill = false;
  }
  setFillTransparent(opIdx) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordSimpleData("fillColor", opIdx);
    this.ctx.fillStyle = this.current.fillColor = "transparent";
    this.current.patternFill = false;
  }
  _getPattern(opIdx, objId, matrix = null) {
    let pattern;
    if (this.cachedPatterns.has(objId)) {
      pattern = this.cachedPatterns.get(objId);
    } else {
      pattern = getShadingPattern(this.getObject(opIdx, objId));
      this.cachedPatterns.set(objId, pattern);
    }
    if (matrix) {
      pattern.matrix = matrix;
    }
    return pattern;
  }
  shadingFill(opIdx, objId) {
    var _a2;
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    this.save(opIdx);
    const pattern = this._getPattern(opIdx, objId);
    ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING, opIdx);
    const inv = getCurrentTransformInverse(ctx);
    if (inv) {
      const {
        width,
        height
      } = ctx.canvas;
      const minMax = MIN_MAX_INIT.slice();
      Util.axialAlignedBoundingBox([0, 0, width, height], inv, minMax);
      const [x0, y0, x1, y1] = minMax;
      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
    } else {
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    }
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.resetBBox(opIdx).recordFullPageBBox(opIdx).recordDependencies(opIdx, Dependencies.transform).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);
    this.compose(this.current.getClippedPathBoundingBox());
    this.restore(opIdx);
  }
  beginInlineImage() {
    unreachable("Should not call beginInlineImage");
  }
  beginImageData() {
    unreachable("Should not call beginImageData");
  }
  paintFormXObjectBegin(opIdx, matrix, bbox) {
    var _a2;
    if (!this.contentVisible) {
      return;
    }
    this.save(opIdx);
    this.baseTransformStack.push(this.baseTransform);
    if (matrix) {
      this.transform(opIdx, ...matrix);
    }
    this.baseTransform = getCurrentTransform(this.ctx);
    if (bbox) {
      Util.axialAlignedBoundingBox(bbox, this.baseTransform, this.current.minMax);
      const [x0, y0, x1, y1] = bbox;
      const clip = new Path2D();
      clip.rect(x0, y0, x1 - x0, y1 - y0);
      this.ctx.clip(clip);
      (_a2 = this.dependencyTracker) == null ? void 0 : _a2.recordClipBox(opIdx, this.ctx, x0, x1, y0, y1);
      this.endPath(opIdx);
    }
  }
  paintFormXObjectEnd(opIdx) {
    if (!this.contentVisible) {
      return;
    }
    this.restore(opIdx);
    this.baseTransform = this.baseTransformStack.pop();
  }
  beginGroup(opIdx, group) {
    var _a2;
    if (!this.contentVisible) {
      return;
    }
    this.save(opIdx);
    if (this.inSMaskMode) {
      this.endSMaskMode();
      this.current.activeSMask = null;
    }
    const currentCtx = this.ctx;
    if (!group.isolated) {
      info("TODO: Support non-isolated groups.");
    }
    if (group.knockout) {
      warn("Knockout groups not supported.");
    }
    const currentTransform = getCurrentTransform(currentCtx);
    if (group.matrix) {
      currentCtx.transform(...group.matrix);
    }
    if (!group.bbox) {
      throw new Error("Bounding box is required.");
    }
    let bounds = MIN_MAX_INIT.slice();
    Util.axialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx), bounds);
    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
    bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
    const offsetX = Math.floor(bounds[0]);
    const offsetY = Math.floor(bounds[1]);
    const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
    const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
    let cacheId = "groupAt" + this.groupLevel;
    if (group.smask) {
      cacheId += "_smask_" + this.smaskCounter++ % 2;
    }
    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    const groupCtx = scratchCanvas.context;
    groupCtx.translate(-offsetX, -offsetY);
    groupCtx.transform(...currentTransform);
    let clip = new Path2D();
    const [x0, y0, x1, y1] = group.bbox;
    clip.rect(x0, y0, x1 - x0, y1 - y0);
    if (group.matrix) {
      const path = new Path2D();
      path.addPath(clip, new DOMMatrix(group.matrix));
      clip = path;
    }
    groupCtx.clip(clip);
    if (group.smask) {
      this.smaskStack.push({
        canvas: scratchCanvas.canvas,
        context: groupCtx,
        offsetX,
        offsetY,
        subtype: group.smask.subtype,
        backdrop: group.smask.backdrop,
        transferMap: group.smask.transferMap || null,
        startTransformInverse: null
      });
    }
    if (!group.smask || this.dependencyTracker) {
      currentCtx.setTransform(1, 0, 0, 1, 0, 0);
      currentCtx.translate(offsetX, offsetY);
      currentCtx.save();
    }
    copyCtxState(currentCtx, groupCtx);
    this.ctx = groupCtx;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.inheritSimpleDataAsFutureForcedDependencies(["fillAlpha", "strokeAlpha", "globalCompositeOperation"]).pushBaseTransform(currentCtx);
    this.setGState(opIdx, [["BM", "source-over"], ["ca", 1], ["CA", 1]]);
    this.groupStack.push(currentCtx);
    this.groupLevel++;
  }
  endGroup(opIdx, group) {
    var _a2;
    if (!this.contentVisible) {
      return;
    }
    this.groupLevel--;
    const groupCtx = this.ctx;
    const ctx = this.groupStack.pop();
    this.ctx = ctx;
    this.ctx.imageSmoothingEnabled = false;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.popBaseTransform();
    if (group.smask) {
      this.tempSMask = this.smaskStack.pop();
      this.restore(opIdx);
      if (this.dependencyTracker) {
        this.ctx.restore();
      }
    } else {
      this.ctx.restore();
      const currentMtx = getCurrentTransform(this.ctx);
      this.restore(opIdx);
      this.ctx.save();
      this.ctx.setTransform(...currentMtx);
      const dirtyBox = MIN_MAX_INIT.slice();
      Util.axialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx, dirtyBox);
      this.ctx.drawImage(groupCtx.canvas, 0, 0);
      this.ctx.restore();
      this.compose(dirtyBox);
    }
  }
  beginAnnotation(opIdx, id, rect, transform, matrix, hasOwnCanvas) {
    __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
    resetCtxToDefault(this.ctx);
    this.ctx.save();
    this.save(opIdx);
    if (this.baseTransform) {
      this.ctx.setTransform(...this.baseTransform);
    }
    if (rect) {
      const width = rect[2] - rect[0];
      const height = rect[3] - rect[1];
      if (hasOwnCanvas && this.annotationCanvasMap) {
        transform = transform.slice();
        transform[4] -= rect[0];
        transform[5] -= rect[1];
        rect = rect.slice();
        rect[0] = rect[1] = 0;
        rect[2] = width;
        rect[3] = height;
        Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), XY);
        const {
          viewportScale
        } = this;
        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
        const {
          canvas,
          context
        } = this.annotationCanvas;
        this.annotationCanvasMap.set(id, canvas);
        this.annotationCanvas.savedCtx = this.ctx;
        this.ctx = context;
        this.ctx.save();
        this.ctx.setTransform(XY[0], 0, 0, -XY[1], 0, height * XY[1]);
        resetCtxToDefault(this.ctx);
      } else {
        resetCtxToDefault(this.ctx);
        this.endPath(opIdx);
        const clip = new Path2D();
        clip.rect(rect[0], rect[1], width, height);
        this.ctx.clip(clip);
      }
    }
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.transform(opIdx, ...transform);
    this.transform(opIdx, ...matrix);
  }
  endAnnotation(opIdx) {
    if (this.annotationCanvas) {
      this.ctx.restore();
      __privateMethod(this, _drawFilter, drawFilter_fn).call(this);
      this.ctx = this.annotationCanvas.savedCtx;
      delete this.annotationCanvas.savedCtx;
      delete this.annotationCanvas;
    }
  }
  paintImageMaskXObject(opIdx, img) {
    var _a2;
    if (!this.contentVisible) {
      return;
    }
    const count = img.count;
    img = this.getObject(opIdx, img.data, img);
    img.count = count;
    const ctx = this.ctx;
    const mask = this._createMaskCanvas(opIdx, img);
    const maskCanvas = mask.canvas;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.resetBBox(opIdx).recordBBox(opIdx, this.ctx, mask.offsetX, mask.offsetX + maskCanvas.width, mask.offsetY, mask.offsetY + maskCanvas.height).recordOperation(opIdx);
    ctx.restore();
    this.compose();
  }
  paintImageMaskXObjectRepeat(opIdx, img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
    var _a2, _b, _c;
    if (!this.contentVisible) {
      return;
    }
    img = this.getObject(opIdx, img.data, img);
    const ctx = this.ctx;
    ctx.save();
    const currentTransform = getCurrentTransform(ctx);
    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
    const mask = this._createMaskCanvas(opIdx, img);
    ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.resetBBox(opIdx);
    for (let i = 0, ii = positions.length; i < ii; i += 2) {
      const trans = Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
      ctx.drawImage(mask.canvas, trans[4], trans[5]);
      (_b = this.dependencyTracker) == null ? void 0 : _b.recordBBox(opIdx, this.ctx, trans[4], trans[4] + mask.canvas.width, trans[5], trans[5] + mask.canvas.height);
    }
    ctx.restore();
    this.compose();
    (_c = this.dependencyTracker) == null ? void 0 : _c.recordOperation(opIdx);
  }
  paintImageMaskXObjectGroup(opIdx, images) {
    var _a2, _b, _c;
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.resetBBox(opIdx).recordDependencies(opIdx, Dependencies.transformAndFill);
    for (const image of images) {
      const {
        data,
        width,
        height,
        transform
      } = image;
      const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      const maskCtx = maskCanvas.context;
      maskCtx.save();
      const img = this.getObject(opIdx, data, image);
      putBinaryImageMask(maskCtx, img);
      maskCtx.globalCompositeOperation = "source-in";
      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx) : fillColor;
      maskCtx.fillRect(0, 0, width, height);
      maskCtx.restore();
      ctx.save();
      ctx.transform(...transform);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
      (_b = this.dependencyTracker) == null ? void 0 : _b.recordBBox(opIdx, ctx, 0, width, 0, height);
      ctx.restore();
    }
    this.compose();
    (_c = this.dependencyTracker) == null ? void 0 : _c.recordOperation(opIdx);
  }
  paintImageXObject(opIdx, objId) {
    if (!this.contentVisible) {
      return;
    }
    const imgData = this.getObject(opIdx, objId);
    if (!imgData) {
      warn("Dependent image isn't ready yet");
      return;
    }
    this.paintInlineImageXObject(opIdx, imgData);
  }
  paintImageXObjectRepeat(opIdx, objId, scaleX, scaleY, positions) {
    if (!this.contentVisible) {
      return;
    }
    const imgData = this.getObject(opIdx, objId);
    if (!imgData) {
      warn("Dependent image isn't ready yet");
      return;
    }
    const width = imgData.width;
    const height = imgData.height;
    const map = [];
    for (let i = 0, ii = positions.length; i < ii; i += 2) {
      map.push({
        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
        x: 0,
        y: 0,
        w: width,
        h: height
      });
    }
    this.paintInlineImageXObjectGroup(opIdx, imgData, map);
  }
  applyTransferMapsToCanvas(ctx) {
    if (this.current.transferMaps !== "none") {
      ctx.filter = this.current.transferMaps;
      ctx.drawImage(ctx.canvas, 0, 0);
      ctx.filter = "none";
    }
    return ctx.canvas;
  }
  applyTransferMapsToBitmap(imgData) {
    if (this.current.transferMaps === "none") {
      return imgData.bitmap;
    }
    const {
      bitmap,
      width,
      height
    } = imgData;
    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
    const tmpCtx = tmpCanvas.context;
    tmpCtx.filter = this.current.transferMaps;
    tmpCtx.drawImage(bitmap, 0, 0);
    tmpCtx.filter = "none";
    return tmpCanvas.canvas;
  }
  paintInlineImageXObject(opIdx, imgData) {
    var _a2;
    if (!this.contentVisible) {
      return;
    }
    const width = imgData.width;
    const height = imgData.height;
    const ctx = this.ctx;
    this.save(opIdx);
    const {
      filter
    } = ctx;
    if (filter !== "none" && filter !== "") {
      ctx.filter = "none";
    }
    ctx.scale(1 / width, -1 / height);
    let imgToPaint;
    if (imgData.bitmap) {
      imgToPaint = this.applyTransferMapsToBitmap(imgData);
    } else if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
      imgToPaint = imgData;
    } else {
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData);
      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
    }
    const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));
    ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.resetBBox(opIdx).recordBBox(opIdx, ctx, 0, width, -height, 0).recordDependencies(opIdx, Dependencies.imageXObject).recordOperation(opIdx);
    drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
    this.compose();
    this.restore(opIdx);
  }
  paintInlineImageXObjectGroup(opIdx, imgData, map) {
    var _a2, _b, _c;
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    let imgToPaint;
    if (imgData.bitmap) {
      imgToPaint = imgData.bitmap;
    } else {
      const w = imgData.width;
      const h = imgData.height;
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData);
      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
    }
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.resetBBox(opIdx);
    for (const entry of map) {
      ctx.save();
      ctx.transform(...entry.transform);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
      (_b = this.dependencyTracker) == null ? void 0 : _b.recordBBox(opIdx, ctx, 0, 1, -1, 0);
      ctx.restore();
    }
    (_c = this.dependencyTracker) == null ? void 0 : _c.recordOperation(opIdx);
    this.compose();
  }
  paintSolidColorImageMask(opIdx) {
    var _a2;
    if (!this.contentVisible) {
      return;
    }
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.resetBBox(opIdx).recordBBox(opIdx, this.ctx, 0, 1, 0, 1).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);
    this.ctx.fillRect(0, 0, 1, 1);
    this.compose();
  }
  markPoint(opIdx, tag) {
  }
  markPointProps(opIdx, tag, properties) {
  }
  beginMarkedContent(opIdx, tag) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.beginMarkedContent(opIdx);
    this.markedContentStack.push({
      visible: true
    });
  }
  beginMarkedContentProps(opIdx, tag, properties) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.beginMarkedContent(opIdx);
    if (tag === "OC") {
      this.markedContentStack.push({
        visible: this.optionalContentConfig.isVisible(properties)
      });
    } else {
      this.markedContentStack.push({
        visible: true
      });
    }
    this.contentVisible = this.isContentVisible();
  }
  endMarkedContent(opIdx) {
    var _a2;
    (_a2 = this.dependencyTracker) == null ? void 0 : _a2.endMarkedContent(opIdx);
    this.markedContentStack.pop();
    this.contentVisible = this.isContentVisible();
  }
  beginCompat(opIdx) {
  }
  endCompat(opIdx) {
  }
  consumePath(opIdx, path, clipBox) {
    var _a2, _b;
    const isEmpty = this.current.isEmptyClip();
    if (this.pendingClip) {
      this.current.updateClipFromPath();
    }
    if (!this.pendingClip) {
      this.compose(clipBox);
    }
    const ctx = this.ctx;
    if (this.pendingClip) {
      if (!isEmpty) {
        if (this.pendingClip === EO_CLIP) {
          ctx.clip(path, "evenodd");
        } else {
          ctx.clip(path);
        }
      }
      this.pendingClip = null;
      (_a2 = this.dependencyTracker) == null ? void 0 : _a2.bboxToClipBoxDropOperation(opIdx).recordFutureForcedDependency("clipPath", opIdx);
    } else {
      (_b = this.dependencyTracker) == null ? void 0 : _b.recordOperation(opIdx);
    }
    this.current.startNewPathAndClipBox(this.current.clipBox);
  }
  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const m = getCurrentTransform(this.ctx);
      if (m[1] === 0 && m[2] === 0) {
        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
      } else {
        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
        const normX = Math.hypot(m[0], m[2]);
        const normY = Math.hypot(m[1], m[3]);
        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
      }
    }
    return this._cachedGetSinglePixelWidth;
  }
  getScaleForStroking() {
    if (this._cachedScaleForStroking[0] === -1) {
      const {
        lineWidth
      } = this.current;
      const {
        a,
        b,
        c,
        d
      } = this.ctx.getTransform();
      let scaleX, scaleY;
      if (b === 0 && c === 0) {
        const normX = Math.abs(a);
        const normY = Math.abs(d);
        if (normX === normY) {
          if (lineWidth === 0) {
            scaleX = scaleY = 1 / normX;
          } else {
            const scaledLineWidth = normX * lineWidth;
            scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
          }
        } else if (lineWidth === 0) {
          scaleX = 1 / normX;
          scaleY = 1 / normY;
        } else {
          const scaledXLineWidth = normX * lineWidth;
          const scaledYLineWidth = normY * lineWidth;
          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
        }
      } else {
        const absDet = Math.abs(a * d - b * c);
        const normX = Math.hypot(a, b);
        const normY = Math.hypot(c, d);
        if (lineWidth === 0) {
          scaleX = normY / absDet;
          scaleY = normX / absDet;
        } else {
          const baseArea = lineWidth * absDet;
          scaleX = normY > baseArea ? normY / baseArea : 1;
          scaleY = normX > baseArea ? normX / baseArea : 1;
        }
      }
      this._cachedScaleForStroking[0] = scaleX;
      this._cachedScaleForStroking[1] = scaleY;
    }
    return this._cachedScaleForStroking;
  }
  rescaleAndStroke(path, saveRestore) {
    const {
      ctx,
      current: {
        lineWidth
      }
    } = this;
    const [scaleX, scaleY] = this.getScaleForStroking();
    if (scaleX === scaleY) {
      ctx.lineWidth = (lineWidth || 1) * scaleX;
      ctx.stroke(path);
      return;
    }
    const dashes = ctx.getLineDash();
    if (saveRestore) {
      ctx.save();
    }
    ctx.scale(scaleX, scaleY);
    SCALE_MATRIX.a = 1 / scaleX;
    SCALE_MATRIX.d = 1 / scaleY;
    const newPath = new Path2D();
    newPath.addPath(path, SCALE_MATRIX);
    if (dashes.length > 0) {
      const scale = Math.max(scaleX, scaleY);
      ctx.setLineDash(dashes.map((x) => x / scale));
      ctx.lineDashOffset /= scale;
    }
    ctx.lineWidth = lineWidth || 1;
    ctx.stroke(newPath);
    if (saveRestore) {
      ctx.restore();
    }
  }
  isContentVisible() {
    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
      if (!this.markedContentStack[i].visible) {
        return false;
      }
    }
    return true;
  }
};
_restoreInitialState = new WeakSet();
restoreInitialState_fn = function() {
  while (this.stateStack.length || this.inSMaskMode) {
    this.restore();
  }
  this.current.activeSMask = null;
  this.ctx.restore();
  if (this.transparentCanvas) {
    this.ctx = this.compositeCtx;
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.drawImage(this.transparentCanvas, 0, 0);
    this.ctx.restore();
    this.transparentCanvas = null;
  }
};
_drawFilter = new WeakSet();
drawFilter_fn = function() {
  if (this.pageColors) {
    const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
    if (hcmFilterId !== "none") {
      const savedFilter = this.ctx.filter;
      this.ctx.filter = hcmFilterId;
      this.ctx.drawImage(this.ctx.canvas, 0, 0);
      this.ctx.filter = savedFilter;
    }
  }
};
_getScaledPath = new WeakSet();
getScaledPath_fn = function(path, currentTransform, transform) {
  const newPath = new Path2D();
  newPath.addPath(path, new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform));
  return newPath;
};
var CanvasGraphics = _CanvasGraphics;
for (const op in OPS) {
  if (CanvasGraphics.prototype[op] !== void 0) {
    CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
  }
}
var _buffer, _view, _decoder, _readString, readString_fn;
var _CssFontInfo = class _CssFontInfo {
  constructor(buffer) {
    __privateAdd(this, _readString);
    __privateAdd(this, _buffer, void 0);
    __privateAdd(this, _view, void 0);
    __privateAdd(this, _decoder, void 0);
    __privateSet(this, _buffer, buffer);
    __privateSet(this, _view, new DataView(__privateGet(this, _buffer)));
    __privateSet(this, _decoder, new TextDecoder());
  }
  static write(info2) {
    const encoder = new TextEncoder();
    const encodedStrings = {};
    let stringsLength = 0;
    for (const prop of _CssFontInfo.strings) {
      const encoded = encoder.encode(info2[prop]);
      encodedStrings[prop] = encoded;
      stringsLength += 4 + encoded.length;
    }
    const buffer = new ArrayBuffer(stringsLength);
    const data = new Uint8Array(buffer);
    const view = new DataView(buffer);
    let offset = 0;
    for (const prop of _CssFontInfo.strings) {
      const encoded = encodedStrings[prop];
      const length = encoded.length;
      view.setUint32(offset, length);
      data.set(encoded, offset + 4);
      offset += 4 + length;
    }
    assert(offset === buffer.byteLength, "CssFontInfo.write: Buffer overflow");
    return buffer;
  }
  get fontFamily() {
    return __privateMethod(this, _readString, readString_fn).call(this, 0);
  }
  get fontWeight() {
    return __privateMethod(this, _readString, readString_fn).call(this, 1);
  }
  get italicAngle() {
    return __privateMethod(this, _readString, readString_fn).call(this, 2);
  }
};
_buffer = new WeakMap();
_view = new WeakMap();
_decoder = new WeakMap();
_readString = new WeakSet();
readString_fn = function(index) {
  assert(index < _CssFontInfo.strings.length, "Invalid string index");
  let offset = 0;
  for (let i = 0; i < index; i++) {
    offset += __privateGet(this, _view).getUint32(offset) + 4;
  }
  const length = __privateGet(this, _view).getUint32(offset);
  return __privateGet(this, _decoder).decode(new Uint8Array(__privateGet(this, _buffer), offset + 4, length));
};
__publicField(_CssFontInfo, "strings", ["fontFamily", "fontWeight", "italicAngle"]);
var CssFontInfo = _CssFontInfo;
var _buffer2, _view2, _decoder2, _readString2, readString_fn2;
var _SystemFontInfo = class _SystemFontInfo {
  constructor(buffer) {
    __privateAdd(this, _readString2);
    __privateAdd(this, _buffer2, void 0);
    __privateAdd(this, _view2, void 0);
    __privateAdd(this, _decoder2, void 0);
    __privateSet(this, _buffer2, buffer);
    __privateSet(this, _view2, new DataView(__privateGet(this, _buffer2)));
    __privateSet(this, _decoder2, new TextDecoder());
  }
  static write(info2) {
    const encoder = new TextEncoder();
    const encodedStrings = {};
    let stringsLength = 0;
    for (const prop of _SystemFontInfo.strings) {
      const encoded = encoder.encode(info2[prop]);
      encodedStrings[prop] = encoded;
      stringsLength += 4 + encoded.length;
    }
    stringsLength += 4;
    let encodedStyleStyle, encodedStyleWeight, lengthEstimate = 1 + stringsLength;
    if (info2.style) {
      encodedStyleStyle = encoder.encode(info2.style.style);
      encodedStyleWeight = encoder.encode(info2.style.weight);
      lengthEstimate += 4 + encodedStyleStyle.length + 4 + encodedStyleWeight.length;
    }
    const buffer = new ArrayBuffer(lengthEstimate);
    const data = new Uint8Array(buffer);
    const view = new DataView(buffer);
    let offset = 0;
    view.setUint8(offset++, info2.guessFallback ? 1 : 0);
    view.setUint32(offset, 0);
    offset += 4;
    stringsLength = 0;
    for (const prop of _SystemFontInfo.strings) {
      const encoded = encodedStrings[prop];
      const length = encoded.length;
      stringsLength += 4 + length;
      view.setUint32(offset, length);
      data.set(encoded, offset + 4);
      offset += 4 + length;
    }
    view.setUint32(offset - stringsLength - 4, stringsLength);
    if (info2.style) {
      view.setUint32(offset, encodedStyleStyle.length);
      data.set(encodedStyleStyle, offset + 4);
      offset += 4 + encodedStyleStyle.length;
      view.setUint32(offset, encodedStyleWeight.length);
      data.set(encodedStyleWeight, offset + 4);
      offset += 4 + encodedStyleWeight.length;
    }
    assert(offset <= buffer.byteLength, "SubstitionInfo.write: Buffer overflow");
    return buffer.transferToFixedLength(offset);
  }
  get guessFallback() {
    return __privateGet(this, _view2).getUint8(0) !== 0;
  }
  get css() {
    return __privateMethod(this, _readString2, readString_fn2).call(this, 0);
  }
  get loadedName() {
    return __privateMethod(this, _readString2, readString_fn2).call(this, 1);
  }
  get baseFontName() {
    return __privateMethod(this, _readString2, readString_fn2).call(this, 2);
  }
  get src() {
    return __privateMethod(this, _readString2, readString_fn2).call(this, 3);
  }
  get style() {
    let offset = 1;
    offset += 4 + __privateGet(this, _view2).getUint32(offset);
    const styleLength = __privateGet(this, _view2).getUint32(offset);
    const style = __privateGet(this, _decoder2).decode(new Uint8Array(__privateGet(this, _buffer2), offset + 4, styleLength));
    offset += 4 + styleLength;
    const weightLength = __privateGet(this, _view2).getUint32(offset);
    const weight = __privateGet(this, _decoder2).decode(new Uint8Array(__privateGet(this, _buffer2), offset + 4, weightLength));
    return {
      style,
      weight
    };
  }
};
_buffer2 = new WeakMap();
_view2 = new WeakMap();
_decoder2 = new WeakMap();
_readString2 = new WeakSet();
readString_fn2 = function(index) {
  assert(index < _SystemFontInfo.strings.length, "Invalid string index");
  let offset = 5;
  for (let i = 0; i < index; i++) {
    offset += __privateGet(this, _view2).getUint32(offset) + 4;
  }
  const length = __privateGet(this, _view2).getUint32(offset);
  return __privateGet(this, _decoder2).decode(new Uint8Array(__privateGet(this, _buffer2), offset + 4, length));
};
__publicField(_SystemFontInfo, "strings", ["css", "loadedName", "baseFontName", "src"]);
var SystemFontInfo = _SystemFontInfo;
var _OFFSET_NUMBERS, _OFFSET_BBOX, _OFFSET_FONT_MATRIX, _OFFSET_DEFAULT_VMETRICS, _OFFSET_STRINGS, _buffer3, _decoder3, _view3, _readBoolean, readBoolean_fn, _readNumber, readNumber_fn, _readString3, readString_fn3;
var _FontInfo = class _FontInfo {
  constructor({
    data,
    extra
  }) {
    __privateAdd(this, _readBoolean);
    __privateAdd(this, _readNumber);
    __privateAdd(this, _readString3);
    __privateAdd(this, _buffer3, void 0);
    __privateAdd(this, _decoder3, void 0);
    __privateAdd(this, _view3, void 0);
    __privateSet(this, _buffer3, data);
    __privateSet(this, _decoder3, new TextDecoder());
    __privateSet(this, _view3, new DataView(__privateGet(this, _buffer3)));
    if (extra) {
      Object.assign(this, extra);
    }
  }
  get black() {
    return __privateMethod(this, _readBoolean, readBoolean_fn).call(this, 0);
  }
  get bold() {
    return __privateMethod(this, _readBoolean, readBoolean_fn).call(this, 1);
  }
  get disableFontFace() {
    return __privateMethod(this, _readBoolean, readBoolean_fn).call(this, 2);
  }
  get fontExtraProperties() {
    return __privateMethod(this, _readBoolean, readBoolean_fn).call(this, 3);
  }
  get isInvalidPDFjsFont() {
    return __privateMethod(this, _readBoolean, readBoolean_fn).call(this, 4);
  }
  get isType3Font() {
    return __privateMethod(this, _readBoolean, readBoolean_fn).call(this, 5);
  }
  get italic() {
    return __privateMethod(this, _readBoolean, readBoolean_fn).call(this, 6);
  }
  get missingFile() {
    return __privateMethod(this, _readBoolean, readBoolean_fn).call(this, 7);
  }
  get remeasure() {
    return __privateMethod(this, _readBoolean, readBoolean_fn).call(this, 8);
  }
  get vertical() {
    return __privateMethod(this, _readBoolean, readBoolean_fn).call(this, 9);
  }
  get ascent() {
    return __privateMethod(this, _readNumber, readNumber_fn).call(this, 0);
  }
  get defaultWidth() {
    return __privateMethod(this, _readNumber, readNumber_fn).call(this, 1);
  }
  get descent() {
    return __privateMethod(this, _readNumber, readNumber_fn).call(this, 2);
  }
  get bbox() {
    let offset = __privateGet(_FontInfo, _OFFSET_BBOX);
    const numCoords = __privateGet(this, _view3).getUint8(offset);
    if (numCoords === 0) {
      return void 0;
    }
    offset += 1;
    const bbox = [];
    for (let i = 0; i < 4; i++) {
      bbox.push(__privateGet(this, _view3).getInt16(offset, true));
      offset += 2;
    }
    return bbox;
  }
  get fontMatrix() {
    let offset = __privateGet(_FontInfo, _OFFSET_FONT_MATRIX);
    const numPoints = __privateGet(this, _view3).getUint8(offset);
    if (numPoints === 0) {
      return void 0;
    }
    offset += 1;
    const fontMatrix = [];
    for (let i = 0; i < 6; i++) {
      fontMatrix.push(__privateGet(this, _view3).getFloat64(offset, true));
      offset += 8;
    }
    return fontMatrix;
  }
  get defaultVMetrics() {
    let offset = __privateGet(_FontInfo, _OFFSET_DEFAULT_VMETRICS);
    const numMetrics = __privateGet(this, _view3).getUint8(offset);
    if (numMetrics === 0) {
      return void 0;
    }
    offset += 1;
    const defaultVMetrics = [];
    for (let i = 0; i < 3; i++) {
      defaultVMetrics.push(__privateGet(this, _view3).getInt16(offset, true));
      offset += 2;
    }
    return defaultVMetrics;
  }
  get fallbackName() {
    return __privateMethod(this, _readString3, readString_fn3).call(this, 0);
  }
  get loadedName() {
    return __privateMethod(this, _readString3, readString_fn3).call(this, 1);
  }
  get mimetype() {
    return __privateMethod(this, _readString3, readString_fn3).call(this, 2);
  }
  get name() {
    return __privateMethod(this, _readString3, readString_fn3).call(this, 3);
  }
  get data() {
    let offset = __privateGet(_FontInfo, _OFFSET_STRINGS);
    const stringsLength = __privateGet(this, _view3).getUint32(offset);
    offset += 4 + stringsLength;
    const systemFontInfoLength = __privateGet(this, _view3).getUint32(offset);
    offset += 4 + systemFontInfoLength;
    const cssFontInfoLength = __privateGet(this, _view3).getUint32(offset);
    offset += 4 + cssFontInfoLength;
    const length = __privateGet(this, _view3).getUint32(offset);
    if (length === 0) {
      return void 0;
    }
    return new Uint8Array(__privateGet(this, _buffer3), offset + 4, length);
  }
  clearData() {
    let offset = __privateGet(_FontInfo, _OFFSET_STRINGS);
    const stringsLength = __privateGet(this, _view3).getUint32(offset);
    offset += 4 + stringsLength;
    const systemFontInfoLength = __privateGet(this, _view3).getUint32(offset);
    offset += 4 + systemFontInfoLength;
    const cssFontInfoLength = __privateGet(this, _view3).getUint32(offset);
    offset += 4 + cssFontInfoLength;
    const length = __privateGet(this, _view3).getUint32(offset);
    const data = new Uint8Array(__privateGet(this, _buffer3), offset + 4, length);
    data.fill(0);
    __privateGet(this, _view3).setUint32(offset, 0);
  }
  get cssFontInfo() {
    let offset = __privateGet(_FontInfo, _OFFSET_STRINGS);
    const stringsLength = __privateGet(this, _view3).getUint32(offset);
    offset += 4 + stringsLength;
    const systemFontInfoLength = __privateGet(this, _view3).getUint32(offset);
    offset += 4 + systemFontInfoLength;
    const cssFontInfoLength = __privateGet(this, _view3).getUint32(offset);
    if (cssFontInfoLength === 0) {
      return null;
    }
    const cssFontInfoData = new Uint8Array(cssFontInfoLength);
    cssFontInfoData.set(new Uint8Array(__privateGet(this, _buffer3), offset + 4, cssFontInfoLength));
    return new CssFontInfo(cssFontInfoData.buffer);
  }
  get systemFontInfo() {
    let offset = __privateGet(_FontInfo, _OFFSET_STRINGS);
    const stringsLength = __privateGet(this, _view3).getUint32(offset);
    offset += 4 + stringsLength;
    const systemFontInfoLength = __privateGet(this, _view3).getUint32(offset);
    if (systemFontInfoLength === 0) {
      return null;
    }
    const systemFontInfoData = new Uint8Array(systemFontInfoLength);
    systemFontInfoData.set(new Uint8Array(__privateGet(this, _buffer3), offset + 4, systemFontInfoLength));
    return new SystemFontInfo(systemFontInfoData.buffer);
  }
  static write(font) {
    const systemFontInfoBuffer = font.systemFontInfo ? SystemFontInfo.write(font.systemFontInfo) : null;
    const cssFontInfoBuffer = font.cssFontInfo ? CssFontInfo.write(font.cssFontInfo) : null;
    const encoder = new TextEncoder();
    const encodedStrings = {};
    let stringsLength = 0;
    for (const prop of _FontInfo.strings) {
      encodedStrings[prop] = encoder.encode(font[prop]);
      stringsLength += 4 + encodedStrings[prop].length;
    }
    const lengthEstimate = __privateGet(_FontInfo, _OFFSET_STRINGS) + 4 + stringsLength + 4 + (systemFontInfoBuffer ? systemFontInfoBuffer.byteLength : 0) + 4 + (cssFontInfoBuffer ? cssFontInfoBuffer.byteLength : 0) + 4 + (font.data ? font.data.length : 0);
    const buffer = new ArrayBuffer(lengthEstimate);
    const data = new Uint8Array(buffer);
    const view = new DataView(buffer);
    let offset = 0;
    const numBools = _FontInfo.bools.length;
    let boolByte = 0, boolBit = 0;
    for (let i = 0; i < numBools; i++) {
      const value = font[_FontInfo.bools[i]];
      const bits = value === void 0 ? 0 : value ? 2 : 1;
      boolByte |= bits << boolBit;
      boolBit += 2;
      if (boolBit === 8 || i === numBools - 1) {
        view.setUint8(offset++, boolByte);
        boolByte = 0;
        boolBit = 0;
      }
    }
    assert(offset === __privateGet(_FontInfo, _OFFSET_NUMBERS), "FontInfo.write: Boolean properties offset mismatch");
    for (const prop of _FontInfo.numbers) {
      view.setFloat64(offset, font[prop]);
      offset += 8;
    }
    assert(offset === __privateGet(_FontInfo, _OFFSET_BBOX), "FontInfo.write: Number properties offset mismatch");
    if (font.bbox) {
      view.setUint8(offset++, 4);
      for (const coord of font.bbox) {
        view.setInt16(offset, coord, true);
        offset += 2;
      }
    } else {
      view.setUint8(offset++, 0);
      offset += 2 * 4;
    }
    assert(offset === __privateGet(_FontInfo, _OFFSET_FONT_MATRIX), "FontInfo.write: BBox properties offset mismatch");
    if (font.fontMatrix) {
      view.setUint8(offset++, 6);
      for (const point of font.fontMatrix) {
        view.setFloat64(offset, point, true);
        offset += 8;
      }
    } else {
      view.setUint8(offset++, 0);
      offset += 8 * 6;
    }
    assert(offset === __privateGet(_FontInfo, _OFFSET_DEFAULT_VMETRICS), "FontInfo.write: FontMatrix properties offset mismatch");
    if (font.defaultVMetrics) {
      view.setUint8(offset++, 1);
      for (const metric of font.defaultVMetrics) {
        view.setInt16(offset, metric, true);
        offset += 2;
      }
    } else {
      view.setUint8(offset++, 0);
      offset += 3 * 2;
    }
    assert(offset === __privateGet(_FontInfo, _OFFSET_STRINGS), "FontInfo.write: DefaultVMetrics properties offset mismatch");
    view.setUint32(__privateGet(_FontInfo, _OFFSET_STRINGS), 0);
    offset += 4;
    for (const prop of _FontInfo.strings) {
      const encoded = encodedStrings[prop];
      const length = encoded.length;
      view.setUint32(offset, length);
      data.set(encoded, offset + 4);
      offset += 4 + length;
    }
    view.setUint32(__privateGet(_FontInfo, _OFFSET_STRINGS), offset - __privateGet(_FontInfo, _OFFSET_STRINGS) - 4);
    if (!systemFontInfoBuffer) {
      view.setUint32(offset, 0);
      offset += 4;
    } else {
      const length = systemFontInfoBuffer.byteLength;
      view.setUint32(offset, length);
      assert(offset + 4 + length <= buffer.byteLength, "FontInfo.write: Buffer overflow at systemFontInfo");
      data.set(new Uint8Array(systemFontInfoBuffer), offset + 4);
      offset += 4 + length;
    }
    if (!cssFontInfoBuffer) {
      view.setUint32(offset, 0);
      offset += 4;
    } else {
      const length = cssFontInfoBuffer.byteLength;
      view.setUint32(offset, length);
      assert(offset + 4 + length <= buffer.byteLength, "FontInfo.write: Buffer overflow at cssFontInfo");
      data.set(new Uint8Array(cssFontInfoBuffer), offset + 4);
      offset += 4 + length;
    }
    if (font.data === void 0) {
      view.setUint32(offset, 0);
      offset += 4;
    } else {
      view.setUint32(offset, font.data.length);
      data.set(font.data, offset + 4);
      offset += 4 + font.data.length;
    }
    assert(offset <= buffer.byteLength, "FontInfo.write: Buffer overflow");
    return buffer.transferToFixedLength(offset);
  }
};
_OFFSET_NUMBERS = new WeakMap();
_OFFSET_BBOX = new WeakMap();
_OFFSET_FONT_MATRIX = new WeakMap();
_OFFSET_DEFAULT_VMETRICS = new WeakMap();
_OFFSET_STRINGS = new WeakMap();
_buffer3 = new WeakMap();
_decoder3 = new WeakMap();
_view3 = new WeakMap();
_readBoolean = new WeakSet();
readBoolean_fn = function(index) {
  assert(index < _FontInfo.bools.length, "Invalid boolean index");
  const byteOffset = Math.floor(index / 4);
  const bitOffset = index * 2 % 8;
  const value = __privateGet(this, _view3).getUint8(byteOffset) >> bitOffset & 3;
  return value === 0 ? void 0 : value === 2;
};
_readNumber = new WeakSet();
readNumber_fn = function(index) {
  assert(index < _FontInfo.numbers.length, "Invalid number index");
  return __privateGet(this, _view3).getFloat64(__privateGet(_FontInfo, _OFFSET_NUMBERS) + index * 8);
};
_readString3 = new WeakSet();
readString_fn3 = function(index) {
  assert(index < _FontInfo.strings.length, "Invalid string index");
  let offset = __privateGet(_FontInfo, _OFFSET_STRINGS) + 4;
  for (let i = 0; i < index; i++) {
    offset += __privateGet(this, _view3).getUint32(offset) + 4;
  }
  const length = __privateGet(this, _view3).getUint32(offset);
  const stringData = new Uint8Array(length);
  stringData.set(new Uint8Array(__privateGet(this, _buffer3), offset + 4, length));
  return __privateGet(this, _decoder3).decode(stringData);
};
__publicField(_FontInfo, "bools", ["black", "bold", "disableFontFace", "fontExtraProperties", "isInvalidPDFjsFont", "isType3Font", "italic", "missingFile", "remeasure", "vertical"]);
__publicField(_FontInfo, "numbers", ["ascent", "defaultWidth", "descent"]);
__publicField(_FontInfo, "strings", ["fallbackName", "loadedName", "mimetype", "name"]);
__privateAdd(_FontInfo, _OFFSET_NUMBERS, Math.ceil(_FontInfo.bools.length * 2 / 8));
__privateAdd(_FontInfo, _OFFSET_BBOX, __privateGet(_FontInfo, _OFFSET_NUMBERS) + _FontInfo.numbers.length * 8);
__privateAdd(_FontInfo, _OFFSET_FONT_MATRIX, __privateGet(_FontInfo, _OFFSET_BBOX) + 1 + 2 * 4);
__privateAdd(_FontInfo, _OFFSET_DEFAULT_VMETRICS, __privateGet(_FontInfo, _OFFSET_FONT_MATRIX) + 1 + 8 * 6);
__privateAdd(_FontInfo, _OFFSET_STRINGS, __privateGet(_FontInfo, _OFFSET_DEFAULT_VMETRICS) + 1 + 2 * 3);
var FontInfo = _FontInfo;
var _port, _src;
var GlobalWorkerOptions = class {
  static get workerPort() {
    return __privateGet(this, _port);
  }
  static set workerPort(val) {
    if (!(typeof Worker !== "undefined" && val instanceof Worker) && val !== null) {
      throw new Error("Invalid `workerPort` type.");
    }
    __privateSet(this, _port, val);
  }
  static get workerSrc() {
    return __privateGet(this, _src);
  }
  static set workerSrc(val) {
    if (typeof val !== "string") {
      throw new Error("Invalid `workerSrc` type.");
    }
    __privateSet(this, _src, val);
  }
};
_port = new WeakMap();
_src = new WeakMap();
__privateAdd(GlobalWorkerOptions, _port, null);
__privateAdd(GlobalWorkerOptions, _src, "");
var _map, _data;
var Metadata = class {
  constructor({
    parsedData,
    rawData
  }) {
    __privateAdd(this, _map, void 0);
    __privateAdd(this, _data, void 0);
    __privateSet(this, _map, parsedData);
    __privateSet(this, _data, rawData);
  }
  getRaw() {
    return __privateGet(this, _data);
  }
  get(name) {
    return __privateGet(this, _map).get(name) ?? null;
  }
  [Symbol.iterator]() {
    return __privateGet(this, _map).entries();
  }
};
_map = new WeakMap();
_data = new WeakMap();
var INTERNAL = Symbol("INTERNAL");
var _isDisplay, _isPrint, _userSet, _visible;
var OptionalContentGroup = class {
  constructor(renderingIntent, {
    name,
    intent,
    usage,
    rbGroups
  }) {
    __privateAdd(this, _isDisplay, false);
    __privateAdd(this, _isPrint, false);
    __privateAdd(this, _userSet, false);
    __privateAdd(this, _visible, true);
    __privateSet(this, _isDisplay, !!(renderingIntent & RenderingIntentFlag.DISPLAY));
    __privateSet(this, _isPrint, !!(renderingIntent & RenderingIntentFlag.PRINT));
    this.name = name;
    this.intent = intent;
    this.usage = usage;
    this.rbGroups = rbGroups;
  }
  get visible() {
    if (__privateGet(this, _userSet)) {
      return __privateGet(this, _visible);
    }
    if (!__privateGet(this, _visible)) {
      return false;
    }
    const {
      print,
      view
    } = this.usage;
    if (__privateGet(this, _isDisplay)) {
      return (view == null ? void 0 : view.viewState) !== "OFF";
    } else if (__privateGet(this, _isPrint)) {
      return (print == null ? void 0 : print.printState) !== "OFF";
    }
    return true;
  }
  _setVisible(internal, visible, userSet = false) {
    if (internal !== INTERNAL) {
      unreachable("Internal method `_setVisible` called.");
    }
    __privateSet(this, _userSet, userSet);
    __privateSet(this, _visible, visible);
  }
};
_isDisplay = new WeakMap();
_isPrint = new WeakMap();
_userSet = new WeakMap();
_visible = new WeakMap();
var _cachedGetHash, _groups, _initialHash, _order, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn;
var OptionalContentConfig = class {
  constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY) {
    __privateAdd(this, _evaluateVisibilityExpression);
    __privateAdd(this, _cachedGetHash, null);
    __privateAdd(this, _groups, /* @__PURE__ */ new Map());
    __privateAdd(this, _initialHash, null);
    __privateAdd(this, _order, null);
    this.renderingIntent = renderingIntent;
    this.name = null;
    this.creator = null;
    if (data === null) {
      return;
    }
    this.name = data.name;
    this.creator = data.creator;
    __privateSet(this, _order, data.order);
    for (const group of data.groups) {
      __privateGet(this, _groups).set(group.id, new OptionalContentGroup(renderingIntent, group));
    }
    if (data.baseState === "OFF") {
      for (const group of __privateGet(this, _groups).values()) {
        group._setVisible(INTERNAL, false);
      }
    }
    for (const on of data.on) {
      __privateGet(this, _groups).get(on)._setVisible(INTERNAL, true);
    }
    for (const off of data.off) {
      __privateGet(this, _groups).get(off)._setVisible(INTERNAL, false);
    }
    __privateSet(this, _initialHash, this.getHash());
  }
  isVisible(group) {
    if (__privateGet(this, _groups).size === 0) {
      return true;
    }
    if (!group) {
      info("Optional content group not defined.");
      return true;
    }
    if (group.type === "OCG") {
      if (!__privateGet(this, _groups).has(group.id)) {
        warn(`Optional content group not found: ${group.id}`);
        return true;
      }
      return __privateGet(this, _groups).get(group.id).visible;
    } else if (group.type === "OCMD") {
      if (group.expression) {
        return __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, group.expression);
      }
      if (!group.policy || group.policy === "AnyOn") {
        for (const id of group.ids) {
          if (!__privateGet(this, _groups).has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (__privateGet(this, _groups).get(id).visible) {
            return true;
          }
        }
        return false;
      } else if (group.policy === "AllOn") {
        for (const id of group.ids) {
          if (!__privateGet(this, _groups).has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (!__privateGet(this, _groups).get(id).visible) {
            return false;
          }
        }
        return true;
      } else if (group.policy === "AnyOff") {
        for (const id of group.ids) {
          if (!__privateGet(this, _groups).has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (!__privateGet(this, _groups).get(id).visible) {
            return true;
          }
        }
        return false;
      } else if (group.policy === "AllOff") {
        for (const id of group.ids) {
          if (!__privateGet(this, _groups).has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (__privateGet(this, _groups).get(id).visible) {
            return false;
          }
        }
        return true;
      }
      warn(`Unknown optional content policy ${group.policy}.`);
      return true;
    }
    warn(`Unknown group type ${group.type}.`);
    return true;
  }
  setVisibility(id, visible = true, preserveRB = true) {
    var _a2;
    const group = __privateGet(this, _groups).get(id);
    if (!group) {
      warn(`Optional content group not found: ${id}`);
      return;
    }
    if (preserveRB && visible && group.rbGroups.length) {
      for (const rbGroup of group.rbGroups) {
        for (const otherId of rbGroup) {
          if (otherId !== id) {
            (_a2 = __privateGet(this, _groups).get(otherId)) == null ? void 0 : _a2._setVisible(INTERNAL, false, true);
          }
        }
      }
    }
    group._setVisible(INTERNAL, !!visible, true);
    __privateSet(this, _cachedGetHash, null);
  }
  setOCGState({
    state,
    preserveRB
  }) {
    let operator;
    for (const elem of state) {
      switch (elem) {
        case "ON":
        case "OFF":
        case "Toggle":
          operator = elem;
          continue;
      }
      const group = __privateGet(this, _groups).get(elem);
      if (!group) {
        continue;
      }
      switch (operator) {
        case "ON":
          this.setVisibility(elem, true, preserveRB);
          break;
        case "OFF":
          this.setVisibility(elem, false, preserveRB);
          break;
        case "Toggle":
          this.setVisibility(elem, !group.visible, preserveRB);
          break;
      }
    }
    __privateSet(this, _cachedGetHash, null);
  }
  get hasInitialVisibility() {
    return __privateGet(this, _initialHash) === null || this.getHash() === __privateGet(this, _initialHash);
  }
  getOrder() {
    if (!__privateGet(this, _groups).size) {
      return null;
    }
    if (__privateGet(this, _order)) {
      return __privateGet(this, _order).slice();
    }
    return [...__privateGet(this, _groups).keys()];
  }
  getGroup(id) {
    return __privateGet(this, _groups).get(id) || null;
  }
  getHash() {
    if (__privateGet(this, _cachedGetHash) !== null) {
      return __privateGet(this, _cachedGetHash);
    }
    const hash = new MurmurHash3_64();
    for (const [id, group] of __privateGet(this, _groups)) {
      hash.update(`${id}:${group.visible}`);
    }
    return __privateSet(this, _cachedGetHash, hash.hexdigest());
  }
  [Symbol.iterator]() {
    return __privateGet(this, _groups).entries();
  }
};
_cachedGetHash = new WeakMap();
_groups = new WeakMap();
_initialHash = new WeakMap();
_order = new WeakMap();
_evaluateVisibilityExpression = new WeakSet();
evaluateVisibilityExpression_fn = function(array) {
  const length = array.length;
  if (length < 2) {
    return true;
  }
  const operator = array[0];
  for (let i = 1; i < length; i++) {
    const element = array[i];
    let state;
    if (Array.isArray(element)) {
      state = __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, element);
    } else if (__privateGet(this, _groups).has(element)) {
      state = __privateGet(this, _groups).get(element).visible;
    } else {
      warn(`Optional content group not found: ${element}`);
      return true;
    }
    switch (operator) {
      case "And":
        if (!state) {
          return false;
        }
        break;
      case "Or":
        if (state) {
          return true;
        }
        break;
      case "Not":
        return !state;
      default:
        return true;
    }
  }
  return operator === "And";
};
var PDFDataTransportStream = class {
  constructor(pdfDataRangeTransport, {
    disableRange = false,
    disableStream = false
  }) {
    assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    const {
      length,
      initialData,
      progressiveDone,
      contentDispositionFilename
    } = pdfDataRangeTransport;
    this._queuedChunks = [];
    this._progressiveDone = progressiveDone;
    this._contentDispositionFilename = contentDispositionFilename;
    if ((initialData == null ? void 0 : initialData.length) > 0) {
      const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;
      this._queuedChunks.push(buffer);
    }
    this._pdfDataRangeTransport = pdfDataRangeTransport;
    this._isStreamingSupported = !disableStream;
    this._isRangeSupported = !disableRange;
    this._contentLength = length;
    this._fullRequestReader = null;
    this._rangeReaders = [];
    pdfDataRangeTransport.addRangeListener((begin, chunk) => {
      this._onReceiveData({
        begin,
        chunk
      });
    });
    pdfDataRangeTransport.addProgressListener((loaded, total) => {
      this._onProgress({
        loaded,
        total
      });
    });
    pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
      this._onReceiveData({
        chunk
      });
    });
    pdfDataRangeTransport.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    });
    pdfDataRangeTransport.transportReady();
  }
  _onReceiveData({
    begin,
    chunk
  }) {
    const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;
    if (begin === void 0) {
      if (this._fullRequestReader) {
        this._fullRequestReader._enqueue(buffer);
      } else {
        this._queuedChunks.push(buffer);
      }
    } else {
      const found = this._rangeReaders.some(function(rangeReader) {
        if (rangeReader._begin !== begin) {
          return false;
        }
        rangeReader._enqueue(buffer);
        return true;
      });
      assert(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }
  get _progressiveDataLength() {
    var _a2;
    return ((_a2 = this._fullRequestReader) == null ? void 0 : _a2._loaded) ?? 0;
  }
  _onProgress(evt) {
    var _a2, _b, _c, _d;
    if (evt.total === void 0) {
      (_b = (_a2 = this._rangeReaders[0]) == null ? void 0 : _a2.onProgress) == null ? void 0 : _b.call(_a2, {
        loaded: evt.loaded
      });
    } else {
      (_d = (_c = this._fullRequestReader) == null ? void 0 : _c.onProgress) == null ? void 0 : _d.call(_c, {
        loaded: evt.loaded,
        total: evt.total
      });
    }
  }
  _onProgressiveDone() {
    var _a2;
    (_a2 = this._fullRequestReader) == null ? void 0 : _a2.progressiveDone();
    this._progressiveDone = true;
  }
  _removeRangeReader(reader) {
    const i = this._rangeReaders.indexOf(reader);
    if (i >= 0) {
      this._rangeReaders.splice(i, 1);
    }
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const queuedChunks = this._queuedChunks;
    this._queuedChunks = null;
    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
  }
  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
    this._pdfDataRangeTransport.requestDataRange(begin, end);
    this._rangeReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    var _a2;
    (_a2 = this._fullRequestReader) == null ? void 0 : _a2.cancel(reason);
    for (const reader of this._rangeReaders.slice(0)) {
      reader.cancel(reason);
    }
    this._pdfDataRangeTransport.abort();
  }
};
var PDFDataTransportStreamReader = class {
  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
    this._stream = stream;
    this._done = progressiveDone || false;
    this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;
    this._queuedChunks = queuedChunks || [];
    this._loaded = 0;
    for (const chunk of this._queuedChunks) {
      this._loaded += chunk.byteLength;
    }
    this._requests = [];
    this._headersReady = Promise.resolve();
    stream._fullRequestReader = this;
    this.onProgress = null;
  }
  _enqueue(chunk) {
    if (this._done) {
      return;
    }
    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();
      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunks.push(chunk);
    }
    this._loaded += chunk.byteLength;
  }
  get headersReady() {
    return this._headersReady;
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }
  get contentLength() {
    return this._stream._contentLength;
  }
  async read() {
    if (this._queuedChunks.length > 0) {
      const chunk = this._queuedChunks.shift();
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
  }
  progressiveDone() {
    if (this._done) {
      return;
    }
    this._done = true;
  }
};
var PDFDataTransportStreamRangeReader = class {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._begin = begin;
    this._end = end;
    this._queuedChunk = null;
    this._requests = [];
    this._done = false;
    this.onProgress = null;
  }
  _enqueue(chunk) {
    if (this._done) {
      return;
    }
    if (this._requests.length === 0) {
      this._queuedChunk = chunk;
    } else {
      const requestsCapability = this._requests.shift();
      requestsCapability.resolve({
        value: chunk,
        done: false
      });
      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: void 0,
          done: true
        });
      }
      this._requests.length = 0;
    }
    this._done = true;
    this._stream._removeRangeReader(this);
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._queuedChunk) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    this._stream._removeRangeReader(this);
  }
};
function getFilenameFromContentDispositionHeader(contentDisposition) {
  let needsEncodingFixup = true;
  let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = unescape(filename);
    filename = rfc5987decode(filename);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  tmp = rfc2231getparam(contentDisposition);
  if (tmp) {
    const filename = rfc2047decode(tmp);
    return fixupEncoding(filename);
  }
  tmp = toParamRegExp("filename", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  function toParamRegExp(attributePattern, flags) {
    return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
  }
  function textdecode(encoding, value) {
    if (encoding) {
      if (!/^[\x00-\xFF]+$/.test(value)) {
        return value;
      }
      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = stringToBytes(value);
        value = decoder.decode(buffer);
        needsEncodingFixup = false;
      } catch {
      }
    }
    return value;
  }
  function fixupEncoding(value) {
    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
      value = textdecode("utf-8", value);
      if (needsEncodingFixup) {
        value = textdecode("iso-8859-1", value);
      }
    }
    return value;
  }
  function rfc2231getparam(contentDispositionStr) {
    const matches = [];
    let match;
    const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
    while ((match = iter.exec(contentDispositionStr)) !== null) {
      let [, n, quot, part] = match;
      n = parseInt(n, 10);
      if (n in matches) {
        if (n === 0) {
          break;
        }
        continue;
      }
      matches[n] = [quot, part];
    }
    const parts = [];
    for (let n = 0; n < matches.length; ++n) {
      if (!(n in matches)) {
        break;
      }
      let [quot, part] = matches[n];
      part = rfc2616unquote(part);
      if (quot) {
        part = unescape(part);
        if (n === 0) {
          part = rfc5987decode(part);
        }
      }
      parts.push(part);
    }
    return parts.join("");
  }
  function rfc2616unquote(value) {
    if (value.startsWith('"')) {
      const parts = value.slice(1).split('\\"');
      for (let i = 0; i < parts.length; ++i) {
        const quotindex = parts[i].indexOf('"');
        if (quotindex !== -1) {
          parts[i] = parts[i].slice(0, quotindex);
          parts.length = i + 1;
        }
        parts[i] = parts[i].replaceAll(/\\(.)/g, "$1");
      }
      value = parts.join('"');
    }
    return value;
  }
  function rfc5987decode(extvalue) {
    const encodingend = extvalue.indexOf("'");
    if (encodingend === -1) {
      return extvalue;
    }
    const encoding = extvalue.slice(0, encodingend);
    const langvalue = extvalue.slice(encodingend + 1);
    const value = langvalue.replace(/^[^']*'/, "");
    return textdecode(encoding, value);
  }
  function rfc2047decode(value) {
    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
      return value;
    }
    return value.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
      if (encoding === "q" || encoding === "Q") {
        text = text.replaceAll("_", " ");
        text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {
          return String.fromCharCode(parseInt(hex, 16));
        });
        return textdecode(charset, text);
      }
      try {
        text = atob(text);
      } catch {
      }
      return textdecode(charset, text);
    });
  }
  return "";
}
function createHeaders(isHttp, httpHeaders) {
  const headers = new Headers();
  if (!isHttp || !httpHeaders || typeof httpHeaders !== "object") {
    return headers;
  }
  for (const key in httpHeaders) {
    const val = httpHeaders[key];
    if (val !== void 0) {
      headers.append(key, val);
    }
  }
  return headers;
}
function getResponseOrigin(url) {
  var _a2;
  return ((_a2 = URL.parse(url)) == null ? void 0 : _a2.origin) ?? null;
}
function validateRangeRequestCapabilities({
  responseHeaders,
  isHttp,
  rangeChunkSize,
  disableRange
}) {
  const returnValues = {
    allowRangeRequests: false,
    suggestedLength: void 0
  };
  const length = parseInt(responseHeaders.get("Content-Length"), 10);
  if (!Number.isInteger(length)) {
    return returnValues;
  }
  returnValues.suggestedLength = length;
  if (length <= 2 * rangeChunkSize) {
    return returnValues;
  }
  if (disableRange || !isHttp) {
    return returnValues;
  }
  if (responseHeaders.get("Accept-Ranges") !== "bytes") {
    return returnValues;
  }
  const contentEncoding = responseHeaders.get("Content-Encoding") || "identity";
  if (contentEncoding !== "identity") {
    return returnValues;
  }
  returnValues.allowRangeRequests = true;
  return returnValues;
}
function extractFilenameFromHeader(responseHeaders) {
  const contentDisposition = responseHeaders.get("Content-Disposition");
  if (contentDisposition) {
    let filename = getFilenameFromContentDispositionHeader(contentDisposition);
    if (filename.includes("%")) {
      try {
        filename = decodeURIComponent(filename);
      } catch {
      }
    }
    if (isPdfFile(filename)) {
      return filename;
    }
  }
  return null;
}
function createResponseError(status, url) {
  return new ResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status, status === 404 || status === 0 && url.startsWith("file:"));
}
function validateResponseStatus(status) {
  return status === 200 || status === 206;
}
function createFetchOptions(headers, withCredentials, abortController) {
  return {
    method: "GET",
    headers,
    signal: abortController.signal,
    mode: "cors",
    credentials: withCredentials ? "include" : "same-origin",
    redirect: "follow"
  };
}
function getArrayBuffer(val) {
  if (val instanceof Uint8Array) {
    return val.buffer;
  }
  if (val instanceof ArrayBuffer) {
    return val;
  }
  warn(`getArrayBuffer - unexpected data format: ${val}`);
  return new Uint8Array(val).buffer;
}
var PDFFetchStream = class {
  constructor(source) {
    __publicField(this, "_responseOrigin", null);
    this.source = source;
    this.isHttp = /^https?:/i.test(source.url);
    this.headers = createHeaders(this.isHttp, source.httpHeaders);
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var _a2;
    return ((_a2 = this._fullRequestReader) == null ? void 0 : _a2._loaded) ?? 0;
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFFetchStreamReader(this);
    return this._fullRequestReader;
  }
  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const reader = new PDFFetchStreamRangeReader(this, begin, end);
    this._rangeRequestReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    var _a2;
    (_a2 = this._fullRequestReader) == null ? void 0 : _a2.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
};
var PDFFetchStreamReader = class {
  constructor(stream) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    this._filename = null;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._contentLength = source.length;
    this._headersCapability = Promise.withResolvers();
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._abortController = new AbortController();
    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    const headers = new Headers(stream.headers);
    const url = source.url;
    fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response) => {
      stream._responseOrigin = getResponseOrigin(response.url);
      if (!validateResponseStatus(response.status)) {
        throw createResponseError(response.status, url);
      }
      this._reader = response.body.getReader();
      this._headersCapability.resolve();
      const responseHeaders = response.headers;
      const {
        allowRangeRequests,
        suggestedLength
      } = validateRangeRequestCapabilities({
        responseHeaders,
        isHttp: stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = extractFilenameFromHeader(responseHeaders);
      if (!this._isStreamingSupported && this._isRangeSupported) {
        this.cancel(new AbortException("Streaming is disabled."));
      }
    }).catch(this._headersCapability.reject);
    this.onProgress = null;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var _a2;
    await this._headersCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value,
        done
      };
    }
    this._loaded += value.byteLength;
    (_a2 = this.onProgress) == null ? void 0 : _a2.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    });
    return {
      value: getArrayBuffer(value),
      done: false
    };
  }
  cancel(reason) {
    var _a2;
    (_a2 = this._reader) == null ? void 0 : _a2.cancel(reason);
    this._abortController.abort();
  }
};
var PDFFetchStreamRangeReader = class {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._readCapability = Promise.withResolvers();
    this._isStreamingSupported = !source.disableStream;
    this._abortController = new AbortController();
    const headers = new Headers(stream.headers);
    headers.append("Range", `bytes=${begin}-${end - 1}`);
    const url = source.url;
    fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response) => {
      const responseOrigin = getResponseOrigin(response.url);
      if (responseOrigin !== stream._responseOrigin) {
        throw new Error(`Expected range response-origin "${responseOrigin}" to match "${stream._responseOrigin}".`);
      }
      if (!validateResponseStatus(response.status)) {
        throw createResponseError(response.status, url);
      }
      this._readCapability.resolve();
      this._reader = response.body.getReader();
    }).catch(this._readCapability.reject);
    this.onProgress = null;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var _a2;
    await this._readCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value,
        done
      };
    }
    this._loaded += value.byteLength;
    (_a2 = this.onProgress) == null ? void 0 : _a2.call(this, {
      loaded: this._loaded
    });
    return {
      value: getArrayBuffer(value),
      done: false
    };
  }
  cancel(reason) {
    var _a2;
    (_a2 = this._reader) == null ? void 0 : _a2.cancel(reason);
    this._abortController.abort();
  }
};
var OK_RESPONSE = 200;
var PARTIAL_CONTENT_RESPONSE = 206;
function network_getArrayBuffer(xhr) {
  const data = xhr.response;
  if (typeof data !== "string") {
    return data;
  }
  return stringToBytes(data).buffer;
}
var NetworkManager = class {
  constructor({
    url,
    httpHeaders,
    withCredentials
  }) {
    __publicField(this, "_responseOrigin", null);
    this.url = url;
    this.isHttp = /^https?:/i.test(url);
    this.headers = createHeaders(this.isHttp, httpHeaders);
    this.withCredentials = withCredentials || false;
    this.currXhrId = 0;
    this.pendingRequests = /* @__PURE__ */ Object.create(null);
  }
  request(args) {
    const xhr = new XMLHttpRequest();
    const xhrId = this.currXhrId++;
    const pendingRequest = this.pendingRequests[xhrId] = {
      xhr
    };
    xhr.open("GET", this.url);
    xhr.withCredentials = this.withCredentials;
    for (const [key, val] of this.headers) {
      xhr.setRequestHeader(key, val);
    }
    if (this.isHttp && "begin" in args && "end" in args) {
      xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
    } else {
      pendingRequest.expectedStatus = OK_RESPONSE;
    }
    xhr.responseType = "arraybuffer";
    assert(args.onError, "Expected `onError` callback to be provided.");
    xhr.onerror = () => {
      args.onError(xhr.status);
    };
    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
    xhr.onprogress = this.onProgress.bind(this, xhrId);
    pendingRequest.onHeadersReceived = args.onHeadersReceived;
    pendingRequest.onDone = args.onDone;
    pendingRequest.onError = args.onError;
    pendingRequest.onProgress = args.onProgress;
    xhr.send(null);
    return xhrId;
  }
  onProgress(xhrId, evt) {
    var _a2;
    const pendingRequest = this.pendingRequests[xhrId];
    if (!pendingRequest) {
      return;
    }
    (_a2 = pendingRequest.onProgress) == null ? void 0 : _a2.call(pendingRequest, evt);
  }
  onStateChange(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];
    if (!pendingRequest) {
      return;
    }
    const xhr = pendingRequest.xhr;
    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
      pendingRequest.onHeadersReceived();
      delete pendingRequest.onHeadersReceived;
    }
    if (xhr.readyState !== 4) {
      return;
    }
    if (!(xhrId in this.pendingRequests)) {
      return;
    }
    delete this.pendingRequests[xhrId];
    if (xhr.status === 0 && this.isHttp) {
      pendingRequest.onError(xhr.status);
      return;
    }
    const xhrStatus = xhr.status || OK_RESPONSE;
    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
      pendingRequest.onError(xhr.status);
      return;
    }
    const chunk = network_getArrayBuffer(xhr);
    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
      const rangeHeader = xhr.getResponseHeader("Content-Range");
      const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
      if (matches) {
        pendingRequest.onDone({
          begin: parseInt(matches[1], 10),
          chunk
        });
      } else {
        warn(`Missing or invalid "Content-Range" header.`);
        pendingRequest.onError(0);
      }
    } else if (chunk) {
      pendingRequest.onDone({
        begin: 0,
        chunk
      });
    } else {
      pendingRequest.onError(xhr.status);
    }
  }
  getRequestXhr(xhrId) {
    return this.pendingRequests[xhrId].xhr;
  }
  isPendingRequest(xhrId) {
    return xhrId in this.pendingRequests;
  }
  abortRequest(xhrId) {
    const xhr = this.pendingRequests[xhrId].xhr;
    delete this.pendingRequests[xhrId];
    xhr.abort();
  }
};
var PDFNetworkStream = class {
  constructor(source) {
    this._source = source;
    this._manager = new NetworkManager(source);
    this._rangeChunkSize = source.rangeChunkSize;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  _onRangeRequestReaderClosed(reader) {
    const i = this._rangeRequestReaders.indexOf(reader);
    if (i >= 0) {
      this._rangeRequestReaders.splice(i, 1);
    }
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
    return this._fullRequestReader;
  }
  getRangeReader(begin, end) {
    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
    this._rangeRequestReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    var _a2;
    (_a2 = this._fullRequestReader) == null ? void 0 : _a2.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
};
var PDFNetworkStreamFullRequestReader = class {
  constructor(manager, source) {
    this._manager = manager;
    this._url = source.url;
    this._fullRequestId = manager.request({
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    });
    this._headersCapability = Promise.withResolvers();
    this._disableRange = source.disableRange || false;
    this._contentLength = source.length;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._isStreamingSupported = false;
    this._isRangeSupported = false;
    this._cachedChunks = [];
    this._requests = [];
    this._done = false;
    this._storedError = void 0;
    this._filename = null;
    this.onProgress = null;
  }
  _onHeadersReceived() {
    const fullRequestXhrId = this._fullRequestId;
    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
    this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);
    const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();
    const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trimStart().replace(/[^\S ]+$/, "").split(/[\r\n]+/).map((x) => {
      const [key, ...val] = x.split(": ");
      return [key, val.join(": ")];
    }) : []);
    const {
      allowRangeRequests,
      suggestedLength
    } = validateRangeRequestCapabilities({
      responseHeaders,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });
    if (allowRangeRequests) {
      this._isRangeSupported = true;
    }
    this._contentLength = suggestedLength || this._contentLength;
    this._filename = extractFilenameFromHeader(responseHeaders);
    if (this._isRangeSupported) {
      this._manager.abortRequest(fullRequestXhrId);
    }
    this._headersCapability.resolve();
  }
  _onDone(data) {
    if (data) {
      if (this._requests.length > 0) {
        const requestCapability = this._requests.shift();
        requestCapability.resolve({
          value: data.chunk,
          done: false
        });
      } else {
        this._cachedChunks.push(data.chunk);
      }
    }
    this._done = true;
    if (this._cachedChunks.length > 0) {
      return;
    }
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
  }
  _onError(status) {
    this._storedError = createResponseError(status, this._url);
    this._headersCapability.reject(this._storedError);
    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }
    this._requests.length = 0;
    this._cachedChunks.length = 0;
  }
  _onProgress(evt) {
    var _a2;
    (_a2 = this.onProgress) == null ? void 0 : _a2.call(this, {
      loaded: evt.loaded,
      total: evt.lengthComputable ? evt.total : this._contentLength
    });
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get contentLength() {
    return this._contentLength;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  async read() {
    await this._headersCapability.promise;
    if (this._storedError) {
      throw this._storedError;
    }
    if (this._cachedChunks.length > 0) {
      const chunk = this._cachedChunks.shift();
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    this._headersCapability.reject(reason);
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    if (this._manager.isPendingRequest(this._fullRequestId)) {
      this._manager.abortRequest(this._fullRequestId);
    }
    this._fullRequestReader = null;
  }
};
var PDFNetworkStreamRangeRequestReader = class {
  constructor(manager, begin, end) {
    this._manager = manager;
    this._url = manager.url;
    this._requestId = manager.request({
      begin,
      end,
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    });
    this._requests = [];
    this._queuedChunk = null;
    this._done = false;
    this._storedError = void 0;
    this.onProgress = null;
    this.onClosed = null;
  }
  _onHeadersReceived() {
    var _a2;
    const responseOrigin = getResponseOrigin((_a2 = this._manager.getRequestXhr(this._requestId)) == null ? void 0 : _a2.responseURL);
    if (responseOrigin !== this._manager._responseOrigin) {
      this._storedError = new Error(`Expected range response-origin "${responseOrigin}" to match "${this._manager._responseOrigin}".`);
      this._onError(0);
    }
  }
  _close() {
    var _a2;
    (_a2 = this.onClosed) == null ? void 0 : _a2.call(this, this);
  }
  _onDone(data) {
    const chunk = data.chunk;
    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();
      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunk = chunk;
    }
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    this._close();
  }
  _onError(status) {
    this._storedError ?? (this._storedError = createResponseError(status, this._url));
    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }
    this._requests.length = 0;
    this._queuedChunk = null;
  }
  _onProgress(evt) {
    var _a2;
    if (!this.isStreamingSupported) {
      (_a2 = this.onProgress) == null ? void 0 : _a2.call(this, {
        loaded: evt.loaded
      });
    }
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._storedError) {
      throw this._storedError;
    }
    if (this._queuedChunk !== null) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    if (this._manager.isPendingRequest(this._requestId)) {
      this._manager.abortRequest(this._requestId);
    }
    this._close();
  }
};
var urlRegex = /^[a-z][a-z0-9\-+.]+:/i;
function parseUrlOrPath(sourceUrl) {
  if (urlRegex.test(sourceUrl)) {
    return new URL(sourceUrl);
  }
  const url = process.getBuiltinModule("url");
  return new URL(url.pathToFileURL(sourceUrl));
}
var PDFNodeStream = class {
  constructor(source) {
    this.source = source;
    this.url = parseUrlOrPath(source.url);
    assert(this.url.protocol === "file:", "PDFNodeStream only supports file:// URLs.");
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var _a2;
    return ((_a2 = this._fullRequestReader) == null ? void 0 : _a2._loaded) ?? 0;
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFNodeStreamFsFullReader(this);
    return this._fullRequestReader;
  }
  getRangeReader(start, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);
    this._rangeRequestReaders.push(rangeReader);
    return rangeReader;
  }
  cancelAllRequests(reason) {
    var _a2;
    (_a2 = this._fullRequestReader) == null ? void 0 : _a2.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
};
var PDFNodeStreamFsFullReader = class {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    const source = stream.source;
    this._contentLength = source.length;
    this._loaded = 0;
    this._filename = null;
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._readableStream = null;
    this._readCapability = Promise.withResolvers();
    this._headersCapability = Promise.withResolvers();
    const fs = process.getBuiltinModule("fs");
    fs.promises.lstat(this._url).then((stat) => {
      this._contentLength = stat.size;
      this._setReadableStream(fs.createReadStream(this._url));
      this._headersCapability.resolve();
    }, (error) => {
      if (error.code === "ENOENT") {
        error = createResponseError(0, this._url.href);
      }
      this._storedError = error;
      this._headersCapability.reject(error);
    });
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var _a2;
    await this._readCapability.promise;
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    if (this._storedError) {
      throw this._storedError;
    }
    const chunk = this._readableStream.read();
    if (chunk === null) {
      this._readCapability = Promise.withResolvers();
      return this.read();
    }
    this._loaded += chunk.length;
    (_a2 = this.onProgress) == null ? void 0 : _a2.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    });
    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }
  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);
      return;
    }
    this._readableStream.destroy(reason);
  }
  _error(reason) {
    this._storedError = reason;
    this._readCapability.resolve();
  }
  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;
      this._readCapability.resolve();
    });
    readableStream.on("error", (reason) => {
      this._error(reason);
    });
    if (!this._isStreamingSupported && this._isRangeSupported) {
      this._error(new AbortException("streaming is disabled"));
    }
    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }
};
var PDFNodeStreamFsRangeReader = class {
  constructor(stream, start, end) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    this._loaded = 0;
    this._readableStream = null;
    this._readCapability = Promise.withResolvers();
    const source = stream.source;
    this._isStreamingSupported = !source.disableStream;
    const fs = process.getBuiltinModule("fs");
    this._setReadableStream(fs.createReadStream(this._url, {
      start,
      end: end - 1
    }));
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var _a2;
    await this._readCapability.promise;
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    if (this._storedError) {
      throw this._storedError;
    }
    const chunk = this._readableStream.read();
    if (chunk === null) {
      this._readCapability = Promise.withResolvers();
      return this.read();
    }
    this._loaded += chunk.length;
    (_a2 = this.onProgress) == null ? void 0 : _a2.call(this, {
      loaded: this._loaded
    });
    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }
  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);
      return;
    }
    this._readableStream.destroy(reason);
  }
  _error(reason) {
    this._storedError = reason;
    this._readCapability.resolve();
  }
  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;
      this._readCapability.resolve();
    });
    readableStream.on("error", (reason) => {
      this._error(reason);
    });
    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }
};
var INITIAL_DATA = Symbol("INITIAL_DATA");
var _objs, _ensureObj, ensureObj_fn;
var PDFObjects = class {
  constructor() {
    __privateAdd(this, _ensureObj);
    __privateAdd(this, _objs, /* @__PURE__ */ Object.create(null));
  }
  get(objId, callback = null) {
    if (callback) {
      const obj2 = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
      obj2.promise.then(() => callback(obj2.data));
      return null;
    }
    const obj = __privateGet(this, _objs)[objId];
    if (!obj || obj.data === INITIAL_DATA) {
      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
    }
    return obj.data;
  }
  has(objId) {
    const obj = __privateGet(this, _objs)[objId];
    return !!obj && obj.data !== INITIAL_DATA;
  }
  delete(objId) {
    const obj = __privateGet(this, _objs)[objId];
    if (!obj || obj.data === INITIAL_DATA) {
      return false;
    }
    delete __privateGet(this, _objs)[objId];
    return true;
  }
  resolve(objId, data = null) {
    const obj = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
    obj.data = data;
    obj.resolve();
  }
  clear() {
    var _a2;
    for (const objId in __privateGet(this, _objs)) {
      const {
        data
      } = __privateGet(this, _objs)[objId];
      (_a2 = data == null ? void 0 : data.bitmap) == null ? void 0 : _a2.close();
    }
    __privateSet(this, _objs, /* @__PURE__ */ Object.create(null));
  }
  *[Symbol.iterator]() {
    for (const objId in __privateGet(this, _objs)) {
      const {
        data
      } = __privateGet(this, _objs)[objId];
      if (data === INITIAL_DATA) {
        continue;
      }
      yield [objId, data];
    }
  }
};
_objs = new WeakMap();
_ensureObj = new WeakSet();
ensureObj_fn = function(objId) {
  var _a2;
  return (_a2 = __privateGet(this, _objs))[objId] || (_a2[objId] = {
    ...Promise.withResolvers(),
    data: INITIAL_DATA
  });
};
var MAX_TEXT_DIVS_TO_RENDER = 1e5;
var DEFAULT_FONT_SIZE = 30;
var _a, _capability, _container3, _disableProcessItems, _fontInspectorEnabled, _lang, _layoutTextParams, _pageHeight, _pageWidth, _reader, _rootContainer, _rotation, _scale, _styleCache, _textContentItemsStr, _textContentSource, _textDivs, _textDivProperties, _transform, _ascentCache, _canvasContexts, _canvasCtxFonts, _minFontSize, _pendingTextLayers, _processItems, processItems_fn, _appendText, appendText_fn, _layout, layout_fn, _getCtx, getCtx_fn, _ensureCtxFont, ensureCtxFont_fn, _ensureMinFontSizeComputed, ensureMinFontSizeComputed_fn, _getAscent, getAscent_fn;
var _TextLayer = class _TextLayer {
  constructor({
    textContentSource,
    container,
    viewport
  }) {
    __privateAdd(this, _processItems);
    __privateAdd(this, _appendText);
    __privateAdd(this, _layout);
    __privateAdd(this, _capability, Promise.withResolvers());
    __privateAdd(this, _container3, null);
    __privateAdd(this, _disableProcessItems, false);
    __privateAdd(this, _fontInspectorEnabled, !!((_a = globalThis.FontInspector) == null ? void 0 : _a.enabled));
    __privateAdd(this, _lang, null);
    __privateAdd(this, _layoutTextParams, null);
    __privateAdd(this, _pageHeight, 0);
    __privateAdd(this, _pageWidth, 0);
    __privateAdd(this, _reader, null);
    __privateAdd(this, _rootContainer, null);
    __privateAdd(this, _rotation, 0);
    __privateAdd(this, _scale, 0);
    __privateAdd(this, _styleCache, /* @__PURE__ */ Object.create(null));
    __privateAdd(this, _textContentItemsStr, []);
    __privateAdd(this, _textContentSource, null);
    __privateAdd(this, _textDivs, []);
    __privateAdd(this, _textDivProperties, /* @__PURE__ */ new WeakMap());
    __privateAdd(this, _transform, null);
    var _a2;
    if (textContentSource instanceof ReadableStream) {
      __privateSet(this, _textContentSource, textContentSource);
    } else if (typeof textContentSource === "object") {
      __privateSet(this, _textContentSource, new ReadableStream({
        start(controller) {
          controller.enqueue(textContentSource);
          controller.close();
        }
      }));
    } else {
      throw new Error('No "textContentSource" parameter specified.');
    }
    __privateSet(this, _container3, __privateSet(this, _rootContainer, container));
    __privateSet(this, _scale, viewport.scale * OutputScale.pixelRatio);
    __privateSet(this, _rotation, viewport.rotation);
    __privateSet(this, _layoutTextParams, {
      div: null,
      properties: null,
      ctx: null
    });
    const {
      pageWidth,
      pageHeight,
      pageX,
      pageY
    } = viewport.rawDims;
    __privateSet(this, _transform, [1, 0, 0, -1, -pageX, pageY + pageHeight]);
    __privateSet(this, _pageWidth, pageWidth);
    __privateSet(this, _pageHeight, pageHeight);
    __privateMethod(_a2 = _TextLayer, _ensureMinFontSizeComputed, ensureMinFontSizeComputed_fn).call(_a2);
    setLayerDimensions(container, viewport);
    __privateGet(this, _capability).promise.finally(() => {
      __privateGet(_TextLayer, _pendingTextLayers).delete(this);
      __privateSet(this, _layoutTextParams, null);
      __privateSet(this, _styleCache, null);
    }).catch(() => {
    });
  }
  static get fontFamilyMap() {
    const {
      isWindows,
      isFirefox
    } = util_FeatureTest.platform;
    return shadow(this, "fontFamilyMap", /* @__PURE__ */ new Map([["sans-serif", `${isWindows && isFirefox ? "Calibri, " : ""}sans-serif`], ["monospace", `${isWindows && isFirefox ? "Lucida Console, " : ""}monospace`]]));
  }
  render() {
    const pump = () => {
      __privateGet(this, _reader).read().then(({
        value,
        done
      }) => {
        if (done) {
          __privateGet(this, _capability).resolve();
          return;
        }
        __privateGet(this, _lang) ?? __privateSet(this, _lang, value.lang);
        Object.assign(__privateGet(this, _styleCache), value.styles);
        __privateMethod(this, _processItems, processItems_fn).call(this, value.items);
        pump();
      }, __privateGet(this, _capability).reject);
    };
    __privateSet(this, _reader, __privateGet(this, _textContentSource).getReader());
    __privateGet(_TextLayer, _pendingTextLayers).add(this);
    pump();
    return __privateGet(this, _capability).promise;
  }
  update({
    viewport,
    onBefore = null
  }) {
    var _a2;
    const scale = viewport.scale * OutputScale.pixelRatio;
    const rotation = viewport.rotation;
    if (rotation !== __privateGet(this, _rotation)) {
      onBefore == null ? void 0 : onBefore();
      __privateSet(this, _rotation, rotation);
      setLayerDimensions(__privateGet(this, _rootContainer), {
        rotation
      });
    }
    if (scale !== __privateGet(this, _scale)) {
      onBefore == null ? void 0 : onBefore();
      __privateSet(this, _scale, scale);
      const params = {
        div: null,
        properties: null,
        ctx: __privateMethod(_a2 = _TextLayer, _getCtx, getCtx_fn).call(_a2, __privateGet(this, _lang))
      };
      for (const div of __privateGet(this, _textDivs)) {
        params.properties = __privateGet(this, _textDivProperties).get(div);
        params.div = div;
        __privateMethod(this, _layout, layout_fn).call(this, params);
      }
    }
  }
  cancel() {
    var _a2;
    const abortEx = new AbortException("TextLayer task cancelled.");
    (_a2 = __privateGet(this, _reader)) == null ? void 0 : _a2.cancel(abortEx).catch(() => {
    });
    __privateSet(this, _reader, null);
    __privateGet(this, _capability).reject(abortEx);
  }
  get textDivs() {
    return __privateGet(this, _textDivs);
  }
  get textContentItemsStr() {
    return __privateGet(this, _textContentItemsStr);
  }
  static cleanup() {
    if (__privateGet(this, _pendingTextLayers).size > 0) {
      return;
    }
    __privateGet(this, _ascentCache).clear();
    for (const {
      canvas
    } of __privateGet(this, _canvasContexts).values()) {
      canvas.remove();
    }
    __privateGet(this, _canvasContexts).clear();
  }
};
_capability = new WeakMap();
_container3 = new WeakMap();
_disableProcessItems = new WeakMap();
_fontInspectorEnabled = new WeakMap();
_lang = new WeakMap();
_layoutTextParams = new WeakMap();
_pageHeight = new WeakMap();
_pageWidth = new WeakMap();
_reader = new WeakMap();
_rootContainer = new WeakMap();
_rotation = new WeakMap();
_scale = new WeakMap();
_styleCache = new WeakMap();
_textContentItemsStr = new WeakMap();
_textContentSource = new WeakMap();
_textDivs = new WeakMap();
_textDivProperties = new WeakMap();
_transform = new WeakMap();
_ascentCache = new WeakMap();
_canvasContexts = new WeakMap();
_canvasCtxFonts = new WeakMap();
_minFontSize = new WeakMap();
_pendingTextLayers = new WeakMap();
_processItems = new WeakSet();
processItems_fn = function(items) {
  var _a2, _b;
  if (__privateGet(this, _disableProcessItems)) {
    return;
  }
  (_b = __privateGet(this, _layoutTextParams)).ctx ?? (_b.ctx = __privateMethod(_a2 = _TextLayer, _getCtx, getCtx_fn).call(_a2, __privateGet(this, _lang)));
  const textDivs = __privateGet(this, _textDivs), textContentItemsStr = __privateGet(this, _textContentItemsStr);
  for (const item of items) {
    if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {
      warn("Ignoring additional textDivs for performance reasons.");
      __privateSet(this, _disableProcessItems, true);
      return;
    }
    if (item.str === void 0) {
      if (item.type === "beginMarkedContentProps" || item.type === "beginMarkedContent") {
        const parent = __privateGet(this, _container3);
        __privateSet(this, _container3, document.createElement("span"));
        __privateGet(this, _container3).classList.add("markedContent");
        if (item.id) {
          __privateGet(this, _container3).setAttribute("id", `${item.id}`);
        }
        parent.append(__privateGet(this, _container3));
      } else if (item.type === "endMarkedContent") {
        __privateSet(this, _container3, __privateGet(this, _container3).parentNode);
      }
      continue;
    }
    textContentItemsStr.push(item.str);
    __privateMethod(this, _appendText, appendText_fn).call(this, item);
  }
};
_appendText = new WeakSet();
appendText_fn = function(geom) {
  var _a2;
  const textDiv = document.createElement("span");
  const textDivProperties = {
    angle: 0,
    canvasWidth: 0,
    hasText: geom.str !== "",
    hasEOL: geom.hasEOL,
    fontSize: 0
  };
  __privateGet(this, _textDivs).push(textDiv);
  const tx = Util.transform(__privateGet(this, _transform), geom.transform);
  let angle = Math.atan2(tx[1], tx[0]);
  const style = __privateGet(this, _styleCache)[geom.fontName];
  if (style.vertical) {
    angle += Math.PI / 2;
  }
  let fontFamily = __privateGet(this, _fontInspectorEnabled) && style.fontSubstitution || style.fontFamily;
  fontFamily = _TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;
  const fontHeight = Math.hypot(tx[2], tx[3]);
  const fontAscent = fontHeight * __privateMethod(_a2 = _TextLayer, _getAscent, getAscent_fn).call(_a2, fontFamily, style, __privateGet(this, _lang));
  let left, top;
  if (angle === 0) {
    left = tx[4];
    top = tx[5] - fontAscent;
  } else {
    left = tx[4] + fontAscent * Math.sin(angle);
    top = tx[5] - fontAscent * Math.cos(angle);
  }
  const scaleFactorStr = "calc(var(--total-scale-factor) *";
  const divStyle = textDiv.style;
  if (__privateGet(this, _container3) === __privateGet(this, _rootContainer)) {
    divStyle.left = `${(100 * left / __privateGet(this, _pageWidth)).toFixed(2)}%`;
    divStyle.top = `${(100 * top / __privateGet(this, _pageHeight)).toFixed(2)}%`;
  } else {
    divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;
    divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;
  }
  divStyle.fontSize = `${scaleFactorStr}${(__privateGet(_TextLayer, _minFontSize) * fontHeight).toFixed(2)}px)`;
  divStyle.fontFamily = fontFamily;
  textDivProperties.fontSize = fontHeight;
  textDiv.setAttribute("role", "presentation");
  textDiv.textContent = geom.str;
  textDiv.dir = geom.dir;
  if (__privateGet(this, _fontInspectorEnabled)) {
    textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;
  }
  if (angle !== 0) {
    textDivProperties.angle = angle * (180 / Math.PI);
  }
  let shouldScaleText = false;
  if (geom.str.length > 1) {
    shouldScaleText = true;
  } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
    const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
    if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
      shouldScaleText = true;
    }
  }
  if (shouldScaleText) {
    textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;
  }
  __privateGet(this, _textDivProperties).set(textDiv, textDivProperties);
  __privateGet(this, _layoutTextParams).div = textDiv;
  __privateGet(this, _layoutTextParams).properties = textDivProperties;
  __privateMethod(this, _layout, layout_fn).call(this, __privateGet(this, _layoutTextParams));
  if (textDivProperties.hasText) {
    __privateGet(this, _container3).append(textDiv);
  }
  if (textDivProperties.hasEOL) {
    const br = document.createElement("br");
    br.setAttribute("role", "presentation");
    __privateGet(this, _container3).append(br);
  }
};
_layout = new WeakSet();
layout_fn = function(params) {
  var _a2;
  const {
    div,
    properties,
    ctx
  } = params;
  const {
    style
  } = div;
  let transform = "";
  if (__privateGet(_TextLayer, _minFontSize) > 1) {
    transform = `scale(${1 / __privateGet(_TextLayer, _minFontSize)})`;
  }
  if (properties.canvasWidth !== 0 && properties.hasText) {
    const {
      fontFamily
    } = style;
    const {
      canvasWidth,
      fontSize
    } = properties;
    __privateMethod(_a2 = _TextLayer, _ensureCtxFont, ensureCtxFont_fn).call(_a2, ctx, fontSize * __privateGet(this, _scale), fontFamily);
    const {
      width
    } = ctx.measureText(div.textContent);
    if (width > 0) {
      transform = `scaleX(${canvasWidth * __privateGet(this, _scale) / width}) ${transform}`;
    }
  }
  if (properties.angle !== 0) {
    transform = `rotate(${properties.angle}deg) ${transform}`;
  }
  if (transform.length > 0) {
    style.transform = transform;
  }
};
_getCtx = new WeakSet();
getCtx_fn = function(lang = null) {
  let ctx = __privateGet(this, _canvasContexts).get(lang || (lang = ""));
  if (!ctx) {
    const canvas = document.createElement("canvas");
    canvas.className = "hiddenCanvasElement";
    canvas.lang = lang;
    document.body.append(canvas);
    ctx = canvas.getContext("2d", {
      alpha: false,
      willReadFrequently: true
    });
    __privateGet(this, _canvasContexts).set(lang, ctx);
    __privateGet(this, _canvasCtxFonts).set(ctx, {
      size: 0,
      family: ""
    });
  }
  return ctx;
};
_ensureCtxFont = new WeakSet();
ensureCtxFont_fn = function(ctx, size, family) {
  const cached = __privateGet(this, _canvasCtxFonts).get(ctx);
  if (size === cached.size && family === cached.family) {
    return;
  }
  ctx.font = `${size}px ${family}`;
  cached.size = size;
  cached.family = family;
};
_ensureMinFontSizeComputed = new WeakSet();
ensureMinFontSizeComputed_fn = function() {
  if (__privateGet(this, _minFontSize) !== null) {
    return;
  }
  const div = document.createElement("div");
  div.style.opacity = 0;
  div.style.lineHeight = 1;
  div.style.fontSize = "1px";
  div.style.position = "absolute";
  div.textContent = "X";
  document.body.append(div);
  __privateSet(this, _minFontSize, div.getBoundingClientRect().height);
  div.remove();
};
_getAscent = new WeakSet();
getAscent_fn = function(fontFamily, style, lang) {
  const cachedAscent = __privateGet(this, _ascentCache).get(fontFamily);
  if (cachedAscent) {
    return cachedAscent;
  }
  const ctx = __privateMethod(this, _getCtx, getCtx_fn).call(this, lang);
  ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;
  __privateMethod(this, _ensureCtxFont, ensureCtxFont_fn).call(this, ctx, DEFAULT_FONT_SIZE, fontFamily);
  const metrics = ctx.measureText("");
  const ascent = metrics.fontBoundingBoxAscent;
  const descent = Math.abs(metrics.fontBoundingBoxDescent);
  ctx.canvas.width = ctx.canvas.height = 0;
  let ratio = 0.8;
  if (ascent) {
    ratio = ascent / (ascent + descent);
  } else {
    if (util_FeatureTest.platform.isFirefox) {
      warn("Enable the `dom.textMetrics.fontBoundingBox.enabled` preference in `about:config` to improve TextLayer rendering.");
    }
    if (style.ascent) {
      ratio = style.ascent;
    } else if (style.descent) {
      ratio = 1 + style.descent;
    }
  }
  __privateGet(this, _ascentCache).set(fontFamily, ratio);
  return ratio;
};
__privateAdd(_TextLayer, _getCtx);
__privateAdd(_TextLayer, _ensureCtxFont);
__privateAdd(_TextLayer, _ensureMinFontSizeComputed);
__privateAdd(_TextLayer, _getAscent);
__privateAdd(_TextLayer, _ascentCache, /* @__PURE__ */ new Map());
__privateAdd(_TextLayer, _canvasContexts, /* @__PURE__ */ new Map());
__privateAdd(_TextLayer, _canvasCtxFonts, /* @__PURE__ */ new WeakMap());
__privateAdd(_TextLayer, _minFontSize, null);
__privateAdd(_TextLayer, _pendingTextLayers, /* @__PURE__ */ new Set());
var TextLayer = _TextLayer;
var RENDERING_CANCELLED_TIMEOUT = 100;
function getDocument(src = {}) {
  if (typeof src === "string" || src instanceof URL) {
    src = {
      url: src
    };
  } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {
    src = {
      data: src
    };
  }
  const task = new PDFDocumentLoadingTask();
  const {
    docId
  } = task;
  const url = src.url ? getUrlProp(src.url) : null;
  const data = src.data ? getDataProp(src.data) : null;
  const httpHeaders = src.httpHeaders || null;
  const withCredentials = src.withCredentials === true;
  const password = src.password ?? null;
  const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;
  const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : 2 ** 16;
  let worker = src.worker instanceof PDFWorker ? src.worker : null;
  const verbosity2 = src.verbosity;
  const docBaseUrl = typeof src.docBaseUrl === "string" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;
  const cMapUrl = getFactoryUrlProp(src.cMapUrl);
  const cMapPacked = src.cMapPacked !== false;
  const CMapReaderFactory = src.CMapReaderFactory || (isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory);
  const iccUrl = getFactoryUrlProp(src.iccUrl);
  const standardFontDataUrl = getFactoryUrlProp(src.standardFontDataUrl);
  const StandardFontDataFactory = src.StandardFontDataFactory || (isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory);
  const wasmUrl = getFactoryUrlProp(src.wasmUrl);
  const WasmFactory = src.WasmFactory || (isNodeJS ? NodeWasmFactory : DOMWasmFactory);
  const ignoreErrors = src.stopAtErrors !== true;
  const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;
  const isEvalSupported2 = src.isEvalSupported !== false;
  const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === "boolean" ? src.isOffscreenCanvasSupported : !isNodeJS;
  const isImageDecoderSupported = typeof src.isImageDecoderSupported === "boolean" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);
  const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;
  const disableFontFace = typeof src.disableFontFace === "boolean" ? src.disableFontFace : isNodeJS;
  const fontExtraProperties = src.fontExtraProperties === true;
  const enableXfa = src.enableXfa === true;
  const ownerDocument = src.ownerDocument || globalThis.document;
  const disableRange = src.disableRange === true;
  const disableStream = src.disableStream === true;
  const disableAutoFetch = src.disableAutoFetch === true;
  const pdfBug = src.pdfBug === true;
  const CanvasFactory = src.CanvasFactory || (isNodeJS ? NodeCanvasFactory : DOMCanvasFactory);
  const FilterFactory = src.FilterFactory || (isNodeJS ? NodeFilterFactory : DOMFilterFactory);
  const enableHWA = src.enableHWA === true;
  const useWasm = src.useWasm !== false;
  const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;
  const useSystemFonts = typeof src.useSystemFonts === "boolean" ? src.useSystemFonts : !isNodeJS && !disableFontFace;
  const useWorkerFetch = typeof src.useWorkerFetch === "boolean" ? src.useWorkerFetch : !!(CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && WasmFactory === DOMWasmFactory && cMapUrl && standardFontDataUrl && wasmUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI) && isValidFetchUrl(wasmUrl, document.baseURI));
  const styleElement = null;
  setVerbosityLevel(verbosity2);
  const transportFactory = {
    canvasFactory: new CanvasFactory({
      ownerDocument,
      enableHWA
    }),
    filterFactory: new FilterFactory({
      docId,
      ownerDocument
    }),
    cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({
      baseUrl: cMapUrl,
      isCompressed: cMapPacked
    }),
    standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({
      baseUrl: standardFontDataUrl
    }),
    wasmFactory: useWorkerFetch ? null : new WasmFactory({
      baseUrl: wasmUrl
    })
  };
  if (!worker) {
    worker = PDFWorker.create({
      verbosity: verbosity2,
      port: GlobalWorkerOptions.workerPort
    });
    task._worker = worker;
  }
  const docParams = {
    docId,
    apiVersion: "5.4.296",
    data,
    password,
    disableAutoFetch,
    rangeChunkSize,
    length,
    docBaseUrl,
    enableXfa,
    evaluatorOptions: {
      maxImageSize,
      disableFontFace,
      ignoreErrors,
      isEvalSupported: isEvalSupported2,
      isOffscreenCanvasSupported,
      isImageDecoderSupported,
      canvasMaxAreaInBytes,
      fontExtraProperties,
      useSystemFonts,
      useWasm,
      useWorkerFetch,
      cMapUrl,
      iccUrl,
      standardFontDataUrl,
      wasmUrl
    }
  };
  const transportParams = {
    ownerDocument,
    pdfBug,
    styleElement,
    loadingParams: {
      disableAutoFetch,
      enableXfa
    }
  };
  worker.promise.then(function() {
    if (task.destroyed) {
      throw new Error("Loading aborted");
    }
    if (worker.destroyed) {
      throw new Error("Worker was destroyed");
    }
    const workerIdPromise = worker.messageHandler.sendWithPromise("GetDocRequest", docParams, data ? [data.buffer] : null);
    let networkStream;
    if (rangeTransport) {
      networkStream = new PDFDataTransportStream(rangeTransport, {
        disableRange,
        disableStream
      });
    } else if (!data) {
      if (!url) {
        throw new Error("getDocument - no `url` parameter provided.");
      }
      const NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : isNodeJS ? PDFNodeStream : PDFNetworkStream;
      networkStream = new NetworkStream({
        url,
        length,
        httpHeaders,
        withCredentials,
        rangeChunkSize,
        disableRange,
        disableStream
      });
    }
    return workerIdPromise.then((workerId) => {
      if (task.destroyed) {
        throw new Error("Loading aborted");
      }
      if (worker.destroyed) {
        throw new Error("Worker was destroyed");
      }
      const messageHandler = new MessageHandler(docId, workerId, worker.port);
      const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory, enableHWA);
      task._transport = transport;
      messageHandler.send("Ready", null);
    });
  }).catch(task._capability.reject);
  return task;
}
var _docId2;
var _PDFDocumentLoadingTask = class _PDFDocumentLoadingTask {
  constructor() {
    __publicField(this, "_capability", Promise.withResolvers());
    __publicField(this, "_transport", null);
    __publicField(this, "_worker", null);
    __publicField(this, "docId", `d${__privateWrapper(_PDFDocumentLoadingTask, _docId2)._++}`);
    __publicField(this, "destroyed", false);
    __publicField(this, "onPassword", null);
    __publicField(this, "onProgress", null);
  }
  get promise() {
    return this._capability.promise;
  }
  async destroy() {
    var _a2, _b, _c, _d;
    this.destroyed = true;
    try {
      if ((_a2 = this._worker) == null ? void 0 : _a2.port) {
        this._worker._pendingDestroy = true;
      }
      await ((_b = this._transport) == null ? void 0 : _b.destroy());
    } catch (ex) {
      if ((_c = this._worker) == null ? void 0 : _c.port) {
        delete this._worker._pendingDestroy;
      }
      throw ex;
    }
    this._transport = null;
    (_d = this._worker) == null ? void 0 : _d.destroy();
    this._worker = null;
  }
  async getData() {
    return this._transport.getData();
  }
};
_docId2 = new WeakMap();
__privateAdd(_PDFDocumentLoadingTask, _docId2, 0);
var PDFDocumentLoadingTask = _PDFDocumentLoadingTask;
var _capability2, _progressiveDoneListeners, _progressiveReadListeners, _progressListeners, _rangeListeners;
var PDFDataRangeTransport = class {
  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
    __privateAdd(this, _capability2, Promise.withResolvers());
    __privateAdd(this, _progressiveDoneListeners, []);
    __privateAdd(this, _progressiveReadListeners, []);
    __privateAdd(this, _progressListeners, []);
    __privateAdd(this, _rangeListeners, []);
    this.length = length;
    this.initialData = initialData;
    this.progressiveDone = progressiveDone;
    this.contentDispositionFilename = contentDispositionFilename;
  }
  addRangeListener(listener) {
    __privateGet(this, _rangeListeners).push(listener);
  }
  addProgressListener(listener) {
    __privateGet(this, _progressListeners).push(listener);
  }
  addProgressiveReadListener(listener) {
    __privateGet(this, _progressiveReadListeners).push(listener);
  }
  addProgressiveDoneListener(listener) {
    __privateGet(this, _progressiveDoneListeners).push(listener);
  }
  onDataRange(begin, chunk) {
    for (const listener of __privateGet(this, _rangeListeners)) {
      listener(begin, chunk);
    }
  }
  onDataProgress(loaded, total) {
    __privateGet(this, _capability2).promise.then(() => {
      for (const listener of __privateGet(this, _progressListeners)) {
        listener(loaded, total);
      }
    });
  }
  onDataProgressiveRead(chunk) {
    __privateGet(this, _capability2).promise.then(() => {
      for (const listener of __privateGet(this, _progressiveReadListeners)) {
        listener(chunk);
      }
    });
  }
  onDataProgressiveDone() {
    __privateGet(this, _capability2).promise.then(() => {
      for (const listener of __privateGet(this, _progressiveDoneListeners)) {
        listener();
      }
    });
  }
  transportReady() {
    __privateGet(this, _capability2).resolve();
  }
  requestDataRange(begin, end) {
    unreachable("Abstract method PDFDataRangeTransport.requestDataRange");
  }
  abort() {
  }
};
_capability2 = new WeakMap();
_progressiveDoneListeners = new WeakMap();
_progressiveReadListeners = new WeakMap();
_progressListeners = new WeakMap();
_rangeListeners = new WeakMap();
var PDFDocumentProxy = class {
  constructor(pdfInfo, transport) {
    this._pdfInfo = pdfInfo;
    this._transport = transport;
  }
  get annotationStorage() {
    return this._transport.annotationStorage;
  }
  get canvasFactory() {
    return this._transport.canvasFactory;
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get numPages() {
    return this._pdfInfo.numPages;
  }
  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }
  get isPureXfa() {
    return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }
  getPage(pageNumber) {
    return this._transport.getPage(pageNumber);
  }
  getPageIndex(ref) {
    return this._transport.getPageIndex(ref);
  }
  getDestinations() {
    return this._transport.getDestinations();
  }
  getDestination(id) {
    return this._transport.getDestination(id);
  }
  getPageLabels() {
    return this._transport.getPageLabels();
  }
  getPageLayout() {
    return this._transport.getPageLayout();
  }
  getPageMode() {
    return this._transport.getPageMode();
  }
  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }
  getOpenAction() {
    return this._transport.getOpenAction();
  }
  getAttachments() {
    return this._transport.getAttachments();
  }
  getAnnotationsByType(types, pageIndexesToSkip) {
    return this._transport.getAnnotationsByType(types, pageIndexesToSkip);
  }
  getJSActions() {
    return this._transport.getDocJSActions();
  }
  getOutline() {
    return this._transport.getOutline();
  }
  getOptionalContentConfig({
    intent = "display"
  } = {}) {
    const {
      renderingIntent
    } = this._transport.getRenderingIntent(intent);
    return this._transport.getOptionalContentConfig(renderingIntent);
  }
  getPermissions() {
    return this._transport.getPermissions();
  }
  getMetadata() {
    return this._transport.getMetadata();
  }
  getMarkInfo() {
    return this._transport.getMarkInfo();
  }
  getData() {
    return this._transport.getData();
  }
  saveDocument() {
    return this._transport.saveDocument();
  }
  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }
  cleanup(keepLoadedFonts = false) {
    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
  }
  destroy() {
    return this.loadingTask.destroy();
  }
  cachedPageNumber(ref) {
    return this._transport.cachedPageNumber(ref);
  }
  get loadingParams() {
    return this._transport.loadingParams;
  }
  get loadingTask() {
    return this._transport.loadingTask;
  }
  getFieldObjects() {
    return this._transport.getFieldObjects();
  }
  hasJSActions() {
    return this._transport.hasJSActions();
  }
  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }
};
var _pendingCleanup, _tryCleanup, tryCleanup_fn;
var PDFPageProxy = class {
  constructor(pageIndex, pageInfo, transport, pdfBug = false) {
    __privateAdd(this, _tryCleanup);
    __privateAdd(this, _pendingCleanup, false);
    this._pageIndex = pageIndex;
    this._pageInfo = pageInfo;
    this._transport = transport;
    this._stats = pdfBug ? new StatTimer() : null;
    this._pdfBug = pdfBug;
    this.commonObjs = transport.commonObjs;
    this.objs = new PDFObjects();
    this._intentStates = /* @__PURE__ */ new Map();
    this.destroyed = false;
    this.recordedBBoxes = null;
  }
  get pageNumber() {
    return this._pageIndex + 1;
  }
  get rotate() {
    return this._pageInfo.rotate;
  }
  get ref() {
    return this._pageInfo.ref;
  }
  get userUnit() {
    return this._pageInfo.userUnit;
  }
  get view() {
    return this._pageInfo.view;
  }
  getViewport({
    scale,
    rotation = this.rotate,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  } = {}) {
    return new PageViewport({
      viewBox: this.view,
      userUnit: this.userUnit,
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }
  getAnnotations({
    intent = "display"
  } = {}) {
    const {
      renderingIntent
    } = this._transport.getRenderingIntent(intent);
    return this._transport.getAnnotations(this._pageIndex, renderingIntent);
  }
  getJSActions() {
    return this._transport.getPageJSActions(this._pageIndex);
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get isPureXfa() {
    return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  async getXfa() {
    var _a2;
    return ((_a2 = this._transport._htmlForXfa) == null ? void 0 : _a2.children[this._pageIndex]) || null;
  }
  render({
    canvasContext,
    canvas = canvasContext.canvas,
    viewport,
    intent = "display",
    annotationMode = AnnotationMode.ENABLE,
    transform = null,
    background = null,
    optionalContentConfigPromise = null,
    annotationCanvasMap = null,
    pageColors = null,
    printAnnotationStorage = null,
    isEditing = false,
    recordOperations = false,
    operationsFilter = null
  }) {
    var _a2, _b, _c;
    (_a2 = this._stats) == null ? void 0 : _a2.time("Overall");
    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);
    const {
      renderingIntent,
      cacheKey
    } = intentArgs;
    __privateSet(this, _pendingCleanup, false);
    optionalContentConfigPromise || (optionalContentConfigPromise = this._transport.getOptionalContentConfig(renderingIntent));
    let intentState = this._intentStates.get(cacheKey);
    if (!intentState) {
      intentState = /* @__PURE__ */ Object.create(null);
      this._intentStates.set(cacheKey, intentState);
    }
    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }
    const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
    if (!intentState.displayReadyCapability) {
      intentState.displayReadyCapability = Promise.withResolvers();
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };
      (_b = this._stats) == null ? void 0 : _b.time("Page Request");
      this._pumpOperatorList(intentArgs);
    }
    const recordForDebugger = Boolean(this._pdfBug && ((_c = globalThis.StepperManager) == null ? void 0 : _c.enabled));
    const shouldRecordOperations = !this.recordedBBoxes && (recordOperations || recordForDebugger);
    const complete = (error) => {
      var _a3, _b2;
      intentState.renderTasks.delete(internalRenderTask);
      if (shouldRecordOperations) {
        const recordedBBoxes = (_a3 = internalRenderTask.gfx) == null ? void 0 : _a3.dependencyTracker.take();
        if (recordedBBoxes) {
          if (internalRenderTask.stepper) {
            internalRenderTask.stepper.setOperatorBBoxes(recordedBBoxes, internalRenderTask.gfx.dependencyTracker.takeDebugMetadata());
          }
          if (recordOperations) {
            this.recordedBBoxes = recordedBBoxes;
          }
        }
      }
      if (intentPrint) {
        __privateSet(this, _pendingCleanup, true);
      }
      __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this);
      if (error) {
        internalRenderTask.capability.reject(error);
        this._abortOperatorList({
          intentState,
          reason: error instanceof Error ? error : new Error(error)
        });
      } else {
        internalRenderTask.capability.resolve();
      }
      if (this._stats) {
        this._stats.timeEnd("Rendering");
        this._stats.timeEnd("Overall");
        if ((_b2 = globalThis.Stats) == null ? void 0 : _b2.enabled) {
          globalThis.Stats.add(this.pageNumber, this._stats);
        }
      }
    };
    const internalRenderTask = new InternalRenderTask({
      callback: complete,
      params: {
        canvas,
        canvasContext,
        dependencyTracker: shouldRecordOperations ? new CanvasDependencyTracker(canvas, intentState.operatorList.length, recordForDebugger) : null,
        viewport,
        transform,
        background
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap,
      operatorList: intentState.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: this._transport.canvasFactory,
      filterFactory: this._transport.filterFactory,
      useRequestAnimationFrame: !intentPrint,
      pdfBug: this._pdfBug,
      pageColors,
      enableHWA: this._transport.enableHWA,
      operationsFilter
    });
    (intentState.renderTasks || (intentState.renderTasks = /* @__PURE__ */ new Set())).add(internalRenderTask);
    const renderTask = internalRenderTask.task;
    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
      var _a3;
      if (this.destroyed) {
        complete();
        return;
      }
      (_a3 = this._stats) == null ? void 0 : _a3.time("Rendering");
      if (!(optionalContentConfig.renderingIntent & renderingIntent)) {
        throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
      }
      internalRenderTask.initializeGraphics({
        transparency,
        optionalContentConfig
      });
      internalRenderTask.operatorListChanged();
    }).catch(complete);
    return renderTask;
  }
  getOperatorList({
    intent = "display",
    annotationMode = AnnotationMode.ENABLE,
    printAnnotationStorage = null,
    isEditing = false
  } = {}) {
    var _a2;
    function operatorListChanged() {
      if (intentState.operatorList.lastChunk) {
        intentState.opListReadCapability.resolve(intentState.operatorList);
        intentState.renderTasks.delete(opListTask);
      }
    }
    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);
    let intentState = this._intentStates.get(intentArgs.cacheKey);
    if (!intentState) {
      intentState = /* @__PURE__ */ Object.create(null);
      this._intentStates.set(intentArgs.cacheKey, intentState);
    }
    let opListTask;
    if (!intentState.opListReadCapability) {
      opListTask = /* @__PURE__ */ Object.create(null);
      opListTask.operatorListChanged = operatorListChanged;
      intentState.opListReadCapability = Promise.withResolvers();
      (intentState.renderTasks || (intentState.renderTasks = /* @__PURE__ */ new Set())).add(opListTask);
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };
      (_a2 = this._stats) == null ? void 0 : _a2.time("Page Request");
      this._pumpOperatorList(intentArgs);
    }
    return intentState.opListReadCapability.promise;
  }
  streamTextContent({
    includeMarkedContent = false,
    disableNormalization = false
  } = {}) {
    const TEXT_CONTENT_CHUNK_SIZE = 100;
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      includeMarkedContent: includeMarkedContent === true,
      disableNormalization: disableNormalization === true
    }, {
      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
      size(textContent) {
        return textContent.items.length;
      }
    });
  }
  getTextContent(params = {}) {
    if (this._transport._htmlForXfa) {
      return this.getXfa().then((xfa) => XfaText.textContent(xfa));
    }
    const readableStream = this.streamTextContent(params);
    return new Promise(function(resolve, reject) {
      function pump() {
        reader.read().then(function({
          value,
          done
        }) {
          if (done) {
            resolve(textContent);
            return;
          }
          textContent.lang ?? (textContent.lang = value.lang);
          Object.assign(textContent.styles, value.styles);
          textContent.items.push(...value.items);
          pump();
        }, reject);
      }
      const reader = readableStream.getReader();
      const textContent = {
        items: [],
        styles: /* @__PURE__ */ Object.create(null),
        lang: null
      };
      pump();
    });
  }
  getStructTree() {
    return this._transport.getStructTree(this._pageIndex);
  }
  _destroy() {
    this.destroyed = true;
    const waitOn = [];
    for (const intentState of this._intentStates.values()) {
      this._abortOperatorList({
        intentState,
        reason: new Error("Page was destroyed."),
        force: true
      });
      if (intentState.opListReadCapability) {
        continue;
      }
      for (const internalRenderTask of intentState.renderTasks) {
        waitOn.push(internalRenderTask.completed);
        internalRenderTask.cancel();
      }
    }
    this.objs.clear();
    __privateSet(this, _pendingCleanup, false);
    return Promise.all(waitOn);
  }
  cleanup(resetStats = false) {
    __privateSet(this, _pendingCleanup, true);
    const success = __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this);
    if (resetStats && success) {
      this._stats && (this._stats = new StatTimer());
    }
    return success;
  }
  _startRenderPage(transparency, cacheKey) {
    var _a2, _b;
    const intentState = this._intentStates.get(cacheKey);
    if (!intentState) {
      return;
    }
    (_a2 = this._stats) == null ? void 0 : _a2.timeEnd("Page Request");
    (_b = intentState.displayReadyCapability) == null ? void 0 : _b.resolve(transparency);
  }
  _renderPageChunk(operatorListChunk, intentState) {
    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
    }
    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
    intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
    for (const internalRenderTask of intentState.renderTasks) {
      internalRenderTask.operatorListChanged();
    }
    if (operatorListChunk.lastChunk) {
      __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this);
    }
  }
  _pumpOperatorList({
    renderingIntent,
    cacheKey,
    annotationStorageSerializable,
    modifiedIds
  }) {
    const {
      map,
      transfer
    } = annotationStorageSerializable;
    const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: renderingIntent,
      cacheKey,
      annotationStorage: map,
      modifiedIds
    }, transfer);
    const reader = readableStream.getReader();
    const intentState = this._intentStates.get(cacheKey);
    intentState.streamReader = reader;
    const pump = () => {
      reader.read().then(({
        value,
        done
      }) => {
        if (done) {
          intentState.streamReader = null;
          return;
        }
        if (this._transport.destroyed) {
          return;
        }
        this._renderPageChunk(value, intentState);
        pump();
      }, (reason) => {
        intentState.streamReader = null;
        if (this._transport.destroyed) {
          return;
        }
        if (intentState.operatorList) {
          intentState.operatorList.lastChunk = true;
          for (const internalRenderTask of intentState.renderTasks) {
            internalRenderTask.operatorListChanged();
          }
          __privateMethod(this, _tryCleanup, tryCleanup_fn).call(this);
        }
        if (intentState.displayReadyCapability) {
          intentState.displayReadyCapability.reject(reason);
        } else if (intentState.opListReadCapability) {
          intentState.opListReadCapability.reject(reason);
        } else {
          throw reason;
        }
      });
    };
    pump();
  }
  _abortOperatorList({
    intentState,
    reason,
    force = false
  }) {
    if (!intentState.streamReader) {
      return;
    }
    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }
    if (!force) {
      if (intentState.renderTasks.size > 0) {
        return;
      }
      if (reason instanceof RenderingCancelledException) {
        let delay = RENDERING_CANCELLED_TIMEOUT;
        if (reason.extraDelay > 0 && reason.extraDelay < 1e3) {
          delay += reason.extraDelay;
        }
        intentState.streamReaderCancelTimeout = setTimeout(() => {
          intentState.streamReaderCancelTimeout = null;
          this._abortOperatorList({
            intentState,
            reason,
            force: true
          });
        }, delay);
        return;
      }
    }
    intentState.streamReader.cancel(new AbortException(reason.message)).catch(() => {
    });
    intentState.streamReader = null;
    if (this._transport.destroyed) {
      return;
    }
    for (const [curCacheKey, curIntentState] of this._intentStates) {
      if (curIntentState === intentState) {
        this._intentStates.delete(curCacheKey);
        break;
      }
    }
    this.cleanup();
  }
  get stats() {
    return this._stats;
  }
};
_pendingCleanup = new WeakMap();
_tryCleanup = new WeakSet();
tryCleanup_fn = function() {
  if (!__privateGet(this, _pendingCleanup) || this.destroyed) {
    return false;
  }
  for (const {
    renderTasks,
    operatorList
  } of this._intentStates.values()) {
    if (renderTasks.size > 0 || !operatorList.lastChunk) {
      return false;
    }
  }
  this._intentStates.clear();
  this.objs.clear();
  __privateSet(this, _pendingCleanup, false);
  return true;
};
var _capability3, _messageHandler, _port2, _webWorker, _fakeWorkerId, _isWorkerDisabled, _workerPorts, _resolve, resolve_fn, _initializeFromPort, initializeFromPort_fn, _initialize, initialize_fn, _setupFakeWorker, setupFakeWorker_fn, _mainThreadWorkerMessageHandler, mainThreadWorkerMessageHandler_get;
var _PDFWorker = class _PDFWorker {
  constructor({
    name = null,
    port = null,
    verbosity: verbosity2 = getVerbosityLevel()
  } = {}) {
    __privateAdd(this, _resolve);
    __privateAdd(this, _initializeFromPort);
    __privateAdd(this, _initialize);
    __privateAdd(this, _setupFakeWorker);
    __privateAdd(this, _capability3, Promise.withResolvers());
    __privateAdd(this, _messageHandler, null);
    __privateAdd(this, _port2, null);
    __privateAdd(this, _webWorker, null);
    this.name = name;
    this.destroyed = false;
    this.verbosity = verbosity2;
    if (port) {
      if (__privateGet(_PDFWorker, _workerPorts).has(port)) {
        throw new Error("Cannot use more than one PDFWorker per port.");
      }
      __privateGet(_PDFWorker, _workerPorts).set(port, this);
      __privateMethod(this, _initializeFromPort, initializeFromPort_fn).call(this, port);
    } else {
      __privateMethod(this, _initialize, initialize_fn).call(this);
    }
  }
  get promise() {
    return __privateGet(this, _capability3).promise;
  }
  get port() {
    return __privateGet(this, _port2);
  }
  get messageHandler() {
    return __privateGet(this, _messageHandler);
  }
  destroy() {
    var _a2, _b;
    this.destroyed = true;
    (_a2 = __privateGet(this, _webWorker)) == null ? void 0 : _a2.terminate();
    __privateSet(this, _webWorker, null);
    __privateGet(_PDFWorker, _workerPorts).delete(__privateGet(this, _port2));
    __privateSet(this, _port2, null);
    (_b = __privateGet(this, _messageHandler)) == null ? void 0 : _b.destroy();
    __privateSet(this, _messageHandler, null);
  }
  static create(params) {
    const cachedPort = __privateGet(this, _workerPorts).get(params == null ? void 0 : params.port);
    if (cachedPort) {
      if (cachedPort._pendingDestroy) {
        throw new Error("PDFWorker.create - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
      }
      return cachedPort;
    }
    return new _PDFWorker(params);
  }
  static get workerSrc() {
    if (GlobalWorkerOptions.workerSrc) {
      return GlobalWorkerOptions.workerSrc;
    }
    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }
  static get _setupFakeWorkerGlobal() {
    const loader = async () => {
      if (__privateGet(this, _mainThreadWorkerMessageHandler, mainThreadWorkerMessageHandler_get)) {
        return __privateGet(this, _mainThreadWorkerMessageHandler, mainThreadWorkerMessageHandler_get);
      }
      const worker = await import(
        /*webpackIgnore: true*/
        /*@vite-ignore*/
        this.workerSrc
      );
      return worker.WorkerMessageHandler;
    };
    return shadow(this, "_setupFakeWorkerGlobal", loader());
  }
};
_capability3 = new WeakMap();
_messageHandler = new WeakMap();
_port2 = new WeakMap();
_webWorker = new WeakMap();
_fakeWorkerId = new WeakMap();
_isWorkerDisabled = new WeakMap();
_workerPorts = new WeakMap();
_resolve = new WeakSet();
resolve_fn = function() {
  __privateGet(this, _capability3).resolve();
  __privateGet(this, _messageHandler).send("configure", {
    verbosity: this.verbosity
  });
};
_initializeFromPort = new WeakSet();
initializeFromPort_fn = function(port) {
  __privateSet(this, _port2, port);
  __privateSet(this, _messageHandler, new MessageHandler("main", "worker", port));
  __privateGet(this, _messageHandler).on("ready", () => {
  });
  __privateMethod(this, _resolve, resolve_fn).call(this);
};
_initialize = new WeakSet();
initialize_fn = function() {
  if (__privateGet(_PDFWorker, _isWorkerDisabled) || __privateGet(_PDFWorker, _mainThreadWorkerMessageHandler, mainThreadWorkerMessageHandler_get)) {
    __privateMethod(this, _setupFakeWorker, setupFakeWorker_fn).call(this);
    return;
  }
  let {
    workerSrc
  } = _PDFWorker;
  try {
    if (!_PDFWorker._isSameOrigin(window.location, workerSrc)) {
      workerSrc = _PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);
    }
    const worker = new Worker(workerSrc, {
      type: "module"
    });
    const messageHandler = new MessageHandler("main", "worker", worker);
    const terminateEarly = () => {
      ac.abort();
      messageHandler.destroy();
      worker.terminate();
      if (this.destroyed) {
        __privateGet(this, _capability3).reject(new Error("Worker was destroyed"));
      } else {
        __privateMethod(this, _setupFakeWorker, setupFakeWorker_fn).call(this);
      }
    };
    const ac = new AbortController();
    worker.addEventListener("error", () => {
      if (!__privateGet(this, _webWorker)) {
        terminateEarly();
      }
    }, {
      signal: ac.signal
    });
    messageHandler.on("test", (data) => {
      ac.abort();
      if (this.destroyed || !data) {
        terminateEarly();
        return;
      }
      __privateSet(this, _messageHandler, messageHandler);
      __privateSet(this, _port2, worker);
      __privateSet(this, _webWorker, worker);
      __privateMethod(this, _resolve, resolve_fn).call(this);
    });
    messageHandler.on("ready", (data) => {
      ac.abort();
      if (this.destroyed) {
        terminateEarly();
        return;
      }
      try {
        sendTest();
      } catch {
        __privateMethod(this, _setupFakeWorker, setupFakeWorker_fn).call(this);
      }
    });
    const sendTest = () => {
      const testObj = new Uint8Array();
      messageHandler.send("test", testObj, [testObj.buffer]);
    };
    sendTest();
    return;
  } catch {
    info("The worker has been disabled.");
  }
  __privateMethod(this, _setupFakeWorker, setupFakeWorker_fn).call(this);
};
_setupFakeWorker = new WeakSet();
setupFakeWorker_fn = function() {
  if (!__privateGet(_PDFWorker, _isWorkerDisabled)) {
    warn("Setting up fake worker.");
    __privateSet(_PDFWorker, _isWorkerDisabled, true);
  }
  _PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler) => {
    if (this.destroyed) {
      __privateGet(this, _capability3).reject(new Error("Worker was destroyed"));
      return;
    }
    const port = new LoopbackPort();
    __privateSet(this, _port2, port);
    const id = `fake${__privateWrapper(_PDFWorker, _fakeWorkerId)._++}`;
    const workerHandler = new MessageHandler(id + "_worker", id, port);
    WorkerMessageHandler.setup(workerHandler, port);
    __privateSet(this, _messageHandler, new MessageHandler(id, id + "_worker", port));
    __privateMethod(this, _resolve, resolve_fn).call(this);
  }).catch((reason) => {
    __privateGet(this, _capability3).reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
  });
};
_mainThreadWorkerMessageHandler = new WeakSet();
mainThreadWorkerMessageHandler_get = function() {
  var _a2;
  try {
    return ((_a2 = globalThis.pdfjsWorker) == null ? void 0 : _a2.WorkerMessageHandler) || null;
  } catch {
    return null;
  }
};
__privateAdd(_PDFWorker, _mainThreadWorkerMessageHandler);
__privateAdd(_PDFWorker, _fakeWorkerId, 0);
__privateAdd(_PDFWorker, _isWorkerDisabled, false);
__privateAdd(_PDFWorker, _workerPorts, /* @__PURE__ */ new WeakMap());
(() => {
  if (isNodeJS) {
    __privateSet(_PDFWorker, _isWorkerDisabled, true);
    GlobalWorkerOptions.workerSrc || (GlobalWorkerOptions.workerSrc = "./pdf.worker.mjs");
  }
  _PDFWorker._isSameOrigin = (baseUrl, otherUrl) => {
    const base = URL.parse(baseUrl);
    if (!(base == null ? void 0 : base.origin) || base.origin === "null") {
      return false;
    }
    const other = new URL(otherUrl, base);
    return base.origin === other.origin;
  };
  _PDFWorker._createCDNWrapper = (url) => {
    const wrapper = `await import("${url}");`;
    return URL.createObjectURL(new Blob([wrapper], {
      type: "text/javascript"
    }));
  };
  _PDFWorker.fromPort = (params) => {
    deprecated("`PDFWorker.fromPort` - please use `PDFWorker.create` instead.");
    if (!(params == null ? void 0 : params.port)) {
      throw new Error("PDFWorker.fromPort - invalid method signature.");
    }
    return _PDFWorker.create(params);
  };
})();
var PDFWorker = _PDFWorker;
var _methodPromises, _pageCache, _pagePromises, _pageRefCache, _passwordCapability, _cacheSimpleMethod, cacheSimpleMethod_fn;
var WorkerTransport = class {
  constructor(messageHandler, loadingTask, networkStream, params, factory, enableHWA) {
    __privateAdd(this, _cacheSimpleMethod);
    __privateAdd(this, _methodPromises, /* @__PURE__ */ new Map());
    __privateAdd(this, _pageCache, /* @__PURE__ */ new Map());
    __privateAdd(this, _pagePromises, /* @__PURE__ */ new Map());
    __privateAdd(this, _pageRefCache, /* @__PURE__ */ new Map());
    __privateAdd(this, _passwordCapability, null);
    this.messageHandler = messageHandler;
    this.loadingTask = loadingTask;
    this.commonObjs = new PDFObjects();
    this.fontLoader = new FontLoader({
      ownerDocument: params.ownerDocument,
      styleElement: params.styleElement
    });
    this.loadingParams = params.loadingParams;
    this._params = params;
    this.canvasFactory = factory.canvasFactory;
    this.filterFactory = factory.filterFactory;
    this.cMapReaderFactory = factory.cMapReaderFactory;
    this.standardFontDataFactory = factory.standardFontDataFactory;
    this.wasmFactory = factory.wasmFactory;
    this.destroyed = false;
    this.destroyCapability = null;
    this._networkStream = networkStream;
    this._fullReader = null;
    this._lastProgress = null;
    this.downloadInfoCapability = Promise.withResolvers();
    this.enableHWA = enableHWA;
    this.setupMessageHandler();
  }
  get annotationStorage() {
    return shadow(this, "annotationStorage", new AnnotationStorage());
  }
  getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {
    let renderingIntent = RenderingIntentFlag.DISPLAY;
    let annotationStorageSerializable = SerializableEmpty;
    switch (intent) {
      case "any":
        renderingIntent = RenderingIntentFlag.ANY;
        break;
      case "display":
        break;
      case "print":
        renderingIntent = RenderingIntentFlag.PRINT;
        break;
      default:
        warn(`getRenderingIntent - invalid intent: ${intent}`);
    }
    const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
    switch (annotationMode) {
      case AnnotationMode.DISABLE:
        renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;
        break;
      case AnnotationMode.ENABLE:
        break;
      case AnnotationMode.ENABLE_FORMS:
        renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;
        break;
      case AnnotationMode.ENABLE_STORAGE:
        renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;
        annotationStorageSerializable = annotationStorage.serializable;
        break;
      default:
        warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
    }
    if (isEditing) {
      renderingIntent += RenderingIntentFlag.IS_EDITING;
    }
    if (isOpList) {
      renderingIntent += RenderingIntentFlag.OPLIST;
    }
    const {
      ids: modifiedIds,
      hash: modifiedIdsHash
    } = annotationStorage.modifiedIds;
    const cacheKeyBuf = [renderingIntent, annotationStorageSerializable.hash, modifiedIdsHash];
    return {
      renderingIntent,
      cacheKey: cacheKeyBuf.join("_"),
      annotationStorageSerializable,
      modifiedIds
    };
  }
  destroy() {
    var _a2;
    if (this.destroyCapability) {
      return this.destroyCapability.promise;
    }
    this.destroyed = true;
    this.destroyCapability = Promise.withResolvers();
    (_a2 = __privateGet(this, _passwordCapability)) == null ? void 0 : _a2.reject(new Error("Worker was destroyed during onPassword callback"));
    const waitOn = [];
    for (const page of __privateGet(this, _pageCache).values()) {
      waitOn.push(page._destroy());
    }
    __privateGet(this, _pageCache).clear();
    __privateGet(this, _pagePromises).clear();
    __privateGet(this, _pageRefCache).clear();
    if (this.hasOwnProperty("annotationStorage")) {
      this.annotationStorage.resetModified();
    }
    const terminated = this.messageHandler.sendWithPromise("Terminate", null);
    waitOn.push(terminated);
    Promise.all(waitOn).then(() => {
      var _a3, _b;
      this.commonObjs.clear();
      this.fontLoader.clear();
      __privateGet(this, _methodPromises).clear();
      this.filterFactory.destroy();
      TextLayer.cleanup();
      (_a3 = this._networkStream) == null ? void 0 : _a3.cancelAllRequests(new AbortException("Worker was terminated."));
      (_b = this.messageHandler) == null ? void 0 : _b.destroy();
      this.messageHandler = null;
      this.destroyCapability.resolve();
    }, this.destroyCapability.reject);
    return this.destroyCapability.promise;
  }
  setupMessageHandler() {
    const {
      messageHandler,
      loadingTask
    } = this;
    messageHandler.on("GetReader", (data, sink) => {
      assert(this._networkStream, "GetReader - no `IPDFStream` instance available.");
      this._fullReader = this._networkStream.getFullReader();
      this._fullReader.onProgress = (evt) => {
        this._lastProgress = {
          loaded: evt.loaded,
          total: evt.total
        };
      };
      sink.onPull = () => {
        this._fullReader.read().then(function({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }
          assert(value instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch((reason) => {
          sink.error(reason);
        });
      };
      sink.onCancel = (reason) => {
        this._fullReader.cancel(reason);
        sink.ready.catch((readyReason) => {
          if (this.destroyed) {
            return;
          }
          throw readyReason;
        });
      };
    });
    messageHandler.on("ReaderHeadersReady", async (data) => {
      var _a2;
      await this._fullReader.headersReady;
      const {
        isStreamingSupported,
        isRangeSupported,
        contentLength
      } = this._fullReader;
      if (!isStreamingSupported || !isRangeSupported) {
        if (this._lastProgress) {
          (_a2 = loadingTask.onProgress) == null ? void 0 : _a2.call(loadingTask, this._lastProgress);
        }
        this._fullReader.onProgress = (evt) => {
          var _a3;
          (_a3 = loadingTask.onProgress) == null ? void 0 : _a3.call(loadingTask, {
            loaded: evt.loaded,
            total: evt.total
          });
        };
      }
      return {
        isStreamingSupported,
        isRangeSupported,
        contentLength
      };
    });
    messageHandler.on("GetRangeReader", (data, sink) => {
      assert(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
      if (!rangeReader) {
        sink.close();
        return;
      }
      sink.onPull = () => {
        rangeReader.read().then(function({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }
          assert(value instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch((reason) => {
          sink.error(reason);
        });
      };
      sink.onCancel = (reason) => {
        rangeReader.cancel(reason);
        sink.ready.catch((readyReason) => {
          if (this.destroyed) {
            return;
          }
          throw readyReason;
        });
      };
    });
    messageHandler.on("GetDoc", ({
      pdfInfo
    }) => {
      this._numPages = pdfInfo.numPages;
      this._htmlForXfa = pdfInfo.htmlForXfa;
      delete pdfInfo.htmlForXfa;
      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
    });
    messageHandler.on("DocException", (ex) => {
      loadingTask._capability.reject(wrapReason(ex));
    });
    messageHandler.on("PasswordRequest", (ex) => {
      __privateSet(this, _passwordCapability, Promise.withResolvers());
      try {
        if (!loadingTask.onPassword) {
          throw wrapReason(ex);
        }
        const updatePassword = (password) => {
          if (password instanceof Error) {
            __privateGet(this, _passwordCapability).reject(password);
          } else {
            __privateGet(this, _passwordCapability).resolve({
              password
            });
          }
        };
        loadingTask.onPassword(updatePassword, ex.code);
      } catch (err) {
        __privateGet(this, _passwordCapability).reject(err);
      }
      return __privateGet(this, _passwordCapability).promise;
    });
    messageHandler.on("DataLoaded", (data) => {
      var _a2;
      (_a2 = loadingTask.onProgress) == null ? void 0 : _a2.call(loadingTask, {
        loaded: data.length,
        total: data.length
      });
      this.downloadInfoCapability.resolve(data);
    });
    messageHandler.on("StartRenderPage", (data) => {
      if (this.destroyed) {
        return;
      }
      const page = __privateGet(this, _pageCache).get(data.pageIndex);
      page._startRenderPage(data.transparency, data.cacheKey);
    });
    messageHandler.on("commonobj", ([id, type, exportedData]) => {
      var _a2;
      if (this.destroyed) {
        return null;
      }
      if (this.commonObjs.has(id)) {
        return null;
      }
      switch (type) {
        case "Font":
          if ("error" in exportedData) {
            const exportedError = exportedData.error;
            warn(`Error during font loading: ${exportedError}`);
            this.commonObjs.resolve(id, exportedError);
            break;
          }
          const fontData = new FontInfo(exportedData);
          const inspectFont = this._params.pdfBug && ((_a2 = globalThis.FontInspector) == null ? void 0 : _a2.enabled) ? (font2, url) => globalThis.FontInspector.fontAdded(font2, url) : null;
          const font = new FontFaceObject(fontData, inspectFont, exportedData.extra, exportedData.charProcOperatorList);
          this.fontLoader.bind(font).catch(() => messageHandler.sendWithPromise("FontFallback", {
            id
          })).finally(() => {
            if (!font.fontExtraProperties && font.data) {
              font.clearData();
            }
            this.commonObjs.resolve(id, font);
          });
          break;
        case "CopyLocalImage":
          const {
            imageRef
          } = exportedData;
          assert(imageRef, "The imageRef must be defined.");
          for (const pageProxy of __privateGet(this, _pageCache).values()) {
            for (const [, data] of pageProxy.objs) {
              if ((data == null ? void 0 : data.ref) !== imageRef) {
                continue;
              }
              if (!data.dataLen) {
                return null;
              }
              this.commonObjs.resolve(id, structuredClone(data));
              return data.dataLen;
            }
          }
          break;
        case "FontPath":
        case "Image":
        case "Pattern":
          this.commonObjs.resolve(id, exportedData);
          break;
        default:
          throw new Error(`Got unknown common object type ${type}`);
      }
      return null;
    });
    messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
      var _a2;
      if (this.destroyed) {
        return;
      }
      const pageProxy = __privateGet(this, _pageCache).get(pageIndex);
      if (pageProxy.objs.has(id)) {
        return;
      }
      if (pageProxy._intentStates.size === 0) {
        (_a2 = imageData == null ? void 0 : imageData.bitmap) == null ? void 0 : _a2.close();
        return;
      }
      switch (type) {
        case "Image":
        case "Pattern":
          pageProxy.objs.resolve(id, imageData);
          break;
        default:
          throw new Error(`Got unknown object type ${type}`);
      }
    });
    messageHandler.on("DocProgress", (data) => {
      var _a2;
      if (this.destroyed) {
        return;
      }
      (_a2 = loadingTask.onProgress) == null ? void 0 : _a2.call(loadingTask, {
        loaded: data.loaded,
        total: data.total
      });
    });
    messageHandler.on("FetchBinaryData", async (data) => {
      if (this.destroyed) {
        throw new Error("Worker was destroyed.");
      }
      const factory = this[data.type];
      if (!factory) {
        throw new Error(`${data.type} not initialized, see the \`useWorkerFetch\` parameter.`);
      }
      return factory.fetch(data);
    });
  }
  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }
  saveDocument() {
    var _a2;
    if (this.annotationStorage.size <= 0) {
      warn("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
    }
    const {
      map,
      transfer
    } = this.annotationStorage.serializable;
    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: map,
      filename: ((_a2 = this._fullReader) == null ? void 0 : _a2.filename) ?? null
    }, transfer).finally(() => {
      this.annotationStorage.resetModified();
    });
  }
  getPage(pageNumber) {
    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
      return Promise.reject(new Error("Invalid page request."));
    }
    const pageIndex = pageNumber - 1, cachedPromise = __privateGet(this, _pagePromises).get(pageIndex);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex
    }).then((pageInfo) => {
      if (this.destroyed) {
        throw new Error("Transport destroyed");
      }
      if (pageInfo.refStr) {
        __privateGet(this, _pageRefCache).set(pageInfo.refStr, pageNumber);
      }
      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);
      __privateGet(this, _pageCache).set(pageIndex, page);
      return page;
    });
    __privateGet(this, _pagePromises).set(pageIndex, promise);
    return promise;
  }
  getPageIndex(ref) {
    if (!isRefProxy(ref)) {
      return Promise.reject(new Error("Invalid pageIndex request."));
    }
    return this.messageHandler.sendWithPromise("GetPageIndex", {
      num: ref.num,
      gen: ref.gen
    });
  }
  getAnnotations(pageIndex, intent) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex,
      intent
    });
  }
  getFieldObjects() {
    return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "GetFieldObjects");
  }
  hasJSActions() {
    return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "HasJSActions");
  }
  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }
  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }
  getDestination(id) {
    if (typeof id !== "string") {
      return Promise.reject(new Error("Invalid destination request."));
    }
    return this.messageHandler.sendWithPromise("GetDestination", {
      id
    });
  }
  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }
  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }
  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }
  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }
  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }
  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }
  getAnnotationsByType(types, pageIndexesToSkip) {
    return this.messageHandler.sendWithPromise("GetAnnotationsByType", {
      types,
      pageIndexesToSkip
    });
  }
  getDocJSActions() {
    return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "GetDocJSActions");
  }
  getPageJSActions(pageIndex) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex
    });
  }
  getStructTree(pageIndex) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex
    });
  }
  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }
  getOptionalContentConfig(renderingIntent) {
    return __privateMethod(this, _cacheSimpleMethod, cacheSimpleMethod_fn).call(this, "GetOptionalContentConfig").then((data) => new OptionalContentConfig(data, renderingIntent));
  }
  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }
  getMetadata() {
    const name = "GetMetadata", cachedPromise = __privateGet(this, _methodPromises).get(name);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise(name, null).then((results) => {
      var _a2, _b;
      return {
        info: results[0],
        metadata: results[1] ? new Metadata(results[1]) : null,
        contentDispositionFilename: ((_a2 = this._fullReader) == null ? void 0 : _a2.filename) ?? null,
        contentLength: ((_b = this._fullReader) == null ? void 0 : _b.contentLength) ?? null
      };
    });
    __privateGet(this, _methodPromises).set(name, promise);
    return promise;
  }
  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }
  async startCleanup(keepLoadedFonts = false) {
    if (this.destroyed) {
      return;
    }
    await this.messageHandler.sendWithPromise("Cleanup", null);
    for (const page of __privateGet(this, _pageCache).values()) {
      const cleanupSuccessful = page.cleanup();
      if (!cleanupSuccessful) {
        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
      }
    }
    this.commonObjs.clear();
    if (!keepLoadedFonts) {
      this.fontLoader.clear();
    }
    __privateGet(this, _methodPromises).clear();
    this.filterFactory.destroy(true);
    TextLayer.cleanup();
  }
  cachedPageNumber(ref) {
    if (!isRefProxy(ref)) {
      return null;
    }
    const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;
    return __privateGet(this, _pageRefCache).get(refStr) ?? null;
  }
};
_methodPromises = new WeakMap();
_pageCache = new WeakMap();
_pagePromises = new WeakMap();
_pageRefCache = new WeakMap();
_passwordCapability = new WeakMap();
_cacheSimpleMethod = new WeakSet();
cacheSimpleMethod_fn = function(name, data = null) {
  const cachedPromise = __privateGet(this, _methodPromises).get(name);
  if (cachedPromise) {
    return cachedPromise;
  }
  const promise = this.messageHandler.sendWithPromise(name, data);
  __privateGet(this, _methodPromises).set(name, promise);
  return promise;
};
var _internalRenderTask;
var RenderTask = class {
  constructor(internalRenderTask) {
    __privateAdd(this, _internalRenderTask, null);
    __publicField(this, "onContinue", null);
    __publicField(this, "onError", null);
    __privateSet(this, _internalRenderTask, internalRenderTask);
  }
  get promise() {
    return __privateGet(this, _internalRenderTask).capability.promise;
  }
  cancel(extraDelay = 0) {
    __privateGet(this, _internalRenderTask).cancel(null, extraDelay);
  }
  get separateAnnots() {
    const {
      separateAnnots
    } = __privateGet(this, _internalRenderTask).operatorList;
    if (!separateAnnots) {
      return false;
    }
    const {
      annotationCanvasMap
    } = __privateGet(this, _internalRenderTask);
    return separateAnnots.form || separateAnnots.canvas && (annotationCanvasMap == null ? void 0 : annotationCanvasMap.size) > 0;
  }
};
_internalRenderTask = new WeakMap();
var _rAF, _canvasInUse;
var _InternalRenderTask = class _InternalRenderTask {
  constructor({
    callback,
    params,
    objs,
    commonObjs,
    annotationCanvasMap,
    operatorList,
    pageIndex,
    canvasFactory,
    filterFactory,
    useRequestAnimationFrame = false,
    pdfBug = false,
    pageColors = null,
    enableHWA = false,
    operationsFilter = null
  }) {
    __privateAdd(this, _rAF, null);
    this.callback = callback;
    this.params = params;
    this.objs = objs;
    this.commonObjs = commonObjs;
    this.annotationCanvasMap = annotationCanvasMap;
    this.operatorListIdx = null;
    this.operatorList = operatorList;
    this._pageIndex = pageIndex;
    this.canvasFactory = canvasFactory;
    this.filterFactory = filterFactory;
    this._pdfBug = pdfBug;
    this.pageColors = pageColors;
    this.running = false;
    this.graphicsReadyCallback = null;
    this.graphicsReady = false;
    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
    this.cancelled = false;
    this.capability = Promise.withResolvers();
    this.task = new RenderTask(this);
    this._cancelBound = this.cancel.bind(this);
    this._continueBound = this._continue.bind(this);
    this._scheduleNextBound = this._scheduleNext.bind(this);
    this._nextBound = this._next.bind(this);
    this._canvas = params.canvas;
    this._canvasContext = params.canvas ? null : params.canvasContext;
    this._enableHWA = enableHWA;
    this._dependencyTracker = params.dependencyTracker;
    this._operationsFilter = operationsFilter;
  }
  get completed() {
    return this.capability.promise.catch(function() {
    });
  }
  initializeGraphics({
    transparency = false,
    optionalContentConfig
  }) {
    var _a2, _b;
    if (this.cancelled) {
      return;
    }
    if (this._canvas) {
      if (__privateGet(_InternalRenderTask, _canvasInUse).has(this._canvas)) {
        throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
      }
      __privateGet(_InternalRenderTask, _canvasInUse).add(this._canvas);
    }
    if (this._pdfBug && ((_a2 = globalThis.StepperManager) == null ? void 0 : _a2.enabled)) {
      this.stepper = globalThis.StepperManager.create(this._pageIndex);
      this.stepper.init(this.operatorList);
      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
    }
    const {
      viewport,
      transform,
      background,
      dependencyTracker
    } = this.params;
    const canvasContext = this._canvasContext || this._canvas.getContext("2d", {
      alpha: false,
      willReadFrequently: !this._enableHWA
    });
    this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
      optionalContentConfig
    }, this.annotationCanvasMap, this.pageColors, dependencyTracker);
    this.gfx.beginDrawing({
      transform,
      viewport,
      transparency,
      background
    });
    this.operatorListIdx = 0;
    this.graphicsReady = true;
    (_b = this.graphicsReadyCallback) == null ? void 0 : _b.call(this);
  }
  cancel(error = null, extraDelay = 0) {
    var _a2, _b, _c;
    this.running = false;
    this.cancelled = true;
    (_a2 = this.gfx) == null ? void 0 : _a2.endDrawing();
    if (__privateGet(this, _rAF)) {
      window.cancelAnimationFrame(__privateGet(this, _rAF));
      __privateSet(this, _rAF, null);
    }
    __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
    error || (error = new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));
    this.callback(error);
    (_c = (_b = this.task).onError) == null ? void 0 : _c.call(_b, error);
  }
  operatorListChanged() {
    var _a2, _b;
    if (!this.graphicsReady) {
      this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
      return;
    }
    (_a2 = this.gfx.dependencyTracker) == null ? void 0 : _a2.growOperationsCount(this.operatorList.fnArray.length);
    (_b = this.stepper) == null ? void 0 : _b.updateOperatorList(this.operatorList);
    if (this.running) {
      return;
    }
    this._continue();
  }
  _continue() {
    this.running = true;
    if (this.cancelled) {
      return;
    }
    if (this.task.onContinue) {
      this.task.onContinue(this._scheduleNextBound);
    } else {
      this._scheduleNext();
    }
  }
  _scheduleNext() {
    if (this._useRequestAnimationFrame) {
      __privateSet(this, _rAF, window.requestAnimationFrame(() => {
        __privateSet(this, _rAF, null);
        this._nextBound().catch(this._cancelBound);
      }));
    } else {
      Promise.resolve().then(this._nextBound).catch(this._cancelBound);
    }
  }
  async _next() {
    if (this.cancelled) {
      return;
    }
    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._operationsFilter);
    if (this.operatorListIdx === this.operatorList.argsArray.length) {
      this.running = false;
      if (this.operatorList.lastChunk) {
        this.gfx.endDrawing();
        __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
        this.callback();
      }
    }
  }
};
_rAF = new WeakMap();
_canvasInUse = new WeakMap();
__privateAdd(_InternalRenderTask, _canvasInUse, /* @__PURE__ */ new WeakSet());
var InternalRenderTask = _InternalRenderTask;
var version = "5.4.296";
var build = "f56dc8601";
var _button, _buttonSwatch, _defaultColor, _dropdown, _dropdownWasFromKeyboard, _isMainColorPicker, _editor4, _eventBus, _openDropdownAC, _uiManager2, _l10nColor, _getDropdownRoot, getDropdownRoot_fn, _colorSelect, colorSelect_fn, _keyDown, keyDown_fn, _openDropdown, openDropdown_fn, _pointerDown2, pointerDown_fn2, _isDropdownVisible, isDropdownVisible_get;
var _ColorPicker = class _ColorPicker {
  constructor({
    editor = null,
    uiManager = null
  }) {
    __privateAdd(this, _getDropdownRoot);
    __privateAdd(this, _colorSelect);
    __privateAdd(this, _keyDown);
    __privateAdd(this, _openDropdown);
    __privateAdd(this, _pointerDown2);
    __privateAdd(this, _isDropdownVisible);
    __privateAdd(this, _button, null);
    __privateAdd(this, _buttonSwatch, null);
    __privateAdd(this, _defaultColor, void 0);
    __privateAdd(this, _dropdown, null);
    __privateAdd(this, _dropdownWasFromKeyboard, false);
    __privateAdd(this, _isMainColorPicker, false);
    __privateAdd(this, _editor4, null);
    __privateAdd(this, _eventBus, void 0);
    __privateAdd(this, _openDropdownAC, null);
    __privateAdd(this, _uiManager2, null);
    var _a2, _b;
    if (editor) {
      __privateSet(this, _isMainColorPicker, false);
      __privateSet(this, _editor4, editor);
    } else {
      __privateSet(this, _isMainColorPicker, true);
    }
    __privateSet(this, _uiManager2, (editor == null ? void 0 : editor._uiManager) || uiManager);
    __privateSet(this, _eventBus, __privateGet(this, _uiManager2)._eventBus);
    __privateSet(this, _defaultColor, ((_a2 = editor == null ? void 0 : editor.color) == null ? void 0 : _a2.toUpperCase()) || ((_b = __privateGet(this, _uiManager2)) == null ? void 0 : _b.highlightColors.values().next().value) || "#FFFF98");
    __privateGet(_ColorPicker, _l10nColor) || __privateSet(_ColorPicker, _l10nColor, Object.freeze({
      blue: "pdfjs-editor-colorpicker-blue",
      green: "pdfjs-editor-colorpicker-green",
      pink: "pdfjs-editor-colorpicker-pink",
      red: "pdfjs-editor-colorpicker-red",
      yellow: "pdfjs-editor-colorpicker-yellow"
    }));
  }
  static get _keyboardManager() {
    return shadow(this, "_keyboardManager", new KeyboardManager([[["Escape", "mac+Escape"], _ColorPicker.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], _ColorPicker.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], _ColorPicker.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], _ColorPicker.prototype._moveToPrevious], [["Home", "mac+Home"], _ColorPicker.prototype._moveToBeginning], [["End", "mac+End"], _ColorPicker.prototype._moveToEnd]]));
  }
  renderButton() {
    const button = __privateSet(this, _button, document.createElement("button"));
    button.className = "colorPicker";
    button.tabIndex = "0";
    button.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button");
    button.ariaHasPopup = "true";
    if (__privateGet(this, _editor4)) {
      button.ariaControls = `${__privateGet(this, _editor4).id}_colorpicker_dropdown`;
    }
    const signal = __privateGet(this, _uiManager2)._signal;
    button.addEventListener("click", __privateMethod(this, _openDropdown, openDropdown_fn).bind(this), {
      signal
    });
    button.addEventListener("keydown", __privateMethod(this, _keyDown, keyDown_fn).bind(this), {
      signal
    });
    const swatch = __privateSet(this, _buttonSwatch, document.createElement("span"));
    swatch.className = "swatch";
    swatch.ariaHidden = "true";
    swatch.style.backgroundColor = __privateGet(this, _defaultColor);
    button.append(swatch);
    return button;
  }
  renderMainDropdown() {
    const dropdown = __privateSet(this, _dropdown, __privateMethod(this, _getDropdownRoot, getDropdownRoot_fn).call(this));
    dropdown.ariaOrientation = "horizontal";
    dropdown.ariaLabelledBy = "highlightColorPickerLabel";
    return dropdown;
  }
  _colorSelectFromKeyboard(event) {
    if (event.target === __privateGet(this, _button)) {
      __privateMethod(this, _openDropdown, openDropdown_fn).call(this, event);
      return;
    }
    const color = event.target.getAttribute("data-color");
    if (!color) {
      return;
    }
    __privateMethod(this, _colorSelect, colorSelect_fn).call(this, color, event);
  }
  _moveToNext(event) {
    var _a2, _b;
    if (!__privateGet(this, _isDropdownVisible, isDropdownVisible_get)) {
      __privateMethod(this, _openDropdown, openDropdown_fn).call(this, event);
      return;
    }
    if (event.target === __privateGet(this, _button)) {
      (_a2 = __privateGet(this, _dropdown).firstChild) == null ? void 0 : _a2.focus();
      return;
    }
    (_b = event.target.nextSibling) == null ? void 0 : _b.focus();
  }
  _moveToPrevious(event) {
    var _a2, _b;
    if (event.target === ((_a2 = __privateGet(this, _dropdown)) == null ? void 0 : _a2.firstChild) || event.target === __privateGet(this, _button)) {
      if (__privateGet(this, _isDropdownVisible, isDropdownVisible_get)) {
        this._hideDropdownFromKeyboard();
      }
      return;
    }
    if (!__privateGet(this, _isDropdownVisible, isDropdownVisible_get)) {
      __privateMethod(this, _openDropdown, openDropdown_fn).call(this, event);
    }
    (_b = event.target.previousSibling) == null ? void 0 : _b.focus();
  }
  _moveToBeginning(event) {
    var _a2;
    if (!__privateGet(this, _isDropdownVisible, isDropdownVisible_get)) {
      __privateMethod(this, _openDropdown, openDropdown_fn).call(this, event);
      return;
    }
    (_a2 = __privateGet(this, _dropdown).firstChild) == null ? void 0 : _a2.focus();
  }
  _moveToEnd(event) {
    var _a2;
    if (!__privateGet(this, _isDropdownVisible, isDropdownVisible_get)) {
      __privateMethod(this, _openDropdown, openDropdown_fn).call(this, event);
      return;
    }
    (_a2 = __privateGet(this, _dropdown).lastChild) == null ? void 0 : _a2.focus();
  }
  hideDropdown() {
    var _a2, _b;
    (_a2 = __privateGet(this, _dropdown)) == null ? void 0 : _a2.classList.add("hidden");
    __privateGet(this, _button).ariaExpanded = "false";
    (_b = __privateGet(this, _openDropdownAC)) == null ? void 0 : _b.abort();
    __privateSet(this, _openDropdownAC, null);
  }
  _hideDropdownFromKeyboard() {
    var _a2;
    if (__privateGet(this, _isMainColorPicker)) {
      return;
    }
    if (!__privateGet(this, _isDropdownVisible, isDropdownVisible_get)) {
      (_a2 = __privateGet(this, _editor4)) == null ? void 0 : _a2.unselect();
      return;
    }
    this.hideDropdown();
    __privateGet(this, _button).focus({
      preventScroll: true,
      focusVisible: __privateGet(this, _dropdownWasFromKeyboard)
    });
  }
  updateColor(color) {
    if (__privateGet(this, _buttonSwatch)) {
      __privateGet(this, _buttonSwatch).style.backgroundColor = color;
    }
    if (!__privateGet(this, _dropdown)) {
      return;
    }
    const i = __privateGet(this, _uiManager2).highlightColors.values();
    for (const child of __privateGet(this, _dropdown).children) {
      child.ariaSelected = i.next().value === color.toUpperCase();
    }
  }
  destroy() {
    var _a2, _b;
    (_a2 = __privateGet(this, _button)) == null ? void 0 : _a2.remove();
    __privateSet(this, _button, null);
    __privateSet(this, _buttonSwatch, null);
    (_b = __privateGet(this, _dropdown)) == null ? void 0 : _b.remove();
    __privateSet(this, _dropdown, null);
  }
};
_button = new WeakMap();
_buttonSwatch = new WeakMap();
_defaultColor = new WeakMap();
_dropdown = new WeakMap();
_dropdownWasFromKeyboard = new WeakMap();
_isMainColorPicker = new WeakMap();
_editor4 = new WeakMap();
_eventBus = new WeakMap();
_openDropdownAC = new WeakMap();
_uiManager2 = new WeakMap();
_l10nColor = new WeakMap();
_getDropdownRoot = new WeakSet();
getDropdownRoot_fn = function() {
  const div = document.createElement("div");
  const signal = __privateGet(this, _uiManager2)._signal;
  div.addEventListener("contextmenu", noContextMenu, {
    signal
  });
  div.className = "dropdown";
  div.role = "listbox";
  div.ariaMultiSelectable = "false";
  div.ariaOrientation = "vertical";
  div.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
  if (__privateGet(this, _editor4)) {
    div.id = `${__privateGet(this, _editor4).id}_colorpicker_dropdown`;
  }
  for (const [name, color] of __privateGet(this, _uiManager2).highlightColors) {
    const button = document.createElement("button");
    button.tabIndex = "0";
    button.role = "option";
    button.setAttribute("data-color", color);
    button.title = name;
    button.setAttribute("data-l10n-id", __privateGet(_ColorPicker, _l10nColor)[name]);
    const swatch = document.createElement("span");
    button.append(swatch);
    swatch.className = "swatch";
    swatch.style.backgroundColor = color;
    button.ariaSelected = color === __privateGet(this, _defaultColor);
    button.addEventListener("click", __privateMethod(this, _colorSelect, colorSelect_fn).bind(this, color), {
      signal
    });
    div.append(button);
  }
  div.addEventListener("keydown", __privateMethod(this, _keyDown, keyDown_fn).bind(this), {
    signal
  });
  return div;
};
_colorSelect = new WeakSet();
colorSelect_fn = function(color, event) {
  event.stopPropagation();
  __privateGet(this, _eventBus).dispatch("switchannotationeditorparams", {
    source: this,
    type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
    value: color
  });
  this.updateColor(color);
};
_keyDown = new WeakSet();
keyDown_fn = function(event) {
  _ColorPicker._keyboardManager.exec(this, event);
};
_openDropdown = new WeakSet();
openDropdown_fn = function(event) {
  if (__privateGet(this, _isDropdownVisible, isDropdownVisible_get)) {
    this.hideDropdown();
    return;
  }
  __privateSet(this, _dropdownWasFromKeyboard, event.detail === 0);
  if (!__privateGet(this, _openDropdownAC)) {
    __privateSet(this, _openDropdownAC, new AbortController());
    window.addEventListener("pointerdown", __privateMethod(this, _pointerDown2, pointerDown_fn2).bind(this), {
      signal: __privateGet(this, _uiManager2).combinedSignal(__privateGet(this, _openDropdownAC))
    });
  }
  __privateGet(this, _button).ariaExpanded = "true";
  if (__privateGet(this, _dropdown)) {
    __privateGet(this, _dropdown).classList.remove("hidden");
    return;
  }
  const root = __privateSet(this, _dropdown, __privateMethod(this, _getDropdownRoot, getDropdownRoot_fn).call(this));
  __privateGet(this, _button).append(root);
};
_pointerDown2 = new WeakSet();
pointerDown_fn2 = function(event) {
  var _a2;
  if ((_a2 = __privateGet(this, _dropdown)) == null ? void 0 : _a2.contains(event.target)) {
    return;
  }
  this.hideDropdown();
};
_isDropdownVisible = new WeakSet();
isDropdownVisible_get = function() {
  return __privateGet(this, _dropdown) && !__privateGet(this, _dropdown).classList.contains("hidden");
};
__privateAdd(_ColorPicker, _l10nColor, null);
var ColorPicker = _ColorPicker;
var _input, _editor5, _uiManager3, _l10nColor2;
var _BasicColorPicker = class _BasicColorPicker {
  constructor(editor) {
    __privateAdd(this, _input, null);
    __privateAdd(this, _editor5, null);
    __privateAdd(this, _uiManager3, null);
    __privateSet(this, _editor5, editor);
    __privateSet(this, _uiManager3, editor._uiManager);
    __privateGet(_BasicColorPicker, _l10nColor2) || __privateSet(_BasicColorPicker, _l10nColor2, Object.freeze({
      freetext: "pdfjs-editor-color-picker-free-text-input",
      ink: "pdfjs-editor-color-picker-ink-input"
    }));
  }
  renderButton() {
    if (__privateGet(this, _input)) {
      return __privateGet(this, _input);
    }
    const {
      editorType,
      colorType,
      colorValue
    } = __privateGet(this, _editor5);
    const input = __privateSet(this, _input, document.createElement("input"));
    input.type = "color";
    input.value = colorValue || "#000000";
    input.className = "basicColorPicker";
    input.tabIndex = 0;
    input.setAttribute("data-l10n-id", __privateGet(_BasicColorPicker, _l10nColor2)[editorType]);
    input.addEventListener("input", () => {
      __privateGet(this, _uiManager3).updateParams(colorType, input.value);
    }, {
      signal: __privateGet(this, _uiManager3)._signal
    });
    return input;
  }
  update(value) {
    if (!__privateGet(this, _input)) {
      return;
    }
    __privateGet(this, _input).value = value;
  }
  destroy() {
    var _a2;
    (_a2 = __privateGet(this, _input)) == null ? void 0 : _a2.remove();
    __privateSet(this, _input, null);
  }
  hideDropdown() {
  }
};
_input = new WeakMap();
_editor5 = new WeakMap();
_uiManager3 = new WeakMap();
_l10nColor2 = new WeakMap();
__privateAdd(_BasicColorPicker, _l10nColor2, null);
var BasicColorPicker = _BasicColorPicker;
function makeColorComp(n) {
  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
}
function scaleAndClamp(x) {
  return Math.max(0, Math.min(255, 255 * x));
}
var ColorConverters = class {
  static CMYK_G([c, y, m, k]) {
    return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
  }
  static G_CMYK([g]) {
    return ["CMYK", 0, 0, 0, 1 - g];
  }
  static G_RGB([g]) {
    return ["RGB", g, g, g];
  }
  static G_rgb([g]) {
    g = scaleAndClamp(g);
    return [g, g, g];
  }
  static G_HTML([g]) {
    const G = makeColorComp(g);
    return `#${G}${G}${G}`;
  }
  static RGB_G([r2, g, b]) {
    return ["G", 0.3 * r2 + 0.59 * g + 0.11 * b];
  }
  static RGB_rgb(color) {
    return color.map(scaleAndClamp);
  }
  static RGB_HTML(color) {
    return `#${color.map(makeColorComp).join("")}`;
  }
  static T_HTML() {
    return "#00000000";
  }
  static T_rgb() {
    return [null];
  }
  static CMYK_RGB([c, y, m, k]) {
    return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
  }
  static CMYK_rgb([c, y, m, k]) {
    return [scaleAndClamp(1 - Math.min(1, c + k)), scaleAndClamp(1 - Math.min(1, m + k)), scaleAndClamp(1 - Math.min(1, y + k))];
  }
  static CMYK_HTML(components) {
    const rgb = this.CMYK_RGB(components).slice(1);
    return this.RGB_HTML(rgb);
  }
  static RGB_CMYK([r2, g, b]) {
    const c = 1 - r2;
    const m = 1 - g;
    const y = 1 - b;
    const k = Math.min(c, m, y);
    return ["CMYK", c, m, y, k];
  }
};
var BaseSVGFactory = class {
  create(width, height, skipDimensions = false) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid SVG dimensions");
    }
    const svg = this._createSVG("svg:svg");
    svg.setAttribute("version", "1.1");
    if (!skipDimensions) {
      svg.setAttribute("width", `${width}px`);
      svg.setAttribute("height", `${height}px`);
    }
    svg.setAttribute("preserveAspectRatio", "none");
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    return svg;
  }
  createElement(type) {
    if (typeof type !== "string") {
      throw new Error("Invalid SVG element type");
    }
    return this._createSVG(type);
  }
  _createSVG(type) {
    unreachable("Abstract method `_createSVG` called.");
  }
};
var DOMSVGFactory = class extends BaseSVGFactory {
  _createSVG(type) {
    return document.createElementNS(SVG_NS, type);
  }
};
var annotation_layer_DEFAULT_FONT_SIZE = 9;
var GetElementsByNameSet = /* @__PURE__ */ new WeakSet();
var TIMEZONE_OFFSET = (/* @__PURE__ */ new Date()).getTimezoneOffset() * 60 * 1e3;
var AnnotationElementFactory = class {
  static create(parameters) {
    const subtype = parameters.data.annotationType;
    switch (subtype) {
      case AnnotationType.LINK:
        return new LinkAnnotationElement(parameters);
      case AnnotationType.TEXT:
        return new TextAnnotationElement(parameters);
      case AnnotationType.WIDGET:
        const fieldType = parameters.data.fieldType;
        switch (fieldType) {
          case "Tx":
            return new TextWidgetAnnotationElement(parameters);
          case "Btn":
            if (parameters.data.radioButton) {
              return new RadioButtonWidgetAnnotationElement(parameters);
            } else if (parameters.data.checkBox) {
              return new CheckboxWidgetAnnotationElement(parameters);
            }
            return new PushButtonWidgetAnnotationElement(parameters);
          case "Ch":
            return new ChoiceWidgetAnnotationElement(parameters);
          case "Sig":
            return new SignatureWidgetAnnotationElement(parameters);
        }
        return new WidgetAnnotationElement(parameters);
      case AnnotationType.POPUP:
        return new PopupAnnotationElement(parameters);
      case AnnotationType.FREETEXT:
        return new FreeTextAnnotationElement(parameters);
      case AnnotationType.LINE:
        return new LineAnnotationElement(parameters);
      case AnnotationType.SQUARE:
        return new SquareAnnotationElement(parameters);
      case AnnotationType.CIRCLE:
        return new CircleAnnotationElement(parameters);
      case AnnotationType.POLYLINE:
        return new PolylineAnnotationElement(parameters);
      case AnnotationType.CARET:
        return new CaretAnnotationElement(parameters);
      case AnnotationType.INK:
        return new InkAnnotationElement(parameters);
      case AnnotationType.POLYGON:
        return new PolygonAnnotationElement(parameters);
      case AnnotationType.HIGHLIGHT:
        return new HighlightAnnotationElement(parameters);
      case AnnotationType.UNDERLINE:
        return new UnderlineAnnotationElement(parameters);
      case AnnotationType.SQUIGGLY:
        return new SquigglyAnnotationElement(parameters);
      case AnnotationType.STRIKEOUT:
        return new StrikeOutAnnotationElement(parameters);
      case AnnotationType.STAMP:
        return new StampAnnotationElement(parameters);
      case AnnotationType.FILEATTACHMENT:
        return new FileAttachmentAnnotationElement(parameters);
      default:
        return new AnnotationElement(parameters);
    }
  }
};
var _updates, _hasBorder, _popupElement, _setRectEdited, setRectEdited_fn;
var _AnnotationElement = class _AnnotationElement {
  constructor(parameters, {
    isRenderable = false,
    ignoreBorder = false,
    createQuadrilaterals = false
  } = {}) {
    __privateAdd(this, _setRectEdited);
    __privateAdd(this, _updates, null);
    __privateAdd(this, _hasBorder, false);
    __privateAdd(this, _popupElement, null);
    this.isRenderable = isRenderable;
    this.data = parameters.data;
    this.layer = parameters.layer;
    this.linkService = parameters.linkService;
    this.downloadManager = parameters.downloadManager;
    this.imageResourcesPath = parameters.imageResourcesPath;
    this.renderForms = parameters.renderForms;
    this.svgFactory = parameters.svgFactory;
    this.annotationStorage = parameters.annotationStorage;
    this.enableComment = parameters.enableComment;
    this.enableScripting = parameters.enableScripting;
    this.hasJSActions = parameters.hasJSActions;
    this._fieldObjects = parameters.fieldObjects;
    this.parent = parameters.parent;
    if (isRenderable) {
      this.container = this._createContainer(ignoreBorder);
    }
    if (createQuadrilaterals) {
      this._createQuadrilaterals();
    }
  }
  static _hasPopupData({
    contentsObj,
    richText
  }) {
    return !!((contentsObj == null ? void 0 : contentsObj.str) || (richText == null ? void 0 : richText.str));
  }
  get _isEditable() {
    return this.data.isEditable;
  }
  get hasPopupData() {
    return _AnnotationElement._hasPopupData(this.data) || this.enableComment && !!this.commentText;
  }
  get commentData() {
    var _a2;
    const {
      data
    } = this;
    const editor = (_a2 = this.annotationStorage) == null ? void 0 : _a2.getEditor(data.id);
    if (editor) {
      return editor.getData();
    }
    return data;
  }
  get hasCommentButton() {
    return this.enableComment && this.hasPopupElement;
  }
  get commentButtonPosition() {
    var _a2;
    const editor = (_a2 = this.annotationStorage) == null ? void 0 : _a2.getEditor(this.data.id);
    if (editor) {
      return editor.commentButtonPositionInPage;
    }
    const {
      quadPoints,
      inkLists,
      rect
    } = this.data;
    let maxX = -Infinity;
    let maxY = -Infinity;
    if ((quadPoints == null ? void 0 : quadPoints.length) >= 8) {
      for (let i = 0; i < quadPoints.length; i += 8) {
        if (quadPoints[i + 1] > maxY) {
          maxY = quadPoints[i + 1];
          maxX = quadPoints[i + 2];
        } else if (quadPoints[i + 1] === maxY) {
          maxX = Math.max(maxX, quadPoints[i + 2]);
        }
      }
      return [maxX, maxY];
    }
    if ((inkLists == null ? void 0 : inkLists.length) >= 1) {
      for (const inkList of inkLists) {
        for (let i = 0, ii = inkList.length; i < ii; i += 2) {
          if (inkList[i + 1] > maxY) {
            maxY = inkList[i + 1];
            maxX = inkList[i];
          } else if (inkList[i + 1] === maxY) {
            maxX = Math.max(maxX, inkList[i]);
          }
        }
      }
      if (maxX !== Infinity) {
        return [maxX, maxY];
      }
    }
    if (rect) {
      return [rect[2], rect[3]];
    }
    return null;
  }
  _normalizePoint(point) {
    const {
      page: {
        view
      },
      viewport: {
        rawDims: {
          pageWidth,
          pageHeight,
          pageX,
          pageY
        }
      }
    } = this.parent;
    point[1] = view[3] - point[1] + view[1];
    point[0] = 100 * (point[0] - pageX) / pageWidth;
    point[1] = 100 * (point[1] - pageY) / pageHeight;
    return point;
  }
  get commentText() {
    var _a2, _b, _c;
    const {
      data
    } = this;
    return ((_b = (_a2 = this.annotationStorage.getRawValue(`${AnnotationEditorPrefix}${data.id}`)) == null ? void 0 : _a2.popup) == null ? void 0 : _b.contents) || ((_c = data.contentsObj) == null ? void 0 : _c.str) || "";
  }
  set commentText(text) {
    const {
      data
    } = this;
    const popup = {
      deleted: !text,
      contents: text || ""
    };
    if (!this.annotationStorage.updateEditor(data.id, {
      popup
    })) {
      this.annotationStorage.setValue(`${AnnotationEditorPrefix}${data.id}`, {
        id: data.id,
        annotationType: data.annotationType,
        pageIndex: this.parent.page._pageIndex,
        popup,
        popupRef: data.popupRef,
        modificationDate: /* @__PURE__ */ new Date()
      });
    }
    if (!text) {
      this.removePopup();
    }
  }
  removePopup() {
    var _a2, _b;
    (_b = ((_a2 = __privateGet(this, _popupElement)) == null ? void 0 : _a2.popup) || this.popup) == null ? void 0 : _b.remove();
    __privateSet(this, _popupElement, this.popup = null);
  }
  updateEdited(params) {
    var _a2;
    if (!this.container) {
      return;
    }
    if (params.rect) {
      __privateGet(this, _updates) || __privateSet(this, _updates, {
        rect: this.data.rect.slice(0)
      });
    }
    const {
      rect,
      popup: newPopup
    } = params;
    if (rect) {
      __privateMethod(this, _setRectEdited, setRectEdited_fn).call(this, rect);
    }
    let popup = ((_a2 = __privateGet(this, _popupElement)) == null ? void 0 : _a2.popup) || this.popup;
    if (!popup && (newPopup == null ? void 0 : newPopup.text)) {
      this._createPopup(newPopup);
      popup = __privateGet(this, _popupElement).popup;
    }
    if (!popup) {
      return;
    }
    popup.updateEdited(params);
    if (newPopup == null ? void 0 : newPopup.deleted) {
      popup.remove();
      __privateSet(this, _popupElement, null);
      this.popup = null;
    }
  }
  resetEdited() {
    var _a2;
    if (!__privateGet(this, _updates)) {
      return;
    }
    __privateMethod(this, _setRectEdited, setRectEdited_fn).call(this, __privateGet(this, _updates).rect);
    (_a2 = __privateGet(this, _popupElement)) == null ? void 0 : _a2.popup.resetEdited();
    __privateSet(this, _updates, null);
  }
  _createContainer(ignoreBorder) {
    const {
      data,
      parent: {
        page,
        viewport
      }
    } = this;
    const container = document.createElement("section");
    container.setAttribute("data-annotation-id", data.id);
    if (!(this instanceof WidgetAnnotationElement) && !(this instanceof LinkAnnotationElement)) {
      container.tabIndex = 0;
    }
    const {
      style
    } = container;
    style.zIndex = this.parent.zIndex;
    this.parent.zIndex += 2;
    if (data.alternativeText) {
      container.title = data.alternativeText;
    }
    if (data.noRotate) {
      container.classList.add("norotate");
    }
    if (!data.rect || this instanceof PopupAnnotationElement) {
      const {
        rotation: rotation2
      } = data;
      if (!data.hasOwnCanvas && rotation2 !== 0) {
        this.setRotation(rotation2, container);
      }
      return container;
    }
    const {
      width,
      height
    } = this;
    if (!ignoreBorder && data.borderStyle.width > 0) {
      style.borderWidth = `${data.borderStyle.width}px`;
      const horizontalRadius = data.borderStyle.horizontalCornerRadius;
      const verticalRadius = data.borderStyle.verticalCornerRadius;
      if (horizontalRadius > 0 || verticalRadius > 0) {
        const radius = `calc(${horizontalRadius}px * var(--total-scale-factor)) / calc(${verticalRadius}px * var(--total-scale-factor))`;
        style.borderRadius = radius;
      } else if (this instanceof RadioButtonWidgetAnnotationElement) {
        const radius = `calc(${width}px * var(--total-scale-factor)) / calc(${height}px * var(--total-scale-factor))`;
        style.borderRadius = radius;
      }
      switch (data.borderStyle.style) {
        case AnnotationBorderStyleType.SOLID:
          style.borderStyle = "solid";
          break;
        case AnnotationBorderStyleType.DASHED:
          style.borderStyle = "dashed";
          break;
        case AnnotationBorderStyleType.BEVELED:
          warn("Unimplemented border style: beveled");
          break;
        case AnnotationBorderStyleType.INSET:
          warn("Unimplemented border style: inset");
          break;
        case AnnotationBorderStyleType.UNDERLINE:
          style.borderBottomStyle = "solid";
          break;
        default:
          break;
      }
      const borderColor = data.borderColor || null;
      if (borderColor) {
        __privateSet(this, _hasBorder, true);
        style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
      } else {
        style.borderWidth = 0;
      }
    }
    const rect = Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
    const {
      pageWidth,
      pageHeight,
      pageX,
      pageY
    } = viewport.rawDims;
    style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
    style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;
    const {
      rotation
    } = data;
    if (data.hasOwnCanvas || rotation === 0) {
      style.width = `${100 * width / pageWidth}%`;
      style.height = `${100 * height / pageHeight}%`;
    } else {
      this.setRotation(rotation, container);
    }
    return container;
  }
  setRotation(angle, container = this.container) {
    if (!this.data.rect) {
      return;
    }
    const {
      pageWidth,
      pageHeight
    } = this.parent.viewport.rawDims;
    let {
      width,
      height
    } = this;
    if (angle % 180 !== 0) {
      [width, height] = [height, width];
    }
    container.style.width = `${100 * width / pageWidth}%`;
    container.style.height = `${100 * height / pageHeight}%`;
    container.setAttribute("data-main-rotation", (360 - angle) % 360);
  }
  get _commonActions() {
    const setColor = (jsName, styleName, event) => {
      const color = event.detail[jsName];
      const colorType = color[0];
      const colorArray = color.slice(1);
      event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);
      this.annotationStorage.setValue(this.data.id, {
        [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)
      });
    };
    return shadow(this, "_commonActions", {
      display: (event) => {
        const {
          display
        } = event.detail;
        const hidden = display % 2 === 1;
        this.container.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          noView: hidden,
          noPrint: display === 1 || display === 2
        });
      },
      print: (event) => {
        this.annotationStorage.setValue(this.data.id, {
          noPrint: !event.detail.print
        });
      },
      hidden: (event) => {
        const {
          hidden
        } = event.detail;
        this.container.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          noPrint: hidden,
          noView: hidden
        });
      },
      focus: (event) => {
        setTimeout(() => event.target.focus({
          preventScroll: false
        }), 0);
      },
      userName: (event) => {
        event.target.title = event.detail.userName;
      },
      readonly: (event) => {
        event.target.disabled = event.detail.readonly;
      },
      required: (event) => {
        this._setRequired(event.target, event.detail.required);
      },
      bgColor: (event) => {
        setColor("bgColor", "backgroundColor", event);
      },
      fillColor: (event) => {
        setColor("fillColor", "backgroundColor", event);
      },
      fgColor: (event) => {
        setColor("fgColor", "color", event);
      },
      textColor: (event) => {
        setColor("textColor", "color", event);
      },
      borderColor: (event) => {
        setColor("borderColor", "borderColor", event);
      },
      strokeColor: (event) => {
        setColor("strokeColor", "borderColor", event);
      },
      rotation: (event) => {
        const angle = event.detail.rotation;
        this.setRotation(angle);
        this.annotationStorage.setValue(this.data.id, {
          rotation: angle
        });
      }
    });
  }
  _dispatchEventFromSandbox(actions, jsEvent) {
    const commonActions = this._commonActions;
    for (const name of Object.keys(jsEvent.detail)) {
      const action = actions[name] || commonActions[name];
      action == null ? void 0 : action(jsEvent);
    }
  }
  _setDefaultPropertiesFromJS(element) {
    if (!this.enableScripting) {
      return;
    }
    const storedData = this.annotationStorage.getRawValue(this.data.id);
    if (!storedData) {
      return;
    }
    const commonActions = this._commonActions;
    for (const [actionName, detail] of Object.entries(storedData)) {
      const action = commonActions[actionName];
      if (action) {
        const eventProxy = {
          detail: {
            [actionName]: detail
          },
          target: element
        };
        action(eventProxy);
        delete storedData[actionName];
      }
    }
  }
  _createQuadrilaterals() {
    if (!this.container) {
      return;
    }
    const {
      quadPoints
    } = this.data;
    if (!quadPoints) {
      return;
    }
    const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map((x) => Math.fround(x));
    if (quadPoints.length === 8) {
      const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);
      if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {
        return;
      }
    }
    const {
      style
    } = this.container;
    let svgBuffer;
    if (__privateGet(this, _hasBorder)) {
      const {
        borderColor,
        borderWidth
      } = style;
      style.borderWidth = 0;
      svgBuffer = ["url('data:image/svg+xml;utf8,", `<svg xmlns="http://www.w3.org/2000/svg"`, ` preserveAspectRatio="none" viewBox="0 0 1 1">`, `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`];
      this.container.classList.add("hasBorder");
    }
    const width = rectTrX - rectBlX;
    const height = rectTrY - rectBlY;
    const {
      svgFactory
    } = this;
    const svg = svgFactory.createElement("svg");
    svg.classList.add("quadrilateralsContainer");
    svg.setAttribute("width", 0);
    svg.setAttribute("height", 0);
    svg.role = "none";
    const defs = svgFactory.createElement("defs");
    svg.append(defs);
    const clipPath = svgFactory.createElement("clipPath");
    const id = `clippath_${this.data.id}`;
    clipPath.setAttribute("id", id);
    clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
    defs.append(clipPath);
    for (let i = 2, ii = quadPoints.length; i < ii; i += 8) {
      const trX = quadPoints[i];
      const trY = quadPoints[i + 1];
      const blX = quadPoints[i + 2];
      const blY = quadPoints[i + 3];
      const rect = svgFactory.createElement("rect");
      const x = (blX - rectBlX) / width;
      const y = (rectTrY - trY) / height;
      const rectWidth = (trX - blX) / width;
      const rectHeight = (trY - blY) / height;
      rect.setAttribute("x", x);
      rect.setAttribute("y", y);
      rect.setAttribute("width", rectWidth);
      rect.setAttribute("height", rectHeight);
      clipPath.append(rect);
      svgBuffer == null ? void 0 : svgBuffer.push(`<rect vector-effect="non-scaling-stroke" x="${x}" y="${y}" width="${rectWidth}" height="${rectHeight}"/>`);
    }
    if (__privateGet(this, _hasBorder)) {
      svgBuffer.push(`</g></svg>')`);
      style.backgroundImage = svgBuffer.join("");
    }
    this.container.append(svg);
    this.container.style.clipPath = `url(#${id})`;
  }
  _createPopup(popupData = null) {
    const {
      data
    } = this;
    let contentsObj, modificationDate;
    if (popupData) {
      contentsObj = {
        str: popupData.text
      };
      modificationDate = popupData.date;
    } else {
      contentsObj = data.contentsObj;
      modificationDate = data.modificationDate;
    }
    const popup = __privateSet(this, _popupElement, new PopupAnnotationElement({
      data: {
        color: data.color,
        titleObj: data.titleObj,
        modificationDate,
        contentsObj,
        richText: data.richText,
        parentRect: data.rect,
        borderStyle: 0,
        id: `popup_${data.id}`,
        rotation: data.rotation,
        noRotate: true
      },
      linkService: this.linkService,
      parent: this.parent,
      elements: [this]
    }));
    if (!this.parent._commentManager) {
      this.parent.div.append(popup.render());
    }
  }
  get hasPopupElement() {
    return !!(__privateGet(this, _popupElement) || this.popup || this.data.popupRef);
  }
  get extraPopupElement() {
    return __privateGet(this, _popupElement);
  }
  render() {
    unreachable("Abstract method `AnnotationElement.render` called");
  }
  _getElementsByName(name, skipId = null) {
    const fields = [];
    if (this._fieldObjects) {
      const fieldObj = this._fieldObjects[name];
      if (fieldObj) {
        for (const {
          page,
          id,
          exportValues
        } of fieldObj) {
          if (page === -1) {
            continue;
          }
          if (id === skipId) {
            continue;
          }
          const exportValue = typeof exportValues === "string" ? exportValues : null;
          const domElement = document.querySelector(`[data-element-id="${id}"]`);
          if (domElement && !GetElementsByNameSet.has(domElement)) {
            warn(`_getElementsByName - element not allowed: ${id}`);
            continue;
          }
          fields.push({
            id,
            exportValue,
            domElement
          });
        }
      }
      return fields;
    }
    for (const domElement of document.getElementsByName(name)) {
      const {
        exportValue
      } = domElement;
      const id = domElement.getAttribute("data-element-id");
      if (id === skipId) {
        continue;
      }
      if (!GetElementsByNameSet.has(domElement)) {
        continue;
      }
      fields.push({
        id,
        exportValue,
        domElement
      });
    }
    return fields;
  }
  show() {
    var _a2;
    if (this.container) {
      this.container.hidden = false;
    }
    (_a2 = this.popup) == null ? void 0 : _a2.maybeShow();
  }
  hide() {
    var _a2;
    if (this.container) {
      this.container.hidden = true;
    }
    (_a2 = this.popup) == null ? void 0 : _a2.forceHide();
  }
  getElementsToTriggerPopup() {
    return this.container;
  }
  addHighlightArea() {
    const triggers = this.getElementsToTriggerPopup();
    if (Array.isArray(triggers)) {
      for (const element of triggers) {
        element.classList.add("highlightArea");
      }
    } else {
      triggers.classList.add("highlightArea");
    }
  }
  _editOnDoubleClick() {
    if (!this._isEditable) {
      return;
    }
    const {
      annotationEditorType: mode,
      data: {
        id: editId
      }
    } = this;
    this.container.addEventListener("dblclick", () => {
      var _a2;
      (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("switchannotationeditormode", {
        source: this,
        mode,
        editId,
        mustEnterInEditMode: true
      });
    });
  }
  get width() {
    return this.data.rect[2] - this.data.rect[0];
  }
  get height() {
    return this.data.rect[3] - this.data.rect[1];
  }
};
_updates = new WeakMap();
_hasBorder = new WeakMap();
_popupElement = new WeakMap();
_setRectEdited = new WeakSet();
setRectEdited_fn = function(rect) {
  const {
    container: {
      style
    },
    data: {
      rect: currentRect,
      rotation
    },
    parent: {
      viewport: {
        rawDims: {
          pageWidth,
          pageHeight,
          pageX,
          pageY
        }
      }
    }
  } = this;
  currentRect == null ? void 0 : currentRect.splice(0, 4, ...rect);
  style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
  style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;
  if (rotation === 0) {
    style.width = `${100 * (rect[2] - rect[0]) / pageWidth}%`;
    style.height = `${100 * (rect[3] - rect[1]) / pageHeight}%`;
  } else {
    this.setRotation(rotation);
  }
};
var AnnotationElement = _AnnotationElement;
var EditorAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.editor = parameters.editor;
  }
  render() {
    this.container.className = "editorAnnotation";
    return this.container;
  }
  createOrUpdatePopup() {
    const {
      editor
    } = this;
    if (!editor.hasComment) {
      return;
    }
    this._createPopup(editor.comment);
    this.extraPopupElement.popup.renderCommentButton();
  }
  get hasCommentButton() {
    return this.enableComment && this.editor.hasComment;
  }
  get commentButtonPosition() {
    return this.editor.commentButtonPositionInPage;
  }
  get commentText() {
    return this.editor.comment.text;
  }
  set commentText(text) {
    this.editor.comment = text;
    if (!text) {
      this.removePopup();
    }
  }
  get commentData() {
    return this.editor.getData();
  }
  remove() {
    this.container.remove();
    this.container = null;
    this.removePopup();
  }
};
var _setInternalLink, setInternalLink_fn, _bindAttachment, bindAttachment_fn, _bindSetOCGState, bindSetOCGState_fn;
var LinkAnnotationElement = class extends AnnotationElement {
  constructor(parameters, options = null) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: !!(options == null ? void 0 : options.ignoreBorder),
      createQuadrilaterals: true
    });
    __privateAdd(this, _setInternalLink);
    __privateAdd(this, _bindAttachment);
    __privateAdd(this, _bindSetOCGState);
    this.isTooltipOnly = parameters.data.isTooltipOnly;
  }
  render() {
    const {
      data,
      linkService
    } = this;
    const link = document.createElement("a");
    link.setAttribute("data-element-id", data.id);
    let isBound = false;
    if (data.url) {
      linkService.addLinkAttributes(link, data.url, data.newWindow);
      isBound = true;
    } else if (data.action) {
      this._bindNamedAction(link, data.action, data.overlaidText);
      isBound = true;
    } else if (data.attachment) {
      __privateMethod(this, _bindAttachment, bindAttachment_fn).call(this, link, data.attachment, data.overlaidText, data.attachmentDest);
      isBound = true;
    } else if (data.setOCGState) {
      __privateMethod(this, _bindSetOCGState, bindSetOCGState_fn).call(this, link, data.setOCGState, data.overlaidText);
      isBound = true;
    } else if (data.dest) {
      this._bindLink(link, data.dest, data.overlaidText);
      isBound = true;
    } else {
      if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
        this._bindJSAction(link, data);
        isBound = true;
      }
      if (data.resetForm) {
        this._bindResetFormAction(link, data.resetForm);
        isBound = true;
      } else if (this.isTooltipOnly && !isBound) {
        this._bindLink(link, "");
        isBound = true;
      }
    }
    this.container.classList.add("linkAnnotation");
    if (isBound) {
      this.container.append(link);
    }
    return this.container;
  }
  _bindLink(link, destination, overlaidText = "") {
    link.href = this.linkService.getDestinationHash(destination);
    link.onclick = () => {
      if (destination) {
        this.linkService.goToDestination(destination);
      }
      return false;
    };
    if (destination || destination === "") {
      __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
    }
    if (overlaidText) {
      link.title = overlaidText;
    }
  }
  _bindNamedAction(link, action, overlaidText = "") {
    link.href = this.linkService.getAnchorUrl("");
    link.onclick = () => {
      this.linkService.executeNamedAction(action);
      return false;
    };
    if (overlaidText) {
      link.title = overlaidText;
    }
    __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
  }
  _bindJSAction(link, data) {
    link.href = this.linkService.getAnchorUrl("");
    const map = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
    for (const name of Object.keys(data.actions)) {
      const jsName = map.get(name);
      if (!jsName) {
        continue;
      }
      link[jsName] = () => {
        var _a2;
        (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: data.id,
            name
          }
        });
        return false;
      };
    }
    if (data.overlaidText) {
      link.title = data.overlaidText;
    }
    if (!link.onclick) {
      link.onclick = () => false;
    }
    __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
  }
  _bindResetFormAction(link, resetForm) {
    const otherClickAction = link.onclick;
    if (!otherClickAction) {
      link.href = this.linkService.getAnchorUrl("");
    }
    __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
    if (!this._fieldObjects) {
      warn(`_bindResetFormAction - "resetForm" action not supported, ensure that the \`fieldObjects\` parameter is provided.`);
      if (!otherClickAction) {
        link.onclick = () => false;
      }
      return;
    }
    link.onclick = () => {
      var _a2;
      otherClickAction == null ? void 0 : otherClickAction();
      const {
        fields: resetFormFields,
        refs: resetFormRefs,
        include
      } = resetForm;
      const allFields = [];
      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
        const fieldIds = new Set(resetFormRefs);
        for (const fieldName of resetFormFields) {
          const fields = this._fieldObjects[fieldName] || [];
          for (const {
            id
          } of fields) {
            fieldIds.add(id);
          }
        }
        for (const fields of Object.values(this._fieldObjects)) {
          for (const field of fields) {
            if (fieldIds.has(field.id) === include) {
              allFields.push(field);
            }
          }
        }
      } else {
        for (const fields of Object.values(this._fieldObjects)) {
          allFields.push(...fields);
        }
      }
      const storage = this.annotationStorage;
      const allIds = [];
      for (const field of allFields) {
        const {
          id
        } = field;
        allIds.push(id);
        switch (field.type) {
          case "text": {
            const value = field.defaultValue || "";
            storage.setValue(id, {
              value
            });
            break;
          }
          case "checkbox":
          case "radiobutton": {
            const value = field.defaultValue === field.exportValues;
            storage.setValue(id, {
              value
            });
            break;
          }
          case "combobox":
          case "listbox": {
            const value = field.defaultValue || "";
            storage.setValue(id, {
              value
            });
            break;
          }
          default:
            continue;
        }
        const domElement = document.querySelector(`[data-element-id="${id}"]`);
        if (!domElement) {
          continue;
        } else if (!GetElementsByNameSet.has(domElement)) {
          warn(`_bindResetFormAction - element not allowed: ${id}`);
          continue;
        }
        domElement.dispatchEvent(new Event("resetform"));
      }
      if (this.enableScripting) {
        (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: "app",
            ids: allIds,
            name: "ResetForm"
          }
        });
      }
      return false;
    };
  }
};
_setInternalLink = new WeakSet();
setInternalLink_fn = function() {
  this.container.setAttribute("data-internal-link", "");
};
_bindAttachment = new WeakSet();
bindAttachment_fn = function(link, attachment, overlaidText = "", dest = null) {
  link.href = this.linkService.getAnchorUrl("");
  if (attachment.description) {
    link.title = attachment.description;
  } else if (overlaidText) {
    link.title = overlaidText;
  }
  link.onclick = () => {
    var _a2;
    (_a2 = this.downloadManager) == null ? void 0 : _a2.openOrDownloadData(attachment.content, attachment.filename, dest);
    return false;
  };
  __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
};
_bindSetOCGState = new WeakSet();
bindSetOCGState_fn = function(link, action, overlaidText = "") {
  link.href = this.linkService.getAnchorUrl("");
  link.onclick = () => {
    this.linkService.executeSetOCGState(action);
    return false;
  };
  if (overlaidText) {
    link.title = overlaidText;
  }
  __privateMethod(this, _setInternalLink, setInternalLink_fn).call(this);
};
var TextAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true
    });
  }
  render() {
    this.container.classList.add("textAnnotation");
    const image = document.createElement("img");
    image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
    image.setAttribute("data-l10n-id", "pdfjs-text-annotation-type");
    image.setAttribute("data-l10n-args", JSON.stringify({
      type: this.data.name
    }));
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.append(image);
    return this.container;
  }
};
var WidgetAnnotationElement = class extends AnnotationElement {
  render() {
    return this.container;
  }
  showElementAndHideCanvas(element) {
    var _a2;
    if (this.data.hasOwnCanvas) {
      if (((_a2 = element.previousSibling) == null ? void 0 : _a2.nodeName) === "CANVAS") {
        element.previousSibling.hidden = true;
      }
      element.hidden = false;
    }
  }
  _getKeyModifier(event) {
    return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;
  }
  _setEventListener(element, elementData, baseName, eventName, valueGetter) {
    if (baseName.includes("mouse")) {
      element.addEventListener(baseName, (event) => {
        var _a2;
        (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event),
            shift: event.shiftKey,
            modifier: this._getKeyModifier(event)
          }
        });
      });
    } else {
      element.addEventListener(baseName, (event) => {
        var _a2;
        if (baseName === "blur") {
          if (!elementData.focused || !event.relatedTarget) {
            return;
          }
          elementData.focused = false;
        } else if (baseName === "focus") {
          if (elementData.focused) {
            return;
          }
          elementData.focused = true;
        }
        if (!valueGetter) {
          return;
        }
        (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event)
          }
        });
      });
    }
  }
  _setEventListeners(element, elementData, names, getter) {
    var _a2, _b, _c;
    for (const [baseName, eventName] of names) {
      if (eventName === "Action" || ((_a2 = this.data.actions) == null ? void 0 : _a2[eventName])) {
        if (eventName === "Focus" || eventName === "Blur") {
          elementData || (elementData = {
            focused: false
          });
        }
        this._setEventListener(element, elementData, baseName, eventName, getter);
        if (eventName === "Focus" && !((_b = this.data.actions) == null ? void 0 : _b.Blur)) {
          this._setEventListener(element, elementData, "blur", "Blur", null);
        } else if (eventName === "Blur" && !((_c = this.data.actions) == null ? void 0 : _c.Focus)) {
          this._setEventListener(element, elementData, "focus", "Focus", null);
        }
      }
    }
  }
  _setBackgroundColor(element) {
    const color = this.data.backgroundColor || null;
    element.style.backgroundColor = color === null ? "transparent" : Util.makeHexColor(color[0], color[1], color[2]);
  }
  _setTextStyle(element) {
    const TEXT_ALIGNMENT = ["left", "center", "right"];
    const {
      fontColor
    } = this.data.defaultAppearanceData;
    const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;
    const style = element.style;
    let computedFontSize;
    const BORDER_SIZE = 2;
    const roundToOneDecimal = (x) => Math.round(10 * x) / 10;
    if (this.data.multiLine) {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
      const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;
      const lineHeight = height / numberOfLines;
      computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));
    } else {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
      computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));
    }
    style.fontSize = `calc(${computedFontSize}px * var(--total-scale-factor))`;
    style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
    if (this.data.textAlignment !== null) {
      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
    }
  }
  _setRequired(element, isRequired) {
    if (isRequired) {
      element.setAttribute("required", true);
    } else {
      element.removeAttribute("required");
    }
    element.setAttribute("aria-required", isRequired);
  }
};
var TextWidgetAnnotationElement = class extends WidgetAnnotationElement {
  constructor(parameters) {
    const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
    super(parameters, {
      isRenderable
    });
  }
  setPropertyOnSiblings(base, key, value, keyInStorage) {
    const storage = this.annotationStorage;
    for (const element of this._getElementsByName(base.name, base.id)) {
      if (element.domElement) {
        element.domElement[key] = value;
      }
      storage.setValue(element.id, {
        [keyInStorage]: value
      });
    }
  }
  render() {
    var _a2, _b;
    const storage = this.annotationStorage;
    const id = this.data.id;
    this.container.classList.add("textWidgetAnnotation");
    let element = null;
    if (this.renderForms) {
      const storedData = storage.getValue(id, {
        value: this.data.fieldValue
      });
      let textContent = storedData.value || "";
      const maxLen = storage.getValue(id, {
        charLimit: this.data.maxLen
      }).charLimit;
      if (maxLen && textContent.length > maxLen) {
        textContent = textContent.slice(0, maxLen);
      }
      let fieldFormattedValues = storedData.formattedValue || ((_a2 = this.data.textContent) == null ? void 0 : _a2.join("\n")) || null;
      if (fieldFormattedValues && this.data.comb) {
        fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
      }
      const elementData = {
        userValue: textContent,
        formattedValue: fieldFormattedValues,
        lastCommittedValue: null,
        commitKey: 1,
        focused: false
      };
      if (this.data.multiLine) {
        element = document.createElement("textarea");
        element.textContent = fieldFormattedValues ?? textContent;
        if (this.data.doNotScroll) {
          element.style.overflowY = "hidden";
        }
      } else {
        element = document.createElement("input");
        element.type = this.data.password ? "password" : "text";
        element.setAttribute("value", fieldFormattedValues ?? textContent);
        if (this.data.doNotScroll) {
          element.style.overflowX = "hidden";
        }
      }
      if (this.data.hasOwnCanvas) {
        element.hidden = true;
      }
      GetElementsByNameSet.add(element);
      element.setAttribute("data-element-id", id);
      element.disabled = this.data.readOnly;
      element.name = this.data.fieldName;
      element.tabIndex = 0;
      const {
        datetimeFormat,
        datetimeType,
        timeStep
      } = this.data;
      const hasDateOrTime = !!datetimeType && this.enableScripting;
      if (datetimeFormat) {
        element.title = datetimeFormat;
      }
      this._setRequired(element, this.data.required);
      if (maxLen) {
        element.maxLength = maxLen;
      }
      element.addEventListener("input", (event) => {
        storage.setValue(id, {
          value: event.target.value
        });
        this.setPropertyOnSiblings(element, "value", event.target.value, "value");
        elementData.formattedValue = null;
      });
      element.addEventListener("resetform", (event) => {
        const defaultValue = this.data.defaultFieldValue ?? "";
        element.value = elementData.userValue = defaultValue;
        elementData.formattedValue = null;
      });
      let blurListener = (event) => {
        const {
          formattedValue
        } = elementData;
        if (formattedValue !== null && formattedValue !== void 0) {
          event.target.value = formattedValue;
        }
        event.target.scrollLeft = 0;
      };
      if (this.enableScripting && this.hasJSActions) {
        element.addEventListener("focus", (event) => {
          var _a3;
          if (elementData.focused) {
            return;
          }
          const {
            target
          } = event;
          if (hasDateOrTime) {
            target.type = datetimeType;
            if (timeStep) {
              target.step = timeStep;
            }
          }
          if (elementData.userValue) {
            const value = elementData.userValue;
            if (hasDateOrTime) {
              if (datetimeType === "time") {
                const date = new Date(value);
                const parts = [date.getHours(), date.getMinutes(), date.getSeconds()];
                target.value = parts.map((v) => v.toString().padStart(2, "0")).join(":");
              } else {
                target.value = new Date(value - TIMEZONE_OFFSET).toISOString().split(datetimeType === "date" ? "T" : ".", 1)[0];
              }
            } else {
              target.value = value;
            }
          }
          elementData.lastCommittedValue = target.value;
          elementData.commitKey = 1;
          if (!((_a3 = this.data.actions) == null ? void 0 : _a3.Focus)) {
            elementData.focused = true;
          }
        });
        element.addEventListener("updatefromsandbox", (jsEvent) => {
          this.showElementAndHideCanvas(jsEvent.target);
          const actions = {
            value(event) {
              elementData.userValue = event.detail.value ?? "";
              if (!hasDateOrTime) {
                storage.setValue(id, {
                  value: elementData.userValue.toString()
                });
              }
              event.target.value = elementData.userValue;
            },
            formattedValue(event) {
              const {
                formattedValue
              } = event.detail;
              elementData.formattedValue = formattedValue;
              if (formattedValue !== null && formattedValue !== void 0 && event.target !== document.activeElement) {
                event.target.value = formattedValue;
              }
              const data = {
                formattedValue
              };
              if (hasDateOrTime) {
                data.value = formattedValue;
              }
              storage.setValue(id, data);
            },
            selRange(event) {
              event.target.setSelectionRange(...event.detail.selRange);
            },
            charLimit: (event) => {
              var _a3;
              const {
                charLimit
              } = event.detail;
              const {
                target
              } = event;
              if (charLimit === 0) {
                target.removeAttribute("maxLength");
                return;
              }
              target.setAttribute("maxLength", charLimit);
              let value = elementData.userValue;
              if (!value || value.length <= charLimit) {
                return;
              }
              value = value.slice(0, charLimit);
              target.value = elementData.userValue = value;
              storage.setValue(id, {
                value
              });
              (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id,
                  name: "Keystroke",
                  value,
                  willCommit: true,
                  commitKey: 1,
                  selStart: target.selectionStart,
                  selEnd: target.selectionEnd
                }
              });
            }
          };
          this._dispatchEventFromSandbox(actions, jsEvent);
        });
        element.addEventListener("keydown", (event) => {
          var _a3;
          elementData.commitKey = 1;
          let commitKey = -1;
          if (event.key === "Escape") {
            commitKey = 0;
          } else if (event.key === "Enter" && !this.data.multiLine) {
            commitKey = 2;
          } else if (event.key === "Tab") {
            elementData.commitKey = 3;
          }
          if (commitKey === -1) {
            return;
          }
          const {
            value
          } = event.target;
          if (elementData.lastCommittedValue === value) {
            return;
          }
          elementData.lastCommittedValue = value;
          elementData.userValue = value;
          (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id,
              name: "Keystroke",
              value,
              willCommit: true,
              commitKey,
              selStart: event.target.selectionStart,
              selEnd: event.target.selectionEnd
            }
          });
        });
        const _blurListener = blurListener;
        blurListener = null;
        element.addEventListener("blur", (event) => {
          var _a3, _b2;
          if (!elementData.focused || !event.relatedTarget) {
            return;
          }
          if (!((_a3 = this.data.actions) == null ? void 0 : _a3.Blur)) {
            elementData.focused = false;
          }
          const {
            target
          } = event;
          let {
            value
          } = target;
          if (hasDateOrTime) {
            if (value && datetimeType === "time") {
              const parts = value.split(":").map((v) => parseInt(v, 10));
              value = new Date(2e3, 0, 1, parts[0], parts[1], parts[2] || 0).valueOf();
              target.step = "";
            } else {
              if (!value.includes("T")) {
                value = `${value}T00:00`;
              }
              value = new Date(value).valueOf();
            }
            target.type = "text";
          }
          elementData.userValue = value;
          if (elementData.lastCommittedValue !== value) {
            (_b2 = this.linkService.eventBus) == null ? void 0 : _b2.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value,
                willCommit: true,
                commitKey: elementData.commitKey,
                selStart: event.target.selectionStart,
                selEnd: event.target.selectionEnd
              }
            });
          }
          _blurListener(event);
        });
        if ((_b = this.data.actions) == null ? void 0 : _b.Keystroke) {
          element.addEventListener("beforeinput", (event) => {
            var _a3;
            elementData.lastCommittedValue = null;
            const {
              data,
              target
            } = event;
            const {
              value,
              selectionStart,
              selectionEnd
            } = target;
            let selStart = selectionStart, selEnd = selectionEnd;
            switch (event.inputType) {
              case "deleteWordBackward": {
                const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                if (match) {
                  selStart -= match[0].length;
                }
                break;
              }
              case "deleteWordForward": {
                const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                if (match) {
                  selEnd += match[0].length;
                }
                break;
              }
              case "deleteContentBackward":
                if (selectionStart === selectionEnd) {
                  selStart -= 1;
                }
                break;
              case "deleteContentForward":
                if (selectionStart === selectionEnd) {
                  selEnd += 1;
                }
                break;
            }
            event.preventDefault();
            (_a3 = this.linkService.eventBus) == null ? void 0 : _a3.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value,
                change: data || "",
                willCommit: false,
                selStart,
                selEnd
              }
            });
          });
        }
        this._setEventListeners(element, elementData, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.value);
      }
      if (blurListener) {
        element.addEventListener("blur", blurListener);
      }
      if (this.data.comb) {
        const fieldWidth = this.data.rect[2] - this.data.rect[0];
        const combWidth = fieldWidth / maxLen;
        element.classList.add("comb");
        element.style.letterSpacing = `calc(${combWidth}px * var(--total-scale-factor) - 1ch)`;
      }
    } else {
      element = document.createElement("div");
      element.textContent = this.data.fieldValue;
      element.style.verticalAlign = "middle";
      element.style.display = "table-cell";
      if (this.data.hasOwnCanvas) {
        element.hidden = true;
      }
    }
    this._setTextStyle(element);
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
};
var SignatureWidgetAnnotationElement = class extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: !!parameters.data.hasOwnCanvas
    });
  }
};
var CheckboxWidgetAnnotationElement = class extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.exportValue === data.fieldValue
    }).value;
    if (typeof value === "string") {
      value = value !== "Off";
      storage.setValue(id, {
        value
      });
    }
    this.container.classList.add("buttonWidgetAnnotation", "checkBox");
    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id);
    element.disabled = data.readOnly;
    this._setRequired(element, this.data.required);
    element.type = "checkbox";
    element.name = data.fieldName;
    if (value) {
      element.setAttribute("checked", true);
    }
    element.setAttribute("exportValue", data.exportValue);
    element.tabIndex = 0;
    element.addEventListener("change", (event) => {
      const {
        name,
        checked
      } = event.target;
      for (const checkbox of this._getElementsByName(name, id)) {
        const curChecked = checked && checkbox.exportValue === data.exportValue;
        if (checkbox.domElement) {
          checkbox.domElement.checked = curChecked;
        }
        storage.setValue(checkbox.id, {
          value: curChecked
        });
      }
      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", (event) => {
      const defaultValue = data.defaultFieldValue || "Off";
      event.target.checked = defaultValue === data.exportValue;
    });
    if (this.enableScripting && this.hasJSActions) {
      element.addEventListener("updatefromsandbox", (jsEvent) => {
        const actions = {
          value(event) {
            event.target.checked = event.detail.value !== "Off";
            storage.setValue(id, {
              value: event.target.checked
            });
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
    }
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
};
var RadioButtonWidgetAnnotationElement = class extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    this.container.classList.add("buttonWidgetAnnotation", "radioButton");
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.fieldValue === data.buttonValue
    }).value;
    if (typeof value === "string") {
      value = value !== data.buttonValue;
      storage.setValue(id, {
        value
      });
    }
    if (value) {
      for (const radio of this._getElementsByName(data.fieldName, id)) {
        storage.setValue(radio.id, {
          value: false
        });
      }
    }
    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id);
    element.disabled = data.readOnly;
    this._setRequired(element, this.data.required);
    element.type = "radio";
    element.name = data.fieldName;
    if (value) {
      element.setAttribute("checked", true);
    }
    element.tabIndex = 0;
    element.addEventListener("change", (event) => {
      const {
        name,
        checked
      } = event.target;
      for (const radio of this._getElementsByName(name, id)) {
        storage.setValue(radio.id, {
          value: false
        });
      }
      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", (event) => {
      const defaultValue = data.defaultFieldValue;
      event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data.buttonValue;
    });
    if (this.enableScripting && this.hasJSActions) {
      const pdfButtonValue = data.buttonValue;
      element.addEventListener("updatefromsandbox", (jsEvent) => {
        const actions = {
          value: (event) => {
            const checked = pdfButtonValue === event.detail.value;
            for (const radio of this._getElementsByName(event.target.name)) {
              const curChecked = checked && radio.id === id;
              if (radio.domElement) {
                radio.domElement.checked = curChecked;
              }
              storage.setValue(radio.id, {
                value: curChecked
              });
            }
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
    }
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
};
var PushButtonWidgetAnnotationElement = class extends LinkAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      ignoreBorder: parameters.data.hasAppearance
    });
  }
  render() {
    const container = super.render();
    container.classList.add("buttonWidgetAnnotation", "pushButton");
    const linkElement = container.lastChild;
    if (this.enableScripting && this.hasJSActions && linkElement) {
      this._setDefaultPropertiesFromJS(linkElement);
      linkElement.addEventListener("updatefromsandbox", (jsEvent) => {
        this._dispatchEventFromSandbox({}, jsEvent);
      });
    }
    return container;
  }
};
var ChoiceWidgetAnnotationElement = class extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    this.container.classList.add("choiceWidgetAnnotation");
    const storage = this.annotationStorage;
    const id = this.data.id;
    const storedData = storage.getValue(id, {
      value: this.data.fieldValue
    });
    const selectElement = document.createElement("select");
    GetElementsByNameSet.add(selectElement);
    selectElement.setAttribute("data-element-id", id);
    selectElement.disabled = this.data.readOnly;
    this._setRequired(selectElement, this.data.required);
    selectElement.name = this.data.fieldName;
    selectElement.tabIndex = 0;
    let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
    if (!this.data.combo) {
      selectElement.size = this.data.options.length;
      if (this.data.multiSelect) {
        selectElement.multiple = true;
      }
    }
    selectElement.addEventListener("resetform", (event) => {
      const defaultValue = this.data.defaultFieldValue;
      for (const option of selectElement.options) {
        option.selected = option.value === defaultValue;
      }
    });
    for (const option of this.data.options) {
      const optionElement = document.createElement("option");
      optionElement.textContent = option.displayValue;
      optionElement.value = option.exportValue;
      if (storedData.value.includes(option.exportValue)) {
        optionElement.setAttribute("selected", true);
        addAnEmptyEntry = false;
      }
      selectElement.append(optionElement);
    }
    let removeEmptyEntry = null;
    if (addAnEmptyEntry) {
      const noneOptionElement = document.createElement("option");
      noneOptionElement.value = " ";
      noneOptionElement.setAttribute("hidden", true);
      noneOptionElement.setAttribute("selected", true);
      selectElement.prepend(noneOptionElement);
      removeEmptyEntry = () => {
        noneOptionElement.remove();
        selectElement.removeEventListener("input", removeEmptyEntry);
        removeEmptyEntry = null;
      };
      selectElement.addEventListener("input", removeEmptyEntry);
    }
    const getValue = (isExport) => {
      const name = isExport ? "value" : "textContent";
      const {
        options,
        multiple
      } = selectElement;
      if (!multiple) {
        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
      }
      return Array.prototype.filter.call(options, (option) => option.selected).map((option) => option[name]);
    };
    let selectedValues = getValue(false);
    const getItems = (event) => {
      const options = event.target.options;
      return Array.prototype.map.call(options, (option) => ({
        displayValue: option.textContent,
        exportValue: option.value
      }));
    };
    if (this.enableScripting && this.hasJSActions) {
      selectElement.addEventListener("updatefromsandbox", (jsEvent) => {
        const actions = {
          value(event) {
            removeEmptyEntry == null ? void 0 : removeEmptyEntry();
            const value = event.detail.value;
            const values = new Set(Array.isArray(value) ? value : [value]);
            for (const option of selectElement.options) {
              option.selected = values.has(option.value);
            }
            storage.setValue(id, {
              value: getValue(true)
            });
            selectedValues = getValue(false);
          },
          multipleSelection(event) {
            selectElement.multiple = true;
          },
          remove(event) {
            const options = selectElement.options;
            const index = event.detail.remove;
            options[index].selected = false;
            selectElement.remove(index);
            if (options.length > 0) {
              const i = Array.prototype.findIndex.call(options, (option) => option.selected);
              if (i === -1) {
                options[0].selected = true;
              }
            }
            storage.setValue(id, {
              value: getValue(true),
              items: getItems(event)
            });
            selectedValues = getValue(false);
          },
          clear(event) {
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }
            storage.setValue(id, {
              value: null,
              items: []
            });
            selectedValues = getValue(false);
          },
          insert(event) {
            const {
              index,
              displayValue,
              exportValue
            } = event.detail.insert;
            const selectChild = selectElement.children[index];
            const optionElement = document.createElement("option");
            optionElement.textContent = displayValue;
            optionElement.value = exportValue;
            if (selectChild) {
              selectChild.before(optionElement);
            } else {
              selectElement.append(optionElement);
            }
            storage.setValue(id, {
              value: getValue(true),
              items: getItems(event)
            });
            selectedValues = getValue(false);
          },
          items(event) {
            const {
              items
            } = event.detail;
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }
            for (const item of items) {
              const {
                displayValue,
                exportValue
              } = item;
              const optionElement = document.createElement("option");
              optionElement.textContent = displayValue;
              optionElement.value = exportValue;
              selectElement.append(optionElement);
            }
            if (selectElement.options.length > 0) {
              selectElement.options[0].selected = true;
            }
            storage.setValue(id, {
              value: getValue(true),
              items: getItems(event)
            });
            selectedValues = getValue(false);
          },
          indices(event) {
            const indices = new Set(event.detail.indices);
            for (const option of event.target.options) {
              option.selected = indices.has(option.index);
            }
            storage.setValue(id, {
              value: getValue(true)
            });
            selectedValues = getValue(false);
          },
          editable(event) {
            event.target.disabled = !event.detail.editable;
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      selectElement.addEventListener("input", (event) => {
        var _a2;
        const exportValue = getValue(true);
        const change = getValue(false);
        storage.setValue(id, {
          value: exportValue
        });
        event.preventDefault();
        (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id,
            name: "Keystroke",
            value: selectedValues,
            change,
            changeEx: exportValue,
            willCommit: false,
            commitKey: 1,
            keyDown: false
          }
        });
      });
      this._setEventListeners(selectElement, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (event) => event.target.value);
    } else {
      selectElement.addEventListener("input", function(event) {
        storage.setValue(id, {
          value: getValue(true)
        });
      });
    }
    if (this.data.combo) {
      this._setTextStyle(selectElement);
    } else {
    }
    this._setBackgroundColor(selectElement);
    this._setDefaultPropertiesFromJS(selectElement);
    this.container.append(selectElement);
    return this.container;
  }
};
var _createPopup, createPopup_fn;
var PopupAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    const {
      data,
      elements,
      parent
    } = parameters;
    const hasCommentManager = !!parent._commentManager;
    super(parameters, {
      isRenderable: !hasCommentManager && AnnotationElement._hasPopupData(data)
    });
    __privateAdd(this, _createPopup);
    this.elements = elements;
    if (hasCommentManager && AnnotationElement._hasPopupData(data)) {
      const popup = this.popup = __privateMethod(this, _createPopup, createPopup_fn).call(this);
      for (const element of elements) {
        element.popup = popup;
      }
    } else {
      this.popup = null;
    }
  }
  render() {
    const {
      container
    } = this;
    container.classList.add("popupAnnotation");
    container.role = "comment";
    const popup = this.popup = __privateMethod(this, _createPopup, createPopup_fn).call(this);
    const elementIds = [];
    for (const element of this.elements) {
      element.popup = popup;
      element.container.ariaHasPopup = "dialog";
      elementIds.push(element.data.id);
      element.addHighlightArea();
    }
    this.container.setAttribute("aria-controls", elementIds.map((id) => `${AnnotationPrefix}${id}`).join(","));
    return this.container;
  }
};
_createPopup = new WeakSet();
createPopup_fn = function() {
  return new PopupElement({
    container: this.container,
    color: this.data.color,
    titleObj: this.data.titleObj,
    modificationDate: this.data.modificationDate || this.data.creationDate,
    contentsObj: this.data.contentsObj,
    richText: this.data.richText,
    rect: this.data.rect,
    parentRect: this.data.parentRect || null,
    parent: this.parent,
    elements: this.elements,
    open: this.data.open,
    commentManager: this.parent._commentManager
  });
};
var _commentManager2, _boundKeyDown, _boundHide, _boundShow, _boundToggle, _color, _container4, _contentsObj, _dateObj, _elements, _parent, _parentRect, _pinned, _popup, _popupAbortController, _position2, _commentButton, _commentButtonPosition, _popupPosition2, _rect, _richText2, _titleObj, _updates2, _wasVisible, _firstElement, _commentText, _addEventListeners, addEventListeners_fn, _setCommentButtonPosition, setCommentButtonPosition_fn, _updateCommentButtonPosition, updateCommentButtonPosition_fn, _updateColor, updateColor_fn, _html, html_get, _fontSize, fontSize_get, _fontColor, fontColor_get, _makePopupContent, makePopupContent_fn, _keyDown2, keyDown_fn2, _setPosition, setPosition_fn, _toggle, toggle_fn, _show, show_fn, _hide, hide_fn;
var PopupElement = class {
  constructor({
    container,
    color,
    elements,
    titleObj,
    modificationDate,
    contentsObj,
    richText,
    parent,
    rect,
    parentRect,
    open,
    commentManager = null
  }) {
    __privateAdd(this, _addEventListeners);
    __privateAdd(this, _setCommentButtonPosition);
    __privateAdd(this, _updateCommentButtonPosition);
    __privateAdd(this, _updateColor);
    __privateAdd(this, _html);
    __privateAdd(this, _fontSize);
    __privateAdd(this, _fontColor);
    __privateAdd(this, _makePopupContent);
    __privateAdd(this, _keyDown2);
    __privateAdd(this, _setPosition);
    __privateAdd(this, _toggle);
    __privateAdd(this, _show);
    __privateAdd(this, _hide);
    __privateAdd(this, _commentManager2, null);
    __privateAdd(this, _boundKeyDown, __privateMethod(this, _keyDown2, keyDown_fn2).bind(this));
    __privateAdd(this, _boundHide, __privateMethod(this, _hide, hide_fn).bind(this));
    __privateAdd(this, _boundShow, __privateMethod(this, _show, show_fn).bind(this));
    __privateAdd(this, _boundToggle, __privateMethod(this, _toggle, toggle_fn).bind(this));
    __privateAdd(this, _color, null);
    __privateAdd(this, _container4, null);
    __privateAdd(this, _contentsObj, null);
    __privateAdd(this, _dateObj, null);
    __privateAdd(this, _elements, null);
    __privateAdd(this, _parent, null);
    __privateAdd(this, _parentRect, null);
    __privateAdd(this, _pinned, false);
    __privateAdd(this, _popup, null);
    __privateAdd(this, _popupAbortController, null);
    __privateAdd(this, _position2, null);
    __privateAdd(this, _commentButton, null);
    __privateAdd(this, _commentButtonPosition, null);
    __privateAdd(this, _popupPosition2, null);
    __privateAdd(this, _rect, null);
    __privateAdd(this, _richText2, null);
    __privateAdd(this, _titleObj, null);
    __privateAdd(this, _updates2, null);
    __privateAdd(this, _wasVisible, false);
    __privateAdd(this, _firstElement, null);
    __privateAdd(this, _commentText, null);
    __privateSet(this, _container4, container);
    __privateSet(this, _titleObj, titleObj);
    __privateSet(this, _contentsObj, contentsObj);
    __privateSet(this, _richText2, richText);
    __privateSet(this, _parent, parent);
    __privateSet(this, _color, color);
    __privateSet(this, _rect, rect);
    __privateSet(this, _parentRect, parentRect);
    __privateSet(this, _elements, elements);
    __privateSet(this, _commentManager2, commentManager);
    __privateSet(this, _firstElement, elements[0]);
    __privateSet(this, _dateObj, PDFDateString.toDateObject(modificationDate));
    this.trigger = elements.flatMap((e) => e.getElementsToTriggerPopup());
    if (commentManager) {
      this.renderCommentButton();
    } else {
      __privateMethod(this, _addEventListeners, addEventListeners_fn).call(this);
      __privateGet(this, _container4).hidden = true;
      if (open) {
        __privateMethod(this, _toggle, toggle_fn).call(this);
      }
    }
  }
  renderCommentButton() {
    if (__privateGet(this, _commentButton)) {
      return;
    }
    if (!__privateGet(this, _commentButtonPosition)) {
      __privateMethod(this, _setCommentButtonPosition, setCommentButtonPosition_fn).call(this);
    }
    if (!__privateGet(this, _commentButtonPosition)) {
      return;
    }
    const {
      signal
    } = __privateSet(this, _popupAbortController, new AbortController());
    const hasOwnButton = !!__privateGet(this, _firstElement).extraPopupElement;
    const togglePopup = () => {
      __privateGet(this, _commentManager2).toggleCommentPopup(this, true, void 0, !hasOwnButton);
    };
    const showPopup = () => {
      __privateGet(this, _commentManager2).toggleCommentPopup(this, false, true, !hasOwnButton);
    };
    const hidePopup = () => {
      __privateGet(this, _commentManager2).toggleCommentPopup(this, false, false);
    };
    if (!hasOwnButton) {
      const button = __privateSet(this, _commentButton, document.createElement("button"));
      button.className = "annotationCommentButton";
      const parentContainer = __privateGet(this, _firstElement).container;
      button.style.zIndex = parentContainer.style.zIndex + 1;
      button.tabIndex = 0;
      button.ariaHasPopup = "dialog";
      button.ariaControls = "commentPopup";
      button.setAttribute("data-l10n-id", "pdfjs-show-comment-button");
      __privateMethod(this, _updateColor, updateColor_fn).call(this);
      __privateMethod(this, _updateCommentButtonPosition, updateCommentButtonPosition_fn).call(this);
      button.addEventListener("keydown", __privateGet(this, _boundKeyDown), {
        signal
      });
      button.addEventListener("click", togglePopup, {
        signal
      });
      button.addEventListener("pointerenter", showPopup, {
        signal
      });
      button.addEventListener("pointerleave", hidePopup, {
        signal
      });
      parentContainer.after(button);
    } else {
      __privateSet(this, _commentButton, __privateGet(this, _firstElement).container);
      for (const element of this.trigger) {
        element.ariaHasPopup = "dialog";
        element.ariaControls = "commentPopup";
        element.addEventListener("keydown", __privateGet(this, _boundKeyDown), {
          signal
        });
        element.addEventListener("click", togglePopup, {
          signal
        });
        element.addEventListener("pointerenter", showPopup, {
          signal
        });
        element.addEventListener("pointerleave", hidePopup, {
          signal
        });
        element.classList.add("popupTriggerArea");
      }
    }
  }
  get commentButtonColor() {
    const {
      color,
      opacity
    } = __privateGet(this, _firstElement).commentData;
    if (!color) {
      return null;
    }
    return __privateGet(this, _parent)._commentManager.makeCommentColor(color, opacity);
  }
  focusCommentButton() {
    setTimeout(() => {
      var _a2;
      (_a2 = __privateGet(this, _commentButton)) == null ? void 0 : _a2.focus();
    }, 0);
  }
  getData() {
    const {
      richText,
      color,
      opacity,
      creationDate,
      modificationDate
    } = __privateGet(this, _firstElement).commentData;
    return {
      contentsObj: {
        str: this.comment
      },
      richText,
      color,
      opacity,
      creationDate,
      modificationDate
    };
  }
  get elementBeforePopup() {
    return __privateGet(this, _commentButton);
  }
  get comment() {
    __privateGet(this, _commentText) || __privateSet(this, _commentText, __privateGet(this, _firstElement).commentText);
    return __privateGet(this, _commentText);
  }
  set comment(text) {
    if (text === this.comment) {
      return;
    }
    __privateGet(this, _firstElement).commentText = __privateSet(this, _commentText, text);
  }
  get parentBoundingClientRect() {
    return __privateGet(this, _firstElement).layer.getBoundingClientRect();
  }
  setCommentButtonStates({
    selected,
    hasPopup
  }) {
    if (!__privateGet(this, _commentButton)) {
      return;
    }
    __privateGet(this, _commentButton).classList.toggle("selected", selected);
    __privateGet(this, _commentButton).ariaExpanded = hasPopup;
  }
  setSelectedCommentButton(selected) {
    __privateGet(this, _commentButton).classList.toggle("selected", selected);
  }
  get commentPopupPosition() {
    if (__privateGet(this, _popupPosition2)) {
      return __privateGet(this, _popupPosition2);
    }
    const {
      x,
      y,
      height
    } = __privateGet(this, _commentButton).getBoundingClientRect();
    const {
      x: parentX,
      y: parentY,
      width: parentWidth,
      height: parentHeight
    } = __privateGet(this, _firstElement).layer.getBoundingClientRect();
    return [(x - parentX) / parentWidth, (y + height - parentY) / parentHeight];
  }
  set commentPopupPosition(pos) {
    __privateSet(this, _popupPosition2, pos);
  }
  hasDefaultPopupPosition() {
    return __privateGet(this, _popupPosition2) === null;
  }
  get commentButtonPosition() {
    return __privateGet(this, _commentButtonPosition);
  }
  get commentButtonWidth() {
    return __privateGet(this, _commentButton).getBoundingClientRect().width / this.parentBoundingClientRect.width;
  }
  editComment(options) {
    const [posX, posY] = __privateGet(this, _popupPosition2) || this.commentButtonPosition.map((x) => x / 100);
    const parentDimensions = this.parentBoundingClientRect;
    const {
      x: parentX,
      y: parentY,
      width: parentWidth,
      height: parentHeight
    } = parentDimensions;
    __privateGet(this, _commentManager2).showDialog(null, this, parentX + posX * parentWidth, parentY + posY * parentHeight, {
      ...options,
      parentDimensions
    });
  }
  render() {
    var _a2, _b;
    if (__privateGet(this, _popup)) {
      return;
    }
    const popup = __privateSet(this, _popup, document.createElement("div"));
    popup.className = "popup";
    if (__privateGet(this, _color)) {
      const baseColor = popup.style.outlineColor = Util.makeHexColor(...__privateGet(this, _color));
      popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
    }
    const header = document.createElement("span");
    header.className = "header";
    if ((_a2 = __privateGet(this, _titleObj)) == null ? void 0 : _a2.str) {
      const title = document.createElement("span");
      title.className = "title";
      header.append(title);
      ({
        dir: title.dir,
        str: title.textContent
      } = __privateGet(this, _titleObj));
    }
    popup.append(header);
    if (__privateGet(this, _dateObj)) {
      const modificationDate = document.createElement("time");
      modificationDate.className = "popupDate";
      modificationDate.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string");
      modificationDate.setAttribute("data-l10n-args", JSON.stringify({
        dateObj: __privateGet(this, _dateObj).valueOf()
      }));
      modificationDate.dateTime = __privateGet(this, _dateObj).toISOString();
      header.append(modificationDate);
    }
    renderRichText({
      html: __privateGet(this, _html, html_get) || __privateGet(this, _contentsObj).str,
      dir: (_b = __privateGet(this, _contentsObj)) == null ? void 0 : _b.dir,
      className: "popupContent"
    }, popup);
    __privateGet(this, _container4).append(popup);
  }
  updateEdited({
    rect,
    popup,
    deleted
  }) {
    var _a2;
    if (__privateGet(this, _commentManager2)) {
      if (deleted) {
        this.remove();
        __privateSet(this, _commentText, null);
      } else if (popup) {
        if (popup.deleted) {
          this.remove();
        } else {
          __privateMethod(this, _updateColor, updateColor_fn).call(this);
          __privateSet(this, _commentText, popup.text);
        }
      }
      if (rect) {
        __privateSet(this, _commentButtonPosition, null);
        __privateMethod(this, _setCommentButtonPosition, setCommentButtonPosition_fn).call(this);
        __privateMethod(this, _updateCommentButtonPosition, updateCommentButtonPosition_fn).call(this);
      }
      return;
    }
    if (deleted || (popup == null ? void 0 : popup.deleted)) {
      this.remove();
      return;
    }
    __privateMethod(this, _addEventListeners, addEventListeners_fn).call(this);
    __privateGet(this, _updates2) || __privateSet(this, _updates2, {
      contentsObj: __privateGet(this, _contentsObj),
      richText: __privateGet(this, _richText2)
    });
    if (rect) {
      __privateSet(this, _position2, null);
    }
    if (popup && popup.text) {
      __privateSet(this, _richText2, __privateMethod(this, _makePopupContent, makePopupContent_fn).call(this, popup.text));
      __privateSet(this, _dateObj, PDFDateString.toDateObject(popup.date));
      __privateSet(this, _contentsObj, null);
    }
    (_a2 = __privateGet(this, _popup)) == null ? void 0 : _a2.remove();
    __privateSet(this, _popup, null);
  }
  resetEdited() {
    var _a2;
    if (!__privateGet(this, _updates2)) {
      return;
    }
    ({
      contentsObj: __privateWrapper(this, _contentsObj)._,
      richText: __privateWrapper(this, _richText2)._
    } = __privateGet(this, _updates2));
    __privateSet(this, _updates2, null);
    (_a2 = __privateGet(this, _popup)) == null ? void 0 : _a2.remove();
    __privateSet(this, _popup, null);
    __privateSet(this, _position2, null);
  }
  remove() {
    var _a2, _b, _c;
    (_a2 = __privateGet(this, _popupAbortController)) == null ? void 0 : _a2.abort();
    __privateSet(this, _popupAbortController, null);
    (_b = __privateGet(this, _popup)) == null ? void 0 : _b.remove();
    __privateSet(this, _popup, null);
    __privateSet(this, _wasVisible, false);
    __privateSet(this, _pinned, false);
    (_c = __privateGet(this, _commentButton)) == null ? void 0 : _c.remove();
    __privateSet(this, _commentButton, null);
    if (this.trigger) {
      for (const element of this.trigger) {
        element.classList.remove("popupTriggerArea");
      }
    }
  }
  forceHide() {
    __privateSet(this, _wasVisible, this.isVisible);
    if (!__privateGet(this, _wasVisible)) {
      return;
    }
    __privateGet(this, _container4).hidden = true;
  }
  maybeShow() {
    if (__privateGet(this, _commentManager2)) {
      return;
    }
    __privateMethod(this, _addEventListeners, addEventListeners_fn).call(this);
    if (!__privateGet(this, _wasVisible)) {
      return;
    }
    if (!__privateGet(this, _popup)) {
      __privateMethod(this, _show, show_fn).call(this);
    }
    __privateSet(this, _wasVisible, false);
    __privateGet(this, _container4).hidden = false;
  }
  get isVisible() {
    if (__privateGet(this, _commentManager2)) {
      return false;
    }
    return __privateGet(this, _container4).hidden === false;
  }
};
_commentManager2 = new WeakMap();
_boundKeyDown = new WeakMap();
_boundHide = new WeakMap();
_boundShow = new WeakMap();
_boundToggle = new WeakMap();
_color = new WeakMap();
_container4 = new WeakMap();
_contentsObj = new WeakMap();
_dateObj = new WeakMap();
_elements = new WeakMap();
_parent = new WeakMap();
_parentRect = new WeakMap();
_pinned = new WeakMap();
_popup = new WeakMap();
_popupAbortController = new WeakMap();
_position2 = new WeakMap();
_commentButton = new WeakMap();
_commentButtonPosition = new WeakMap();
_popupPosition2 = new WeakMap();
_rect = new WeakMap();
_richText2 = new WeakMap();
_titleObj = new WeakMap();
_updates2 = new WeakMap();
_wasVisible = new WeakMap();
_firstElement = new WeakMap();
_commentText = new WeakMap();
_addEventListeners = new WeakSet();
addEventListeners_fn = function() {
  var _a2;
  if (__privateGet(this, _popupAbortController)) {
    return;
  }
  __privateSet(this, _popupAbortController, new AbortController());
  const {
    signal
  } = __privateGet(this, _popupAbortController);
  for (const element of this.trigger) {
    element.addEventListener("click", __privateGet(this, _boundToggle), {
      signal
    });
    element.addEventListener("pointerenter", __privateGet(this, _boundShow), {
      signal
    });
    element.addEventListener("pointerleave", __privateGet(this, _boundHide), {
      signal
    });
    element.classList.add("popupTriggerArea");
  }
  for (const element of __privateGet(this, _elements)) {
    (_a2 = element.container) == null ? void 0 : _a2.addEventListener("keydown", __privateGet(this, _boundKeyDown), {
      signal
    });
  }
};
_setCommentButtonPosition = new WeakSet();
setCommentButtonPosition_fn = function() {
  const element = __privateGet(this, _elements).find((e) => e.hasCommentButton);
  if (!element) {
    return;
  }
  __privateSet(this, _commentButtonPosition, element._normalizePoint(element.commentButtonPosition));
};
_updateCommentButtonPosition = new WeakSet();
updateCommentButtonPosition_fn = function() {
  if (__privateGet(this, _firstElement).extraPopupElement && !__privateGet(this, _firstElement).editor) {
    return;
  }
  this.renderCommentButton();
  const [x, y] = __privateGet(this, _commentButtonPosition);
  const {
    style
  } = __privateGet(this, _commentButton);
  style.left = `calc(${x}%)`;
  style.top = `calc(${y}% - var(--comment-button-dim))`;
};
_updateColor = new WeakSet();
updateColor_fn = function() {
  if (__privateGet(this, _firstElement).extraPopupElement) {
    return;
  }
  this.renderCommentButton();
  __privateGet(this, _commentButton).style.backgroundColor = this.commentButtonColor || "";
};
_html = new WeakSet();
html_get = function() {
  const richText = __privateGet(this, _richText2);
  const contentsObj = __privateGet(this, _contentsObj);
  if ((richText == null ? void 0 : richText.str) && (!(contentsObj == null ? void 0 : contentsObj.str) || contentsObj.str === richText.str)) {
    return __privateGet(this, _richText2).html || null;
  }
  return null;
};
_fontSize = new WeakSet();
fontSize_get = function() {
  var _a2, _b, _c;
  return ((_c = (_b = (_a2 = __privateGet(this, _html, html_get)) == null ? void 0 : _a2.attributes) == null ? void 0 : _b.style) == null ? void 0 : _c.fontSize) || 0;
};
_fontColor = new WeakSet();
fontColor_get = function() {
  var _a2, _b, _c;
  return ((_c = (_b = (_a2 = __privateGet(this, _html, html_get)) == null ? void 0 : _a2.attributes) == null ? void 0 : _b.style) == null ? void 0 : _c.color) || null;
};
_makePopupContent = new WeakSet();
makePopupContent_fn = function(text) {
  const popupLines = [];
  const popupContent = {
    str: text,
    html: {
      name: "div",
      attributes: {
        dir: "auto"
      },
      children: [{
        name: "p",
        children: popupLines
      }]
    }
  };
  const lineAttributes = {
    style: {
      color: __privateGet(this, _fontColor, fontColor_get),
      fontSize: __privateGet(this, _fontSize, fontSize_get) ? `calc(${__privateGet(this, _fontSize, fontSize_get)}px * var(--total-scale-factor))` : ""
    }
  };
  for (const line of text.split("\n")) {
    popupLines.push({
      name: "span",
      value: line,
      attributes: lineAttributes
    });
  }
  return popupContent;
};
_keyDown2 = new WeakSet();
keyDown_fn2 = function(event) {
  if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
    return;
  }
  if (event.key === "Enter" || event.key === "Escape" && __privateGet(this, _pinned)) {
    __privateMethod(this, _toggle, toggle_fn).call(this);
  }
};
_setPosition = new WeakSet();
setPosition_fn = function() {
  if (__privateGet(this, _position2) !== null) {
    return;
  }
  const {
    page: {
      view
    },
    viewport: {
      rawDims: {
        pageWidth,
        pageHeight,
        pageX,
        pageY
      }
    }
  } = __privateGet(this, _parent);
  let useParentRect = !!__privateGet(this, _parentRect);
  let rect = useParentRect ? __privateGet(this, _parentRect) : __privateGet(this, _rect);
  for (const element of __privateGet(this, _elements)) {
    if (!rect || Util.intersect(element.data.rect, rect) !== null) {
      rect = element.data.rect;
      useParentRect = true;
      break;
    }
  }
  const normalizedRect = Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);
  const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
  const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;
  const popupLeft = normalizedRect[0] + parentWidth;
  const popupTop = normalizedRect[1];
  __privateSet(this, _position2, [100 * (popupLeft - pageX) / pageWidth, 100 * (popupTop - pageY) / pageHeight]);
  const {
    style
  } = __privateGet(this, _container4);
  style.left = `${__privateGet(this, _position2)[0]}%`;
  style.top = `${__privateGet(this, _position2)[1]}%`;
};
_toggle = new WeakSet();
toggle_fn = function() {
  if (__privateGet(this, _commentManager2)) {
    __privateGet(this, _commentManager2).toggleCommentPopup(this, false);
    return;
  }
  __privateSet(this, _pinned, !__privateGet(this, _pinned));
  if (__privateGet(this, _pinned)) {
    __privateMethod(this, _show, show_fn).call(this);
    __privateGet(this, _container4).addEventListener("click", __privateGet(this, _boundToggle));
    __privateGet(this, _container4).addEventListener("keydown", __privateGet(this, _boundKeyDown));
  } else {
    __privateMethod(this, _hide, hide_fn).call(this);
    __privateGet(this, _container4).removeEventListener("click", __privateGet(this, _boundToggle));
    __privateGet(this, _container4).removeEventListener("keydown", __privateGet(this, _boundKeyDown));
  }
};
_show = new WeakSet();
show_fn = function() {
  if (!__privateGet(this, _popup)) {
    this.render();
  }
  if (!this.isVisible) {
    __privateMethod(this, _setPosition, setPosition_fn).call(this);
    __privateGet(this, _container4).hidden = false;
    __privateGet(this, _container4).style.zIndex = parseInt(__privateGet(this, _container4).style.zIndex) + 1e3;
  } else if (__privateGet(this, _pinned)) {
    __privateGet(this, _container4).classList.add("focused");
  }
};
_hide = new WeakSet();
hide_fn = function() {
  __privateGet(this, _container4).classList.remove("focused");
  if (__privateGet(this, _pinned) || !this.isVisible) {
    return;
  }
  __privateGet(this, _container4).hidden = true;
  __privateGet(this, _container4).style.zIndex = parseInt(__privateGet(this, _container4).style.zIndex) - 1e3;
};
var FreeTextAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.textContent = parameters.data.textContent;
    this.textPosition = parameters.data.textPosition;
    this.annotationEditorType = AnnotationEditorType.FREETEXT;
  }
  render() {
    this.container.classList.add("freeTextAnnotation");
    if (this.textContent) {
      const content = document.createElement("div");
      content.classList.add("annotationTextContent");
      content.setAttribute("role", "comment");
      for (const line of this.textContent) {
        const lineSpan = document.createElement("span");
        lineSpan.textContent = line;
        content.append(lineSpan);
      }
      this.container.append(content);
    }
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this._editOnDoubleClick();
    return this.container;
  }
};
var _line;
var LineAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    __privateAdd(this, _line, null);
  }
  render() {
    this.container.classList.add("lineAnnotation");
    const {
      data,
      width,
      height
    } = this;
    const svg = this.svgFactory.create(width, height, true);
    const line = __privateSet(this, _line, this.svgFactory.createElement("svg:line"));
    line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
    line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
    line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
    line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
    line.setAttribute("stroke-width", data.borderStyle.width || 1);
    line.setAttribute("stroke", "transparent");
    line.setAttribute("fill", "transparent");
    svg.append(line);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _line);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_line = new WeakMap();
var _square;
var SquareAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    __privateAdd(this, _square, null);
  }
  render() {
    this.container.classList.add("squareAnnotation");
    const {
      data,
      width,
      height
    } = this;
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data.borderStyle.width;
    const square = __privateSet(this, _square, this.svgFactory.createElement("svg:rect"));
    square.setAttribute("x", borderWidth / 2);
    square.setAttribute("y", borderWidth / 2);
    square.setAttribute("width", width - borderWidth);
    square.setAttribute("height", height - borderWidth);
    square.setAttribute("stroke-width", borderWidth || 1);
    square.setAttribute("stroke", "transparent");
    square.setAttribute("fill", "transparent");
    svg.append(square);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _square);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_square = new WeakMap();
var _circle;
var CircleAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    __privateAdd(this, _circle, null);
  }
  render() {
    this.container.classList.add("circleAnnotation");
    const {
      data,
      width,
      height
    } = this;
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data.borderStyle.width;
    const circle = __privateSet(this, _circle, this.svgFactory.createElement("svg:ellipse"));
    circle.setAttribute("cx", width / 2);
    circle.setAttribute("cy", height / 2);
    circle.setAttribute("rx", width / 2 - borderWidth / 2);
    circle.setAttribute("ry", height / 2 - borderWidth / 2);
    circle.setAttribute("stroke-width", borderWidth || 1);
    circle.setAttribute("stroke", "transparent");
    circle.setAttribute("fill", "transparent");
    svg.append(circle);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _circle);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_circle = new WeakMap();
var _polyline;
var PolylineAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    __privateAdd(this, _polyline, null);
    this.containerClassName = "polylineAnnotation";
    this.svgElementName = "svg:polyline";
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect,
        vertices,
        borderStyle,
        popupRef
      },
      width,
      height
    } = this;
    if (!vertices) {
      return this.container;
    }
    const svg = this.svgFactory.create(width, height, true);
    let points = [];
    for (let i = 0, ii = vertices.length; i < ii; i += 2) {
      const x = vertices[i] - rect[0];
      const y = rect[3] - vertices[i + 1];
      points.push(`${x},${y}`);
    }
    points = points.join(" ");
    const polyline = __privateSet(this, _polyline, this.svgFactory.createElement(this.svgElementName));
    polyline.setAttribute("points", points);
    polyline.setAttribute("stroke-width", borderStyle.width || 1);
    polyline.setAttribute("stroke", "transparent");
    polyline.setAttribute("fill", "transparent");
    svg.append(polyline);
    this.container.append(svg);
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _polyline);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_polyline = new WeakMap();
var PolygonAnnotationElement = class extends PolylineAnnotationElement {
  constructor(parameters) {
    super(parameters);
    this.containerClassName = "polygonAnnotation";
    this.svgElementName = "svg:polygon";
  }
};
var CaretAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("caretAnnotation");
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
};
var _polylinesGroupElement, _polylines, _getTransform, getTransform_fn;
var InkAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    __privateAdd(this, _getTransform);
    __privateAdd(this, _polylinesGroupElement, null);
    __privateAdd(this, _polylines, []);
    this.containerClassName = "inkAnnotation";
    this.svgElementName = "svg:polyline";
    this.annotationEditorType = this.data.it === "InkHighlight" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect,
        rotation,
        inkLists,
        borderStyle,
        popupRef
      }
    } = this;
    const {
      transform,
      width,
      height
    } = __privateMethod(this, _getTransform, getTransform_fn).call(this, rotation, rect);
    const svg = this.svgFactory.create(width, height, true);
    const g = __privateSet(this, _polylinesGroupElement, this.svgFactory.createElement("svg:g"));
    svg.append(g);
    g.setAttribute("stroke-width", borderStyle.width || 1);
    g.setAttribute("stroke-linecap", "round");
    g.setAttribute("stroke-linejoin", "round");
    g.setAttribute("stroke-miterlimit", 10);
    g.setAttribute("stroke", "transparent");
    g.setAttribute("fill", "transparent");
    g.setAttribute("transform", transform);
    for (let i = 0, ii = inkLists.length; i < ii; i++) {
      const polyline = this.svgFactory.createElement(this.svgElementName);
      __privateGet(this, _polylines).push(polyline);
      polyline.setAttribute("points", inkLists[i].join(","));
      g.append(polyline);
    }
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.append(svg);
    this._editOnDoubleClick();
    return this.container;
  }
  updateEdited(params) {
    super.updateEdited(params);
    const {
      thickness,
      points,
      rect
    } = params;
    const g = __privateGet(this, _polylinesGroupElement);
    if (thickness >= 0) {
      g.setAttribute("stroke-width", thickness || 1);
    }
    if (points) {
      for (let i = 0, ii = __privateGet(this, _polylines).length; i < ii; i++) {
        __privateGet(this, _polylines)[i].setAttribute("points", points[i].join(","));
      }
    }
    if (rect) {
      const {
        transform,
        width,
        height
      } = __privateMethod(this, _getTransform, getTransform_fn).call(this, this.data.rotation, rect);
      const root = g.parentElement;
      root.setAttribute("viewBox", `0 0 ${width} ${height}`);
      g.setAttribute("transform", transform);
    }
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _polylines);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_polylinesGroupElement = new WeakMap();
_polylines = new WeakMap();
_getTransform = new WeakSet();
getTransform_fn = function(rotation, rect) {
  switch (rotation) {
    case 90:
      return {
        transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,
        width: rect[3] - rect[1],
        height: rect[2] - rect[0]
      };
    case 180:
      return {
        transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,
        width: rect[2] - rect[0],
        height: rect[3] - rect[1]
      };
    case 270:
      return {
        transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,
        width: rect[3] - rect[1],
        height: rect[2] - rect[0]
      };
    default:
      return {
        transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,
        width: rect[2] - rect[0],
        height: rect[3] - rect[1]
      };
  }
};
var HighlightAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
    this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;
  }
  render() {
    const {
      data: {
        overlaidText,
        popupRef
      }
    } = this;
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("highlightAnnotation");
    this._editOnDoubleClick();
    if (overlaidText) {
      const mark = document.createElement("mark");
      mark.classList.add("overlaidText");
      mark.textContent = overlaidText;
      this.container.append(mark);
    }
    return this.container;
  }
};
var UnderlineAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    const {
      data: {
        overlaidText,
        popupRef
      }
    } = this;
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("underlineAnnotation");
    if (overlaidText) {
      const underline = document.createElement("u");
      underline.classList.add("overlaidText");
      underline.textContent = overlaidText;
      this.container.append(underline);
    }
    return this.container;
  }
};
var SquigglyAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    const {
      data: {
        overlaidText,
        popupRef
      }
    } = this;
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("squigglyAnnotation");
    if (overlaidText) {
      const underline = document.createElement("u");
      underline.classList.add("overlaidText");
      underline.textContent = overlaidText;
      this.container.append(underline);
    }
    return this.container;
  }
};
var StrikeOutAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    const {
      data: {
        overlaidText,
        popupRef
      }
    } = this;
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("strikeoutAnnotation");
    if (overlaidText) {
      const strikeout = document.createElement("s");
      strikeout.classList.add("overlaidText");
      strikeout.textContent = overlaidText;
      this.container.append(strikeout);
    }
    return this.container;
  }
};
var StampAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.annotationEditorType = AnnotationEditorType.STAMP;
  }
  render() {
    this.container.classList.add("stampAnnotation");
    this.container.setAttribute("role", "img");
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this._editOnDoubleClick();
    return this.container;
  }
};
var _trigger, _download, download_fn;
var FileAttachmentAnnotationElement = class extends AnnotationElement {
  constructor(parameters) {
    var _a2;
    super(parameters, {
      isRenderable: true
    });
    __privateAdd(this, _download);
    __privateAdd(this, _trigger, null);
    const {
      file
    } = this.data;
    this.filename = file.filename;
    this.content = file.content;
    (_a2 = this.linkService.eventBus) == null ? void 0 : _a2.dispatch("fileattachmentannotation", {
      source: this,
      ...file
    });
  }
  render() {
    this.container.classList.add("fileAttachmentAnnotation");
    const {
      container,
      data
    } = this;
    let trigger;
    if (data.hasAppearance || data.fillAlpha === 0) {
      trigger = document.createElement("div");
    } else {
      trigger = document.createElement("img");
      trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? "paperclip" : "pushpin"}.svg`;
      if (data.fillAlpha && data.fillAlpha < 1) {
        trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;
      }
    }
    trigger.addEventListener("dblclick", __privateMethod(this, _download, download_fn).bind(this));
    __privateSet(this, _trigger, trigger);
    const {
      isMac
    } = util_FeatureTest.platform;
    container.addEventListener("keydown", (evt) => {
      if (evt.key === "Enter" && (isMac ? evt.metaKey : evt.ctrlKey)) {
        __privateMethod(this, _download, download_fn).call(this);
      }
    });
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    } else {
      trigger.classList.add("popupTriggerArea");
    }
    container.append(trigger);
    return container;
  }
  getElementsToTriggerPopup() {
    return __privateGet(this, _trigger);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
_trigger = new WeakMap();
_download = new WeakSet();
download_fn = function() {
  var _a2;
  (_a2 = this.downloadManager) == null ? void 0 : _a2.openOrDownloadData(this.content, this.filename);
};
var _accessibilityManager, _annotationCanvasMap, _annotationStorage2, _editableAnnotations, _structTreeLayer, _linkService, _appendElement, appendElement_fn, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn;
var _AnnotationLayer = class _AnnotationLayer {
  constructor({
    div,
    accessibilityManager,
    annotationCanvasMap,
    annotationEditorUIManager,
    page,
    viewport,
    structTreeLayer,
    commentManager,
    linkService,
    annotationStorage
  }) {
    __privateAdd(this, _appendElement);
    __privateAdd(this, _setAnnotationCanvasMap);
    __privateAdd(this, _accessibilityManager, null);
    __privateAdd(this, _annotationCanvasMap, null);
    __privateAdd(this, _annotationStorage2, null);
    __privateAdd(this, _editableAnnotations, /* @__PURE__ */ new Map());
    __privateAdd(this, _structTreeLayer, null);
    __privateAdd(this, _linkService, null);
    this.div = div;
    __privateSet(this, _accessibilityManager, accessibilityManager);
    __privateSet(this, _annotationCanvasMap, annotationCanvasMap);
    __privateSet(this, _structTreeLayer, structTreeLayer || null);
    __privateSet(this, _linkService, linkService || null);
    __privateSet(this, _annotationStorage2, annotationStorage || new AnnotationStorage());
    this.page = page;
    this.viewport = viewport;
    this.zIndex = 0;
    this._annotationEditorUIManager = annotationEditorUIManager;
    this._commentManager = commentManager || null;
  }
  hasEditableAnnotations() {
    return __privateGet(this, _editableAnnotations).size > 0;
  }
  async render(params) {
    var _a2, _b, _c;
    const {
      annotations
    } = params;
    const layer = this.div;
    setLayerDimensions(layer, this.viewport);
    const popupToElements = /* @__PURE__ */ new Map();
    const elementParams = {
      data: null,
      layer,
      linkService: __privateGet(this, _linkService),
      downloadManager: params.downloadManager,
      imageResourcesPath: params.imageResourcesPath || "",
      renderForms: params.renderForms !== false,
      svgFactory: new DOMSVGFactory(),
      annotationStorage: __privateGet(this, _annotationStorage2),
      enableComment: params.enableComment === true,
      enableScripting: params.enableScripting === true,
      hasJSActions: params.hasJSActions,
      fieldObjects: params.fieldObjects,
      parent: this,
      elements: null
    };
    for (const data of annotations) {
      if (data.noHTML) {
        continue;
      }
      const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;
      if (!isPopupAnnotation) {
        if (data.rect[2] === data.rect[0] || data.rect[3] === data.rect[1]) {
          continue;
        }
      } else {
        const elements = popupToElements.get(data.id);
        if (!elements) {
          continue;
        }
        elementParams.elements = elements;
      }
      elementParams.data = data;
      const element = AnnotationElementFactory.create(elementParams);
      if (!element.isRenderable) {
        continue;
      }
      if (!isPopupAnnotation && data.popupRef) {
        const elements = popupToElements.get(data.popupRef);
        if (!elements) {
          popupToElements.set(data.popupRef, [element]);
        } else {
          elements.push(element);
        }
      }
      const rendered = element.render();
      if (data.hidden) {
        rendered.style.visibility = "hidden";
      }
      await __privateMethod(this, _appendElement, appendElement_fn).call(this, rendered, data.id, elementParams.elements);
      (_b = (_a2 = element.extraPopupElement) == null ? void 0 : _a2.popup) == null ? void 0 : _b.renderCommentButton();
      if (element._isEditable) {
        __privateGet(this, _editableAnnotations).set(element.data.id, element);
        (_c = this._annotationEditorUIManager) == null ? void 0 : _c.renderAnnotationElement(element);
      }
    }
    __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this);
  }
  async addLinkAnnotations(annotations) {
    const elementParams = {
      data: null,
      layer: this.div,
      linkService: __privateGet(this, _linkService),
      svgFactory: new DOMSVGFactory(),
      parent: this
    };
    for (const data of annotations) {
      data.borderStyle || (data.borderStyle = _AnnotationLayer._defaultBorderStyle);
      elementParams.data = data;
      const element = AnnotationElementFactory.create(elementParams);
      if (!element.isRenderable) {
        continue;
      }
      const rendered = element.render();
      await __privateMethod(this, _appendElement, appendElement_fn).call(this, rendered, data.id, null);
    }
  }
  update({
    viewport
  }) {
    const layer = this.div;
    this.viewport = viewport;
    setLayerDimensions(layer, {
      rotation: viewport.rotation
    });
    __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this);
    layer.hidden = false;
  }
  getEditableAnnotations() {
    return Array.from(__privateGet(this, _editableAnnotations).values());
  }
  getEditableAnnotation(id) {
    return __privateGet(this, _editableAnnotations).get(id);
  }
  addFakeAnnotation(editor) {
    var _a2;
    const {
      div
    } = this;
    const {
      id,
      rotation
    } = editor;
    const element = new EditorAnnotationElement({
      data: {
        id,
        rect: editor.getPDFRect(),
        rotation
      },
      editor,
      layer: div,
      parent: this,
      enableComment: !!this._commentManager,
      linkService: __privateGet(this, _linkService),
      annotationStorage: __privateGet(this, _annotationStorage2)
    });
    const htmlElement = element.render();
    div.append(htmlElement);
    (_a2 = __privateGet(this, _accessibilityManager)) == null ? void 0 : _a2.moveElementInDOM(div, htmlElement, htmlElement, false);
    element.createOrUpdatePopup();
    return element;
  }
  static get _defaultBorderStyle() {
    return shadow(this, "_defaultBorderStyle", Object.freeze({
      width: 1,
      rawWidth: 1,
      style: AnnotationBorderStyleType.SOLID,
      dashArray: [3],
      horizontalCornerRadius: 0,
      verticalCornerRadius: 0
    }));
  }
};
_accessibilityManager = new WeakMap();
_annotationCanvasMap = new WeakMap();
_annotationStorage2 = new WeakMap();
_editableAnnotations = new WeakMap();
_structTreeLayer = new WeakMap();
_linkService = new WeakMap();
_appendElement = new WeakSet();
appendElement_fn = async function(element, id, popupElements) {
  var _a2, _b;
  const contentElement = element.firstChild || element;
  const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;
  const ariaAttributes = await ((_a2 = __privateGet(this, _structTreeLayer)) == null ? void 0 : _a2.getAriaAttributes(annotationId));
  if (ariaAttributes) {
    for (const [key, value] of ariaAttributes) {
      contentElement.setAttribute(key, value);
    }
  }
  if (popupElements) {
    popupElements.at(-1).container.after(element);
  } else {
    this.div.append(element);
    (_b = __privateGet(this, _accessibilityManager)) == null ? void 0 : _b.moveElementInDOM(this.div, element, contentElement, false);
  }
};
_setAnnotationCanvasMap = new WeakSet();
setAnnotationCanvasMap_fn = function() {
  var _a2;
  if (!__privateGet(this, _annotationCanvasMap)) {
    return;
  }
  const layer = this.div;
  for (const [id, canvas] of __privateGet(this, _annotationCanvasMap)) {
    const element = layer.querySelector(`[data-annotation-id="${id}"]`);
    if (!element) {
      continue;
    }
    canvas.className = "annotationContent";
    const {
      firstChild
    } = element;
    if (!firstChild) {
      element.append(canvas);
    } else if (firstChild.nodeName === "CANVAS") {
      firstChild.replaceWith(canvas);
    } else if (!firstChild.classList.contains("annotationContent")) {
      firstChild.before(canvas);
    } else {
      firstChild.after(canvas);
    }
    const editableAnnotation = __privateGet(this, _editableAnnotations).get(id);
    if (!editableAnnotation) {
      continue;
    }
    if (editableAnnotation._hasNoCanvas) {
      (_a2 = this._annotationEditorUIManager) == null ? void 0 : _a2.setMissingCanvas(id, element.id, canvas);
      editableAnnotation._hasNoCanvas = false;
    } else {
      editableAnnotation.canvas = canvas;
    }
  }
  __privateGet(this, _annotationCanvasMap).clear();
};
var AnnotationLayer = _AnnotationLayer;
var EOL_PATTERN = /\r\n?|\n/g;
var _content, _editorDivId, _editModeAC, _fontSize2, _updateFontSize, updateFontSize_fn, _updateColor2, updateColor_fn2, _extractText, extractText_fn, _setEditorDimensions, setEditorDimensions_fn, _getNodeContent, getNodeContent_fn, _setContent, setContent_fn, _serializeContent, serializeContent_fn, _deserializeContent, deserializeContent_fn, _hasElementChanged, hasElementChanged_fn;
var _FreeTextEditor = class _FreeTextEditor extends AnnotationEditor {
  constructor(params) {
    super({
      ...params,
      name: "freeTextEditor"
    });
    __privateAdd(this, _updateFontSize);
    __privateAdd(this, _updateColor2);
    __privateAdd(this, _extractText);
    __privateAdd(this, _setEditorDimensions);
    __privateAdd(this, _setContent);
    __privateAdd(this, _serializeContent);
    __privateAdd(this, _hasElementChanged);
    __privateAdd(this, _content, "");
    __privateAdd(this, _editorDivId, `${this.id}-editor`);
    __privateAdd(this, _editModeAC, null);
    __privateAdd(this, _fontSize2, void 0);
    __publicField(this, "_colorPicker", null);
    this.color = params.color || _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;
    __privateSet(this, _fontSize2, params.fontSize || _FreeTextEditor._defaultFontSize);
    if (!this.annotationElementId) {
      this._uiManager.a11yAlert("pdfjs-editor-freetext-added-alert");
    }
  }
  static get _keyboardManager() {
    const proto = _FreeTextEditor.prototype;
    const arrowChecker = (self) => self.isEmpty();
    const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
    const big = AnnotationEditorUIManager.TRANSLATE_BIG;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], proto.commitOrRemove, {
      bubbles: true
    }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], proto.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], proto._translateEmpty, {
      args: [-small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto._translateEmpty, {
      args: [-big, 0],
      checker: arrowChecker
    }], [["ArrowRight", "mac+ArrowRight"], proto._translateEmpty, {
      args: [small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto._translateEmpty, {
      args: [big, 0],
      checker: arrowChecker
    }], [["ArrowUp", "mac+ArrowUp"], proto._translateEmpty, {
      args: [0, -small],
      checker: arrowChecker
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto._translateEmpty, {
      args: [0, -big],
      checker: arrowChecker
    }], [["ArrowDown", "mac+ArrowDown"], proto._translateEmpty, {
      args: [0, small],
      checker: arrowChecker
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto._translateEmpty, {
      args: [0, big],
      checker: arrowChecker
    }]]));
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
    const style = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
  }
  static updateDefaultParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.FREETEXT_SIZE:
        _FreeTextEditor._defaultFontSize = value;
        break;
      case AnnotationEditorParamsType.FREETEXT_COLOR:
        _FreeTextEditor._defaultColor = value;
        break;
    }
  }
  updateParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.FREETEXT_SIZE:
        __privateMethod(this, _updateFontSize, updateFontSize_fn).call(this, value);
        break;
      case AnnotationEditorParamsType.FREETEXT_COLOR:
        __privateMethod(this, _updateColor2, updateColor_fn2).call(this, value);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[AnnotationEditorParamsType.FREETEXT_SIZE, _FreeTextEditor._defaultFontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor]];
  }
  get propertiesToUpdate() {
    return [[AnnotationEditorParamsType.FREETEXT_SIZE, __privateGet(this, _fontSize2)], [AnnotationEditorParamsType.FREETEXT_COLOR, this.color]];
  }
  get toolbarButtons() {
    this._colorPicker || (this._colorPicker = new BasicColorPicker(this));
    return [["colorPicker", this._colorPicker]];
  }
  get colorType() {
    return AnnotationEditorParamsType.FREETEXT_COLOR;
  }
  onUpdatedColor() {
    var _a2;
    this.editorDiv.style.color = this.color;
    (_a2 = this._colorPicker) == null ? void 0 : _a2.update(this.color);
    super.onUpdatedColor();
  }
  _translateEmpty(x, y) {
    this._uiManager.translateSelectedEditors(x, y, true);
  }
  getInitialTranslation() {
    const scale = this.parentScale;
    return [-_FreeTextEditor._internalPadding * scale, -(_FreeTextEditor._internalPadding + __privateGet(this, _fontSize2)) * scale];
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  enableEditMode() {
    if (!super.enableEditMode()) {
      return false;
    }
    this.overlayDiv.classList.remove("enabled");
    this.editorDiv.contentEditable = true;
    this._isDraggable = false;
    this.div.removeAttribute("aria-activedescendant");
    __privateSet(this, _editModeAC, new AbortController());
    const signal = this._uiManager.combinedSignal(__privateGet(this, _editModeAC));
    this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), {
      signal
    });
    this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), {
      signal
    });
    this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), {
      signal
    });
    this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), {
      signal
    });
    this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), {
      signal
    });
    return true;
  }
  disableEditMode() {
    var _a2;
    if (!super.disableEditMode()) {
      return false;
    }
    this.overlayDiv.classList.add("enabled");
    this.editorDiv.contentEditable = false;
    this.div.setAttribute("aria-activedescendant", __privateGet(this, _editorDivId));
    this._isDraggable = true;
    (_a2 = __privateGet(this, _editModeAC)) == null ? void 0 : _a2.abort();
    __privateSet(this, _editModeAC, null);
    this.div.focus({
      preventScroll: true
    });
    this.isEditing = false;
    this.parent.div.classList.add("freetextEditing");
    return true;
  }
  focusin(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    super.focusin(event);
    if (event.target !== this.editorDiv) {
      this.editorDiv.focus();
    }
  }
  onceAdded(focus) {
    var _a2;
    if (this.width) {
      return;
    }
    this.enableEditMode();
    if (focus) {
      this.editorDiv.focus();
    }
    if ((_a2 = this._initialOptions) == null ? void 0 : _a2.isCentered) {
      this.center();
    }
    this._initialOptions = null;
  }
  isEmpty() {
    return !this.editorDiv || this.editorDiv.innerText.trim() === "";
  }
  remove() {
    this.isEditing = false;
    if (this.parent) {
      this.parent.setEditingState(true);
      this.parent.div.classList.add("freetextEditing");
    }
    super.remove();
  }
  commit() {
    if (!this.isInEditMode()) {
      return;
    }
    super.commit();
    this.disableEditMode();
    const savedText = __privateGet(this, _content);
    const newText = __privateSet(this, _content, __privateMethod(this, _extractText, extractText_fn).call(this).trimEnd());
    if (savedText === newText) {
      return;
    }
    const setText = (text) => {
      __privateSet(this, _content, text);
      if (!text) {
        this.remove();
        return;
      }
      __privateMethod(this, _setContent, setContent_fn).call(this);
      this._uiManager.rebuild(this);
      __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
    };
    this.addCommands({
      cmd: () => {
        setText(newText);
      },
      undo: () => {
        setText(savedText);
      },
      mustExec: false
    });
    __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
  }
  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }
  enterInEditMode() {
    this.enableEditMode();
    this.editorDiv.focus();
  }
  keydown(event) {
    if (event.target === this.div && event.key === "Enter") {
      this.enterInEditMode();
      event.preventDefault();
    }
  }
  editorDivKeydown(event) {
    _FreeTextEditor._keyboardManager.exec(this, event);
  }
  editorDivFocus(event) {
    this.isEditing = true;
  }
  editorDivBlur(event) {
    this.isEditing = false;
  }
  editorDivInput(event) {
    this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
  }
  disableEditing() {
    this.editorDiv.setAttribute("role", "comment");
    this.editorDiv.removeAttribute("aria-multiline");
  }
  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox");
    this.editorDiv.setAttribute("aria-multiline", true);
  }
  get canChangeContent() {
    return true;
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this._isCopy || this.annotationElementId) {
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    this.editorDiv = document.createElement("div");
    this.editorDiv.className = "internal";
    this.editorDiv.setAttribute("id", __privateGet(this, _editorDivId));
    this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text2");
    this.editorDiv.setAttribute("data-l10n-attrs", "default-content");
    this.enableEditing();
    this.editorDiv.contentEditable = true;
    const {
      style
    } = this.editorDiv;
    style.fontSize = `calc(${__privateGet(this, _fontSize2)}px * var(--total-scale-factor))`;
    style.color = this.color;
    this.div.append(this.editorDiv);
    this.overlayDiv = document.createElement("div");
    this.overlayDiv.classList.add("overlay", "enabled");
    this.div.append(this.overlayDiv);
    if (this._isCopy || this.annotationElementId) {
      const [parentWidth, parentHeight] = this.parentDimensions;
      if (this.annotationElementId) {
        const {
          position
        } = this._initialData;
        let [tx, ty] = this.getInitialTranslation();
        [tx, ty] = this.pageTranslationToScreen(tx, ty);
        const [pageWidth, pageHeight] = this.pageDimensions;
        const [pageX, pageY] = this.pageTranslation;
        let posX, posY;
        switch (this.rotation) {
          case 0:
            posX = baseX + (position[0] - pageX) / pageWidth;
            posY = baseY + this.height - (position[1] - pageY) / pageHeight;
            break;
          case 90:
            posX = baseX + (position[0] - pageX) / pageWidth;
            posY = baseY - (position[1] - pageY) / pageHeight;
            [tx, ty] = [ty, -tx];
            break;
          case 180:
            posX = baseX - this.width + (position[0] - pageX) / pageWidth;
            posY = baseY - (position[1] - pageY) / pageHeight;
            [tx, ty] = [-tx, -ty];
            break;
          case 270:
            posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;
            posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;
            [tx, ty] = [-ty, tx];
            break;
        }
        this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);
      } else {
        this._moveAfterPaste(baseX, baseY);
      }
      __privateMethod(this, _setContent, setContent_fn).call(this);
      this._isDraggable = true;
      this.editorDiv.contentEditable = false;
    } else {
      this._isDraggable = false;
      this.editorDiv.contentEditable = true;
    }
    return this.div;
  }
  editorDivPaste(event) {
    var _a2, _b, _c;
    const clipboardData = event.clipboardData || window.clipboardData;
    const {
      types
    } = clipboardData;
    if (types.length === 1 && types[0] === "text/plain") {
      return;
    }
    event.preventDefault();
    const paste = __privateMethod(_a2 = _FreeTextEditor, _deserializeContent, deserializeContent_fn).call(_a2, clipboardData.getData("text") || "").replaceAll(EOL_PATTERN, "\n");
    if (!paste) {
      return;
    }
    const selection = window.getSelection();
    if (!selection.rangeCount) {
      return;
    }
    this.editorDiv.normalize();
    selection.deleteFromDocument();
    const range = selection.getRangeAt(0);
    if (!paste.includes("\n")) {
      range.insertNode(document.createTextNode(paste));
      this.editorDiv.normalize();
      selection.collapseToStart();
      return;
    }
    const {
      startContainer,
      startOffset
    } = range;
    const bufferBefore = [];
    const bufferAfter = [];
    if (startContainer.nodeType === Node.TEXT_NODE) {
      const parent = startContainer.parentElement;
      bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, ""));
      if (parent !== this.editorDiv) {
        let buffer = bufferBefore;
        for (const child of this.editorDiv.childNodes) {
          if (child === parent) {
            buffer = bufferAfter;
            continue;
          }
          buffer.push(__privateMethod(_b = _FreeTextEditor, _getNodeContent, getNodeContent_fn).call(_b, child));
        }
      }
      bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, ""));
    } else if (startContainer === this.editorDiv) {
      let buffer = bufferBefore;
      let i = 0;
      for (const child of this.editorDiv.childNodes) {
        if (i++ === startOffset) {
          buffer = bufferAfter;
        }
        buffer.push(__privateMethod(_c = _FreeTextEditor, _getNodeContent, getNodeContent_fn).call(_c, child));
      }
    }
    __privateSet(this, _content, `${bufferBefore.join("\n")}${paste}${bufferAfter.join("\n")}`);
    __privateMethod(this, _setContent, setContent_fn).call(this);
    const newRange = new Range();
    let beforeLength = Math.sumPrecise(bufferBefore.map((line) => line.length));
    for (const {
      firstChild
    } of this.editorDiv.childNodes) {
      if (firstChild.nodeType === Node.TEXT_NODE) {
        const length = firstChild.nodeValue.length;
        if (beforeLength <= length) {
          newRange.setStart(firstChild, beforeLength);
          newRange.setEnd(firstChild, beforeLength);
          break;
        }
        beforeLength -= length;
      }
    }
    selection.removeAllRanges();
    selection.addRange(newRange);
  }
  get contentDiv() {
    return this.editorDiv;
  }
  getPDFRect() {
    const padding = _FreeTextEditor._internalPadding * this.parentScale;
    return this.getRect(padding, padding);
  }
  static async deserialize(data, parent, uiManager) {
    var _a2;
    let initialData = null;
    if (data instanceof FreeTextAnnotationElement) {
      const {
        data: {
          defaultAppearanceData: {
            fontSize,
            fontColor
          },
          rect,
          rotation,
          id,
          popupRef,
          richText,
          contentsObj,
          creationDate,
          modificationDate
        },
        textContent,
        textPosition,
        parent: {
          page: {
            pageNumber
          }
        }
      } = data;
      if (!textContent || textContent.length === 0) {
        return null;
      }
      initialData = data = {
        annotationType: AnnotationEditorType.FREETEXT,
        color: Array.from(fontColor),
        fontSize,
        value: textContent.join("\n"),
        position: textPosition,
        pageIndex: pageNumber - 1,
        rect: rect.slice(0),
        rotation,
        annotationElementId: id,
        id,
        deleted: false,
        popupRef,
        comment: (contentsObj == null ? void 0 : contentsObj.str) || null,
        richText,
        creationDate,
        modificationDate
      };
    }
    const editor = await super.deserialize(data, parent, uiManager);
    __privateSet(editor, _fontSize2, data.fontSize);
    editor.color = Util.makeHexColor(...data.color);
    __privateSet(editor, _content, __privateMethod(_a2 = _FreeTextEditor, _deserializeContent, deserializeContent_fn).call(_a2, data.value));
    editor._initialData = initialData;
    if (data.comment) {
      editor.setCommentData(data);
    }
    return editor;
  }
  serialize(isForCopying = false) {
    if (this.isEmpty()) {
      return null;
    }
    if (this.deleted) {
      return this.serializeDeleted();
    }
    const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.color);
    const serialized = Object.assign(super.serialize(isForCopying), {
      color,
      fontSize: __privateGet(this, _fontSize2),
      value: __privateMethod(this, _serializeContent, serializeContent_fn).call(this)
    });
    this.addComment(serialized);
    if (isForCopying) {
      serialized.isCopy = true;
      return serialized;
    }
    if (this.annotationElementId && !__privateMethod(this, _hasElementChanged, hasElementChanged_fn).call(this, serialized)) {
      return null;
    }
    serialized.id = this.annotationElementId;
    return serialized;
  }
  renderAnnotationElement(annotation) {
    const content = super.renderAnnotationElement(annotation);
    if (!content) {
      return null;
    }
    const {
      style
    } = content;
    style.fontSize = `calc(${__privateGet(this, _fontSize2)}px * var(--total-scale-factor))`;
    style.color = this.color;
    content.replaceChildren();
    for (const line of __privateGet(this, _content).split("\n")) {
      const div = document.createElement("div");
      div.append(line ? document.createTextNode(line) : document.createElement("br"));
      content.append(div);
    }
    annotation.updateEdited({
      rect: this.getPDFRect(),
      popup: this._uiManager.hasCommentManager() || this.hasEditedComment ? this.comment : {
        text: __privateGet(this, _content)
      }
    });
    return content;
  }
  resetAnnotationElement(annotation) {
    super.resetAnnotationElement(annotation);
    annotation.resetEdited();
  }
};
_content = new WeakMap();
_editorDivId = new WeakMap();
_editModeAC = new WeakMap();
_fontSize2 = new WeakMap();
_updateFontSize = new WeakSet();
updateFontSize_fn = function(fontSize) {
  const setFontsize = (size) => {
    this.editorDiv.style.fontSize = `calc(${size}px * var(--total-scale-factor))`;
    this.translate(0, -(size - __privateGet(this, _fontSize2)) * this.parentScale);
    __privateSet(this, _fontSize2, size);
    __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
  };
  const savedFontsize = __privateGet(this, _fontSize2);
  this.addCommands({
    cmd: setFontsize.bind(this, fontSize),
    undo: setFontsize.bind(this, savedFontsize),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: true,
    type: AnnotationEditorParamsType.FREETEXT_SIZE,
    overwriteIfSameType: true,
    keepUndo: true
  });
};
_updateColor2 = new WeakSet();
updateColor_fn2 = function(color) {
  const setColor = (col) => {
    this.color = col;
    this.onUpdatedColor();
  };
  const savedColor = this.color;
  this.addCommands({
    cmd: setColor.bind(this, color),
    undo: setColor.bind(this, savedColor),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: true,
    type: AnnotationEditorParamsType.FREETEXT_COLOR,
    overwriteIfSameType: true,
    keepUndo: true
  });
};
_extractText = new WeakSet();
extractText_fn = function() {
  var _a2;
  const buffer = [];
  this.editorDiv.normalize();
  let prevChild = null;
  for (const child of this.editorDiv.childNodes) {
    if ((prevChild == null ? void 0 : prevChild.nodeType) === Node.TEXT_NODE && child.nodeName === "BR") {
      continue;
    }
    buffer.push(__privateMethod(_a2 = _FreeTextEditor, _getNodeContent, getNodeContent_fn).call(_a2, child));
    prevChild = child;
  }
  return buffer.join("\n");
};
_setEditorDimensions = new WeakSet();
setEditorDimensions_fn = function() {
  const [parentWidth, parentHeight] = this.parentDimensions;
  let rect;
  if (this.isAttachedToDOM) {
    rect = this.div.getBoundingClientRect();
  } else {
    const {
      currentLayer,
      div
    } = this;
    const savedDisplay = div.style.display;
    const savedVisibility = div.classList.contains("hidden");
    div.classList.remove("hidden");
    div.style.display = "hidden";
    currentLayer.div.append(this.div);
    rect = div.getBoundingClientRect();
    div.remove();
    div.style.display = savedDisplay;
    div.classList.toggle("hidden", savedVisibility);
  }
  if (this.rotation % 180 === this.parentRotation % 180) {
    this.width = rect.width / parentWidth;
    this.height = rect.height / parentHeight;
  } else {
    this.width = rect.height / parentWidth;
    this.height = rect.width / parentHeight;
  }
  this.fixAndSetPosition();
};
_getNodeContent = new WeakSet();
getNodeContent_fn = function(node) {
  return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, "");
};
_setContent = new WeakSet();
setContent_fn = function() {
  this.editorDiv.replaceChildren();
  if (!__privateGet(this, _content)) {
    return;
  }
  for (const line of __privateGet(this, _content).split("\n")) {
    const div = document.createElement("div");
    div.append(line ? document.createTextNode(line) : document.createElement("br"));
    this.editorDiv.append(div);
  }
};
_serializeContent = new WeakSet();
serializeContent_fn = function() {
  return __privateGet(this, _content).replaceAll(" ", " ");
};
_deserializeContent = new WeakSet();
deserializeContent_fn = function(content) {
  return content.replaceAll(" ", " ");
};
_hasElementChanged = new WeakSet();
hasElementChanged_fn = function(serialized) {
  const {
    value,
    fontSize,
    color,
    pageIndex
  } = this._initialData;
  return this.hasEditedComment || this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i) => c !== color[i]) || serialized.pageIndex !== pageIndex;
};
__privateAdd(_FreeTextEditor, _getNodeContent);
__privateAdd(_FreeTextEditor, _deserializeContent);
__publicField(_FreeTextEditor, "_freeTextDefaultContent", "");
__publicField(_FreeTextEditor, "_internalPadding", 0);
__publicField(_FreeTextEditor, "_defaultColor", null);
__publicField(_FreeTextEditor, "_defaultFontSize", 10);
__publicField(_FreeTextEditor, "_type", "freetext");
__publicField(_FreeTextEditor, "_editorType", AnnotationEditorType.FREETEXT);
var FreeTextEditor = _FreeTextEditor;
var Outline = class {
  toSVGPath() {
    unreachable("Abstract method `toSVGPath` must be implemented.");
  }
  get box() {
    unreachable("Abstract getter `box` must be implemented.");
  }
  serialize(_bbox3, _rotation4) {
    unreachable("Abstract method `serialize` must be implemented.");
  }
  static _rescale(src, tx, ty, sx, sy, dest) {
    dest || (dest = new Float32Array(src.length));
    for (let i = 0, ii = src.length; i < ii; i += 2) {
      dest[i] = tx + src[i] * sx;
      dest[i + 1] = ty + src[i + 1] * sy;
    }
    return dest;
  }
  static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {
    dest || (dest = new Float32Array(src.length));
    for (let i = 0, ii = src.length; i < ii; i += 2) {
      dest[i] = tx + src[i + 1] * sx;
      dest[i + 1] = ty + src[i] * sy;
    }
    return dest;
  }
  static _translate(src, tx, ty, dest) {
    dest || (dest = new Float32Array(src.length));
    for (let i = 0, ii = src.length; i < ii; i += 2) {
      dest[i] = tx + src[i];
      dest[i + 1] = ty + src[i + 1];
    }
    return dest;
  }
  static svgRound(x) {
    return Math.round(x * 1e4);
  }
  static _normalizePoint(x, y, parentWidth, parentHeight, rotation) {
    switch (rotation) {
      case 90:
        return [1 - y / parentWidth, x / parentHeight];
      case 180:
        return [1 - x / parentWidth, 1 - y / parentHeight];
      case 270:
        return [y / parentWidth, 1 - x / parentHeight];
      default:
        return [x / parentWidth, y / parentHeight];
    }
  }
  static _normalizePagePoint(x, y, rotation) {
    switch (rotation) {
      case 90:
        return [1 - y, x];
      case 180:
        return [1 - x, 1 - y];
      case 270:
        return [y, 1 - x];
      default:
        return [x, y];
    }
  }
  static createBezierPoints(x1, y1, x2, y2, x3, y3) {
    return [(x1 + 5 * x2) / 6, (y1 + 5 * y2) / 6, (5 * x2 + x3) / 6, (5 * y2 + y3) / 6, (x2 + x3) / 2, (y2 + y3) / 2];
  }
};
__publicField(Outline, "PRECISION", 1e-4);
var _box, _bottom, _innerMargin, _isLTR, _top, _last, _lastX, _lastY, _min, _min_dist, _scaleFactor, _thickness, _points, _MIN_DIST, _MIN_DIFF, _MIN, _getLastCoords, getLastCoords_fn, _toSVGPathTwoPoints, toSVGPathTwoPoints_fn, _toSVGPathStart, toSVGPathStart_fn, _toSVGPathEnd, toSVGPathEnd_fn, _getOutlineTwoPoints, getOutlineTwoPoints_fn, _getOutlineStart, getOutlineStart_fn, _getOutlineEnd, getOutlineEnd_fn;
var _FreeDrawOutliner = class _FreeDrawOutliner {
  constructor({
    x,
    y
  }, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
    __privateAdd(this, _getLastCoords);
    __privateAdd(this, _toSVGPathTwoPoints);
    __privateAdd(this, _toSVGPathStart);
    __privateAdd(this, _toSVGPathEnd);
    __privateAdd(this, _getOutlineTwoPoints);
    __privateAdd(this, _getOutlineStart);
    __privateAdd(this, _getOutlineEnd);
    __privateAdd(this, _box, void 0);
    __privateAdd(this, _bottom, []);
    __privateAdd(this, _innerMargin, void 0);
    __privateAdd(this, _isLTR, void 0);
    __privateAdd(this, _top, []);
    __privateAdd(this, _last, new Float32Array(18));
    __privateAdd(this, _lastX, void 0);
    __privateAdd(this, _lastY, void 0);
    __privateAdd(this, _min, void 0);
    __privateAdd(this, _min_dist, void 0);
    __privateAdd(this, _scaleFactor, void 0);
    __privateAdd(this, _thickness, void 0);
    __privateAdd(this, _points, []);
    __privateSet(this, _box, box);
    __privateSet(this, _thickness, thickness * scaleFactor);
    __privateSet(this, _isLTR, isLTR);
    __privateGet(this, _last).set([NaN, NaN, NaN, NaN, x, y], 6);
    __privateSet(this, _innerMargin, innerMargin);
    __privateSet(this, _min_dist, __privateGet(_FreeDrawOutliner, _MIN_DIST) * scaleFactor);
    __privateSet(this, _min, __privateGet(_FreeDrawOutliner, _MIN) * scaleFactor);
    __privateSet(this, _scaleFactor, scaleFactor);
    __privateGet(this, _points).push(x, y);
  }
  isEmpty() {
    return isNaN(__privateGet(this, _last)[8]);
  }
  add({
    x,
    y
  }) {
    var _a2;
    __privateSet(this, _lastX, x);
    __privateSet(this, _lastY, y);
    const [layerX, layerY, layerWidth, layerHeight] = __privateGet(this, _box);
    let [x1, y1, x2, y2] = __privateGet(this, _last).subarray(8, 12);
    const diffX = x - x2;
    const diffY = y - y2;
    const d = Math.hypot(diffX, diffY);
    if (d < __privateGet(this, _min)) {
      return false;
    }
    const diffD = d - __privateGet(this, _min_dist);
    const K = diffD / d;
    const shiftX = K * diffX;
    const shiftY = K * diffY;
    let x0 = x1;
    let y0 = y1;
    x1 = x2;
    y1 = y2;
    x2 += shiftX;
    y2 += shiftY;
    (_a2 = __privateGet(this, _points)) == null ? void 0 : _a2.push(x, y);
    const nX = -shiftY / diffD;
    const nY = shiftX / diffD;
    const thX = nX * __privateGet(this, _thickness);
    const thY = nY * __privateGet(this, _thickness);
    __privateGet(this, _last).set(__privateGet(this, _last).subarray(2, 8), 0);
    __privateGet(this, _last).set([x2 + thX, y2 + thY], 4);
    __privateGet(this, _last).set(__privateGet(this, _last).subarray(14, 18), 12);
    __privateGet(this, _last).set([x2 - thX, y2 - thY], 16);
    if (isNaN(__privateGet(this, _last)[6])) {
      if (__privateGet(this, _top).length === 0) {
        __privateGet(this, _last).set([x1 + thX, y1 + thY], 2);
        __privateGet(this, _top).push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);
        __privateGet(this, _last).set([x1 - thX, y1 - thY], 14);
        __privateGet(this, _bottom).push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);
      }
      __privateGet(this, _last).set([x0, y0, x1, y1, x2, y2], 6);
      return !this.isEmpty();
    }
    __privateGet(this, _last).set([x0, y0, x1, y1, x2, y2], 6);
    const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));
    if (angle < Math.PI / 2) {
      [x1, y1, x2, y2] = __privateGet(this, _last).subarray(2, 6);
      __privateGet(this, _top).push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
      [x1, y1, x0, y0] = __privateGet(this, _last).subarray(14, 18);
      __privateGet(this, _bottom).push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);
      return true;
    }
    [x0, y0, x1, y1, x2, y2] = __privateGet(this, _last).subarray(0, 6);
    __privateGet(this, _top).push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
    [x2, y2, x1, y1, x0, y0] = __privateGet(this, _last).subarray(12, 18);
    __privateGet(this, _bottom).push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
    return true;
  }
  toSVGPath() {
    if (this.isEmpty()) {
      return "";
    }
    const top = __privateGet(this, _top);
    const bottom = __privateGet(this, _bottom);
    if (isNaN(__privateGet(this, _last)[6]) && !this.isEmpty()) {
      return __privateMethod(this, _toSVGPathTwoPoints, toSVGPathTwoPoints_fn).call(this);
    }
    const buffer = [];
    buffer.push(`M${top[4]} ${top[5]}`);
    for (let i = 6; i < top.length; i += 6) {
      if (isNaN(top[i])) {
        buffer.push(`L${top[i + 4]} ${top[i + 5]}`);
      } else {
        buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);
      }
    }
    __privateMethod(this, _toSVGPathEnd, toSVGPathEnd_fn).call(this, buffer);
    for (let i = bottom.length - 6; i >= 6; i -= 6) {
      if (isNaN(bottom[i])) {
        buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);
      } else {
        buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);
      }
    }
    __privateMethod(this, _toSVGPathStart, toSVGPathStart_fn).call(this, buffer);
    return buffer.join(" ");
  }
  newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {
    return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);
  }
  getOutlines() {
    var _a2;
    const top = __privateGet(this, _top);
    const bottom = __privateGet(this, _bottom);
    const last = __privateGet(this, _last);
    const [layerX, layerY, layerWidth, layerHeight] = __privateGet(this, _box);
    const points = new Float32Array((((_a2 = __privateGet(this, _points)) == null ? void 0 : _a2.length) ?? 0) + 2);
    for (let i = 0, ii = points.length - 2; i < ii; i += 2) {
      points[i] = (__privateGet(this, _points)[i] - layerX) / layerWidth;
      points[i + 1] = (__privateGet(this, _points)[i + 1] - layerY) / layerHeight;
    }
    points[points.length - 2] = (__privateGet(this, _lastX) - layerX) / layerWidth;
    points[points.length - 1] = (__privateGet(this, _lastY) - layerY) / layerHeight;
    if (isNaN(last[6]) && !this.isEmpty()) {
      return __privateMethod(this, _getOutlineTwoPoints, getOutlineTwoPoints_fn).call(this, points);
    }
    const outline = new Float32Array(__privateGet(this, _top).length + 24 + __privateGet(this, _bottom).length);
    let N = top.length;
    for (let i = 0; i < N; i += 2) {
      if (isNaN(top[i])) {
        outline[i] = outline[i + 1] = NaN;
        continue;
      }
      outline[i] = top[i];
      outline[i + 1] = top[i + 1];
    }
    N = __privateMethod(this, _getOutlineEnd, getOutlineEnd_fn).call(this, outline, N);
    for (let i = bottom.length - 6; i >= 6; i -= 6) {
      for (let j = 0; j < 6; j += 2) {
        if (isNaN(bottom[i + j])) {
          outline[N] = outline[N + 1] = NaN;
          N += 2;
          continue;
        }
        outline[N] = bottom[i + j];
        outline[N + 1] = bottom[i + j + 1];
        N += 2;
      }
    }
    __privateMethod(this, _getOutlineStart, getOutlineStart_fn).call(this, outline, N);
    return this.newFreeDrawOutline(outline, points, __privateGet(this, _box), __privateGet(this, _scaleFactor), __privateGet(this, _innerMargin), __privateGet(this, _isLTR));
  }
};
_box = new WeakMap();
_bottom = new WeakMap();
_innerMargin = new WeakMap();
_isLTR = new WeakMap();
_top = new WeakMap();
_last = new WeakMap();
_lastX = new WeakMap();
_lastY = new WeakMap();
_min = new WeakMap();
_min_dist = new WeakMap();
_scaleFactor = new WeakMap();
_thickness = new WeakMap();
_points = new WeakMap();
_MIN_DIST = new WeakMap();
_MIN_DIFF = new WeakMap();
_MIN = new WeakMap();
_getLastCoords = new WeakSet();
getLastCoords_fn = function() {
  const lastTop = __privateGet(this, _last).subarray(4, 6);
  const lastBottom = __privateGet(this, _last).subarray(16, 18);
  const [x, y, width, height] = __privateGet(this, _box);
  return [(__privateGet(this, _lastX) + (lastTop[0] - lastBottom[0]) / 2 - x) / width, (__privateGet(this, _lastY) + (lastTop[1] - lastBottom[1]) / 2 - y) / height, (__privateGet(this, _lastX) + (lastBottom[0] - lastTop[0]) / 2 - x) / width, (__privateGet(this, _lastY) + (lastBottom[1] - lastTop[1]) / 2 - y) / height];
};
_toSVGPathTwoPoints = new WeakSet();
toSVGPathTwoPoints_fn = function() {
  const [x, y, width, height] = __privateGet(this, _box);
  const [lastTopX, lastTopY, lastBottomX, lastBottomY] = __privateMethod(this, _getLastCoords, getLastCoords_fn).call(this);
  return `M${(__privateGet(this, _last)[2] - x) / width} ${(__privateGet(this, _last)[3] - y) / height} L${(__privateGet(this, _last)[4] - x) / width} ${(__privateGet(this, _last)[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(__privateGet(this, _last)[16] - x) / width} ${(__privateGet(this, _last)[17] - y) / height} L${(__privateGet(this, _last)[14] - x) / width} ${(__privateGet(this, _last)[15] - y) / height} Z`;
};
_toSVGPathStart = new WeakSet();
toSVGPathStart_fn = function(buffer) {
  const bottom = __privateGet(this, _bottom);
  buffer.push(`L${bottom[4]} ${bottom[5]} Z`);
};
_toSVGPathEnd = new WeakSet();
toSVGPathEnd_fn = function(buffer) {
  const [x, y, width, height] = __privateGet(this, _box);
  const lastTop = __privateGet(this, _last).subarray(4, 6);
  const lastBottom = __privateGet(this, _last).subarray(16, 18);
  const [lastTopX, lastTopY, lastBottomX, lastBottomY] = __privateMethod(this, _getLastCoords, getLastCoords_fn).call(this);
  buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);
};
_getOutlineTwoPoints = new WeakSet();
getOutlineTwoPoints_fn = function(points) {
  const last = __privateGet(this, _last);
  const [layerX, layerY, layerWidth, layerHeight] = __privateGet(this, _box);
  const [lastTopX, lastTopY, lastBottomX, lastBottomY] = __privateMethod(this, _getLastCoords, getLastCoords_fn).call(this);
  const outline = new Float32Array(36);
  outline.set([NaN, NaN, NaN, NaN, (last[2] - layerX) / layerWidth, (last[3] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[4] - layerX) / layerWidth, (last[5] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (last[16] - layerX) / layerWidth, (last[17] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[14] - layerX) / layerWidth, (last[15] - layerY) / layerHeight], 0);
  return this.newFreeDrawOutline(outline, points, __privateGet(this, _box), __privateGet(this, _scaleFactor), __privateGet(this, _innerMargin), __privateGet(this, _isLTR));
};
_getOutlineStart = new WeakSet();
getOutlineStart_fn = function(outline, pos) {
  const bottom = __privateGet(this, _bottom);
  outline.set([NaN, NaN, NaN, NaN, bottom[4], bottom[5]], pos);
  return pos += 6;
};
_getOutlineEnd = new WeakSet();
getOutlineEnd_fn = function(outline, pos) {
  const lastTop = __privateGet(this, _last).subarray(4, 6);
  const lastBottom = __privateGet(this, _last).subarray(16, 18);
  const [layerX, layerY, layerWidth, layerHeight] = __privateGet(this, _box);
  const [lastTopX, lastTopY, lastBottomX, lastBottomY] = __privateMethod(this, _getLastCoords, getLastCoords_fn).call(this);
  outline.set([NaN, NaN, NaN, NaN, (lastTop[0] - layerX) / layerWidth, (lastTop[1] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (lastBottom[0] - layerX) / layerWidth, (lastBottom[1] - layerY) / layerHeight], pos);
  return pos += 24;
};
__privateAdd(_FreeDrawOutliner, _MIN_DIST, 8);
__privateAdd(_FreeDrawOutliner, _MIN_DIFF, 2);
__privateAdd(_FreeDrawOutliner, _MIN, __privateGet(_FreeDrawOutliner, _MIN_DIST) + __privateGet(_FreeDrawOutliner, _MIN_DIFF));
var FreeDrawOutliner = _FreeDrawOutliner;
var _box2, _bbox, _innerMargin2, _isLTR2, _points2, _scaleFactor2, _outline, _computeMinMax, computeMinMax_fn;
var FreeDrawOutline = class extends Outline {
  constructor(outline, points, box, scaleFactor, innerMargin, isLTR) {
    super();
    __privateAdd(this, _computeMinMax);
    __privateAdd(this, _box2, void 0);
    __privateAdd(this, _bbox, new Float32Array(4));
    __privateAdd(this, _innerMargin2, void 0);
    __privateAdd(this, _isLTR2, void 0);
    __privateAdd(this, _points2, void 0);
    __privateAdd(this, _scaleFactor2, void 0);
    __privateAdd(this, _outline, void 0);
    __privateSet(this, _outline, outline);
    __privateSet(this, _points2, points);
    __privateSet(this, _box2, box);
    __privateSet(this, _scaleFactor2, scaleFactor);
    __privateSet(this, _innerMargin2, innerMargin);
    __privateSet(this, _isLTR2, isLTR);
    this.firstPoint = [NaN, NaN];
    this.lastPoint = [NaN, NaN];
    __privateMethod(this, _computeMinMax, computeMinMax_fn).call(this, isLTR);
    const [x, y, width, height] = __privateGet(this, _bbox);
    for (let i = 0, ii = outline.length; i < ii; i += 2) {
      outline[i] = (outline[i] - x) / width;
      outline[i + 1] = (outline[i + 1] - y) / height;
    }
    for (let i = 0, ii = points.length; i < ii; i += 2) {
      points[i] = (points[i] - x) / width;
      points[i + 1] = (points[i + 1] - y) / height;
    }
  }
  toSVGPath() {
    const buffer = [`M${__privateGet(this, _outline)[4]} ${__privateGet(this, _outline)[5]}`];
    for (let i = 6, ii = __privateGet(this, _outline).length; i < ii; i += 6) {
      if (isNaN(__privateGet(this, _outline)[i])) {
        buffer.push(`L${__privateGet(this, _outline)[i + 4]} ${__privateGet(this, _outline)[i + 5]}`);
        continue;
      }
      buffer.push(`C${__privateGet(this, _outline)[i]} ${__privateGet(this, _outline)[i + 1]} ${__privateGet(this, _outline)[i + 2]} ${__privateGet(this, _outline)[i + 3]} ${__privateGet(this, _outline)[i + 4]} ${__privateGet(this, _outline)[i + 5]}`);
    }
    buffer.push("Z");
    return buffer.join(" ");
  }
  serialize([blX, blY, trX, trY], rotation) {
    const width = trX - blX;
    const height = trY - blY;
    let outline;
    let points;
    switch (rotation) {
      case 0:
        outline = Outline._rescale(__privateGet(this, _outline), blX, trY, width, -height);
        points = Outline._rescale(__privateGet(this, _points2), blX, trY, width, -height);
        break;
      case 90:
        outline = Outline._rescaleAndSwap(__privateGet(this, _outline), blX, blY, width, height);
        points = Outline._rescaleAndSwap(__privateGet(this, _points2), blX, blY, width, height);
        break;
      case 180:
        outline = Outline._rescale(__privateGet(this, _outline), trX, blY, -width, height);
        points = Outline._rescale(__privateGet(this, _points2), trX, blY, -width, height);
        break;
      case 270:
        outline = Outline._rescaleAndSwap(__privateGet(this, _outline), trX, trY, -width, -height);
        points = Outline._rescaleAndSwap(__privateGet(this, _points2), trX, trY, -width, -height);
        break;
    }
    return {
      outline: Array.from(outline),
      points: [Array.from(points)]
    };
  }
  get box() {
    return __privateGet(this, _bbox);
  }
  newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
    return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);
  }
  getNewOutline(thickness, innerMargin) {
    const [x, y, width, height] = __privateGet(this, _bbox);
    const [layerX, layerY, layerWidth, layerHeight] = __privateGet(this, _box2);
    const sx = width * layerWidth;
    const sy = height * layerHeight;
    const tx = x * layerWidth + layerX;
    const ty = y * layerHeight + layerY;
    const outliner = this.newOutliner({
      x: __privateGet(this, _points2)[0] * sx + tx,
      y: __privateGet(this, _points2)[1] * sy + ty
    }, __privateGet(this, _box2), __privateGet(this, _scaleFactor2), thickness, __privateGet(this, _isLTR2), innerMargin ?? __privateGet(this, _innerMargin2));
    for (let i = 2; i < __privateGet(this, _points2).length; i += 2) {
      outliner.add({
        x: __privateGet(this, _points2)[i] * sx + tx,
        y: __privateGet(this, _points2)[i + 1] * sy + ty
      });
    }
    return outliner.getOutlines();
  }
};
_box2 = new WeakMap();
_bbox = new WeakMap();
_innerMargin2 = new WeakMap();
_isLTR2 = new WeakMap();
_points2 = new WeakMap();
_scaleFactor2 = new WeakMap();
_outline = new WeakMap();
_computeMinMax = new WeakSet();
computeMinMax_fn = function(isLTR) {
  const outline = __privateGet(this, _outline);
  let lastX = outline[4];
  let lastY = outline[5];
  const minMax = [lastX, lastY, lastX, lastY];
  let firstPointX = lastX;
  let firstPointY = lastY;
  let lastPointX = lastX;
  let lastPointY = lastY;
  const ltrCallback = isLTR ? Math.max : Math.min;
  const bezierBbox = new Float32Array(4);
  for (let i = 6, ii = outline.length; i < ii; i += 6) {
    const x = outline[i + 4], y = outline[i + 5];
    if (isNaN(outline[i])) {
      Util.pointBoundingBox(x, y, minMax);
      if (firstPointY > y) {
        firstPointX = x;
        firstPointY = y;
      } else if (firstPointY === y) {
        firstPointX = ltrCallback(firstPointX, x);
      }
      if (lastPointY < y) {
        lastPointX = x;
        lastPointY = y;
      } else if (lastPointY === y) {
        lastPointX = ltrCallback(lastPointX, x);
      }
    } else {
      bezierBbox[0] = bezierBbox[1] = Infinity;
      bezierBbox[2] = bezierBbox[3] = -Infinity;
      Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6), bezierBbox);
      Util.rectBoundingBox(bezierBbox[0], bezierBbox[1], bezierBbox[2], bezierBbox[3], minMax);
      if (firstPointY > bezierBbox[1]) {
        firstPointX = bezierBbox[0];
        firstPointY = bezierBbox[1];
      } else if (firstPointY === bezierBbox[1]) {
        firstPointX = ltrCallback(firstPointX, bezierBbox[0]);
      }
      if (lastPointY < bezierBbox[3]) {
        lastPointX = bezierBbox[2];
        lastPointY = bezierBbox[3];
      } else if (lastPointY === bezierBbox[3]) {
        lastPointX = ltrCallback(lastPointX, bezierBbox[2]);
      }
    }
    lastX = x;
    lastY = y;
  }
  const bbox = __privateGet(this, _bbox);
  bbox[0] = minMax[0] - __privateGet(this, _innerMargin2);
  bbox[1] = minMax[1] - __privateGet(this, _innerMargin2);
  bbox[2] = minMax[2] - minMax[0] + 2 * __privateGet(this, _innerMargin2);
  bbox[3] = minMax[3] - minMax[1] + 2 * __privateGet(this, _innerMargin2);
  this.firstPoint = [firstPointX, firstPointY];
  this.lastPoint = [lastPointX, lastPointY];
};
var _box3, _firstPoint, _lastPoint, _verticalEdges, _intervals, _getOutlines, getOutlines_fn, _binarySearch, binarySearch_fn, _insert, insert_fn, _remove, remove_fn, _breakEdge, breakEdge_fn;
var HighlightOutliner = class {
  constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true) {
    __privateAdd(this, _getOutlines);
    __privateAdd(this, _binarySearch);
    __privateAdd(this, _insert);
    __privateAdd(this, _remove);
    __privateAdd(this, _breakEdge);
    __privateAdd(this, _box3, void 0);
    __privateAdd(this, _firstPoint, void 0);
    __privateAdd(this, _lastPoint, void 0);
    __privateAdd(this, _verticalEdges, []);
    __privateAdd(this, _intervals, []);
    const minMax = [Infinity, Infinity, -Infinity, -Infinity];
    const NUMBER_OF_DIGITS = 4;
    const EPSILON = 10 ** -NUMBER_OF_DIGITS;
    for (const {
      x,
      y,
      width,
      height
    } of boxes) {
      const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;
      const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;
      const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;
      const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;
      const left = [x1, y1, y2, true];
      const right = [x2, y1, y2, false];
      __privateGet(this, _verticalEdges).push(left, right);
      Util.rectBoundingBox(x1, y1, x2, y2, minMax);
    }
    const bboxWidth = minMax[2] - minMax[0] + 2 * innerMargin;
    const bboxHeight = minMax[3] - minMax[1] + 2 * innerMargin;
    const shiftedMinX = minMax[0] - innerMargin;
    const shiftedMinY = minMax[1] - innerMargin;
    let firstPointX = isLTR ? -Infinity : Infinity;
    let firstPointY = Infinity;
    const lastEdge = __privateGet(this, _verticalEdges).at(isLTR ? -1 : -2);
    const lastPoint = [lastEdge[0], lastEdge[2]];
    for (const edge of __privateGet(this, _verticalEdges)) {
      const [x, y1, y2, left] = edge;
      if (!left && isLTR) {
        if (y1 < firstPointY) {
          firstPointY = y1;
          firstPointX = x;
        } else if (y1 === firstPointY) {
          firstPointX = Math.max(firstPointX, x);
        }
      } else if (left && !isLTR) {
        if (y1 < firstPointY) {
          firstPointY = y1;
          firstPointX = x;
        } else if (y1 === firstPointY) {
          firstPointX = Math.min(firstPointX, x);
        }
      }
      edge[0] = (x - shiftedMinX) / bboxWidth;
      edge[1] = (y1 - shiftedMinY) / bboxHeight;
      edge[2] = (y2 - shiftedMinY) / bboxHeight;
    }
    __privateSet(this, _box3, new Float32Array([shiftedMinX, shiftedMinY, bboxWidth, bboxHeight]));
    __privateSet(this, _firstPoint, [firstPointX, firstPointY]);
    __privateSet(this, _lastPoint, lastPoint);
  }
  getOutlines() {
    __privateGet(this, _verticalEdges).sort((a, b) => a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);
    const outlineVerticalEdges = [];
    for (const edge of __privateGet(this, _verticalEdges)) {
      if (edge[3]) {
        outlineVerticalEdges.push(...__privateMethod(this, _breakEdge, breakEdge_fn).call(this, edge));
        __privateMethod(this, _insert, insert_fn).call(this, edge);
      } else {
        __privateMethod(this, _remove, remove_fn).call(this, edge);
        outlineVerticalEdges.push(...__privateMethod(this, _breakEdge, breakEdge_fn).call(this, edge));
      }
    }
    return __privateMethod(this, _getOutlines, getOutlines_fn).call(this, outlineVerticalEdges);
  }
};
_box3 = new WeakMap();
_firstPoint = new WeakMap();
_lastPoint = new WeakMap();
_verticalEdges = new WeakMap();
_intervals = new WeakMap();
_getOutlines = new WeakSet();
getOutlines_fn = function(outlineVerticalEdges) {
  const edges = [];
  const allEdges = /* @__PURE__ */ new Set();
  for (const edge of outlineVerticalEdges) {
    const [x, y1, y2] = edge;
    edges.push([x, y1, edge], [x, y2, edge]);
  }
  edges.sort((a, b) => a[1] - b[1] || a[0] - b[0]);
  for (let i = 0, ii = edges.length; i < ii; i += 2) {
    const edge1 = edges[i][2];
    const edge2 = edges[i + 1][2];
    edge1.push(edge2);
    edge2.push(edge1);
    allEdges.add(edge1);
    allEdges.add(edge2);
  }
  const outlines = [];
  let outline;
  while (allEdges.size > 0) {
    const edge = allEdges.values().next().value;
    let [x, y1, y2, edge1, edge2] = edge;
    allEdges.delete(edge);
    let lastPointX = x;
    let lastPointY = y1;
    outline = [x, y2];
    outlines.push(outline);
    while (true) {
      let e;
      if (allEdges.has(edge1)) {
        e = edge1;
      } else if (allEdges.has(edge2)) {
        e = edge2;
      } else {
        break;
      }
      allEdges.delete(e);
      [x, y1, y2, edge1, edge2] = e;
      if (lastPointX !== x) {
        outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);
        lastPointX = x;
      }
      lastPointY = lastPointY === y1 ? y2 : y1;
    }
    outline.push(lastPointX, lastPointY);
  }
  return new HighlightOutline(outlines, __privateGet(this, _box3), __privateGet(this, _firstPoint), __privateGet(this, _lastPoint));
};
_binarySearch = new WeakSet();
binarySearch_fn = function(y) {
  const array = __privateGet(this, _intervals);
  let start = 0;
  let end = array.length - 1;
  while (start <= end) {
    const middle = start + end >> 1;
    const y1 = array[middle][0];
    if (y1 === y) {
      return middle;
    }
    if (y1 < y) {
      start = middle + 1;
    } else {
      end = middle - 1;
    }
  }
  return end + 1;
};
_insert = new WeakSet();
insert_fn = function([, y1, y2]) {
  const index = __privateMethod(this, _binarySearch, binarySearch_fn).call(this, y1);
  __privateGet(this, _intervals).splice(index, 0, [y1, y2]);
};
_remove = new WeakSet();
remove_fn = function([, y1, y2]) {
  const index = __privateMethod(this, _binarySearch, binarySearch_fn).call(this, y1);
  for (let i = index; i < __privateGet(this, _intervals).length; i++) {
    const [start, end] = __privateGet(this, _intervals)[i];
    if (start !== y1) {
      break;
    }
    if (start === y1 && end === y2) {
      __privateGet(this, _intervals).splice(i, 1);
      return;
    }
  }
  for (let i = index - 1; i >= 0; i--) {
    const [start, end] = __privateGet(this, _intervals)[i];
    if (start !== y1) {
      break;
    }
    if (start === y1 && end === y2) {
      __privateGet(this, _intervals).splice(i, 1);
      return;
    }
  }
};
_breakEdge = new WeakSet();
breakEdge_fn = function(edge) {
  const [x, y1, y2] = edge;
  const results = [[x, y1, y2]];
  const index = __privateMethod(this, _binarySearch, binarySearch_fn).call(this, y2);
  for (let i = 0; i < index; i++) {
    const [start, end] = __privateGet(this, _intervals)[i];
    for (let j = 0, jj = results.length; j < jj; j++) {
      const [, y3, y4] = results[j];
      if (end <= y3 || y4 <= start) {
        continue;
      }
      if (y3 >= start) {
        if (y4 > end) {
          results[j][1] = end;
        } else {
          if (jj === 1) {
            return [];
          }
          results.splice(j, 1);
          j--;
          jj--;
        }
        continue;
      }
      results[j][2] = start;
      if (y4 > end) {
        results.push([x, end, y4]);
      }
    }
  }
  return results;
};
var _box4, _outlines;
var HighlightOutline = class extends Outline {
  constructor(outlines, box, firstPoint, lastPoint) {
    super();
    __privateAdd(this, _box4, void 0);
    __privateAdd(this, _outlines, void 0);
    __privateSet(this, _outlines, outlines);
    __privateSet(this, _box4, box);
    this.firstPoint = firstPoint;
    this.lastPoint = lastPoint;
  }
  toSVGPath() {
    const buffer = [];
    for (const polygon of __privateGet(this, _outlines)) {
      let [prevX, prevY] = polygon;
      buffer.push(`M${prevX} ${prevY}`);
      for (let i = 2; i < polygon.length; i += 2) {
        const x = polygon[i];
        const y = polygon[i + 1];
        if (x === prevX) {
          buffer.push(`V${y}`);
          prevY = y;
        } else if (y === prevY) {
          buffer.push(`H${x}`);
          prevX = x;
        }
      }
      buffer.push("Z");
    }
    return buffer.join(" ");
  }
  serialize([blX, blY, trX, trY], _rotation4) {
    const outlines = [];
    const width = trX - blX;
    const height = trY - blY;
    for (const outline of __privateGet(this, _outlines)) {
      const points = new Array(outline.length);
      for (let i = 0; i < outline.length; i += 2) {
        points[i] = blX + outline[i] * width;
        points[i + 1] = trY - outline[i + 1] * height;
      }
      outlines.push(points);
    }
    return outlines;
  }
  get box() {
    return __privateGet(this, _box4);
  }
  get classNamesForOutlining() {
    return ["highlightOutline"];
  }
};
_box4 = new WeakMap();
_outlines = new WeakMap();
var FreeHighlightOutliner = class extends FreeDrawOutliner {
  newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {
    return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);
  }
};
var FreeHighlightOutline = class extends FreeDrawOutline {
  newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
    return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);
  }
};
var _anchorNode, _anchorOffset, _boxes, _clipPathId, _colorPicker2, _focusOutlines, _focusNode, _focusOffset, _highlightDiv, _highlightOutlines, _id4, _isFreeHighlight, _firstPoint2, _lastPoint2, _outlineId, _text2, _thickness2, _methodOfCreation, _createOutlines, createOutlines_fn, _createFreeOutlines, createFreeOutlines_fn, _updateColor3, updateColor_fn3, _updateThickness, updateThickness_fn, _changeThickness, changeThickness_fn, _cleanDrawLayer, cleanDrawLayer_fn, _addToDrawLayer, addToDrawLayer_fn, _rotateBbox, rotateBbox_fn, _keydown, keydown_fn, _setCaret, setCaret_fn, _getRotation, getRotation_fn, _serializeBoxes, serializeBoxes_fn, _serializeOutlines, serializeOutlines_fn, _highlightMove, highlightMove_fn, _endHighlight, endHighlight_fn, _hasElementChanged2, hasElementChanged_fn2;
var _HighlightEditor = class _HighlightEditor extends AnnotationEditor {
  constructor(params) {
    super({
      ...params,
      name: "highlightEditor"
    });
    __privateAdd(this, _createOutlines);
    __privateAdd(this, _createFreeOutlines);
    __privateAdd(this, _updateColor3);
    __privateAdd(this, _updateThickness);
    __privateAdd(this, _changeThickness);
    __privateAdd(this, _cleanDrawLayer);
    __privateAdd(this, _addToDrawLayer);
    __privateAdd(this, _keydown);
    __privateAdd(this, _setCaret);
    __privateAdd(this, _getRotation);
    __privateAdd(this, _serializeBoxes);
    __privateAdd(this, _serializeOutlines);
    __privateAdd(this, _hasElementChanged2);
    __privateAdd(this, _anchorNode, null);
    __privateAdd(this, _anchorOffset, 0);
    __privateAdd(this, _boxes, void 0);
    __privateAdd(this, _clipPathId, null);
    __privateAdd(this, _colorPicker2, null);
    __privateAdd(this, _focusOutlines, null);
    __privateAdd(this, _focusNode, null);
    __privateAdd(this, _focusOffset, 0);
    __privateAdd(this, _highlightDiv, null);
    __privateAdd(this, _highlightOutlines, null);
    __privateAdd(this, _id4, null);
    __privateAdd(this, _isFreeHighlight, false);
    __privateAdd(this, _firstPoint2, null);
    __privateAdd(this, _lastPoint2, null);
    __privateAdd(this, _outlineId, null);
    __privateAdd(this, _text2, "");
    __privateAdd(this, _thickness2, void 0);
    __privateAdd(this, _methodOfCreation, "");
    this.color = params.color || _HighlightEditor._defaultColor;
    __privateSet(this, _thickness2, params.thickness || _HighlightEditor._defaultThickness);
    this.opacity = params.opacity || _HighlightEditor._defaultOpacity;
    __privateSet(this, _boxes, params.boxes || null);
    __privateSet(this, _methodOfCreation, params.methodOfCreation || "");
    __privateSet(this, _text2, params.text || "");
    this._isDraggable = false;
    this.defaultL10nId = "pdfjs-editor-highlight-editor";
    if (params.highlightId > -1) {
      __privateSet(this, _isFreeHighlight, true);
      __privateMethod(this, _createFreeOutlines, createFreeOutlines_fn).call(this, params);
      __privateMethod(this, _addToDrawLayer, addToDrawLayer_fn).call(this);
    } else if (__privateGet(this, _boxes)) {
      __privateSet(this, _anchorNode, params.anchorNode);
      __privateSet(this, _anchorOffset, params.anchorOffset);
      __privateSet(this, _focusNode, params.focusNode);
      __privateSet(this, _focusOffset, params.focusOffset);
      __privateMethod(this, _createOutlines, createOutlines_fn).call(this);
      __privateMethod(this, _addToDrawLayer, addToDrawLayer_fn).call(this);
      this.rotate(this.rotation);
    }
    if (!this.annotationElementId) {
      this._uiManager.a11yAlert("pdfjs-editor-highlight-added-alert");
    }
  }
  static get _keyboardManager() {
    const proto = _HighlightEditor.prototype;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], proto._moveCaret, {
      args: [0]
    }], [["ArrowRight", "mac+ArrowRight"], proto._moveCaret, {
      args: [1]
    }], [["ArrowUp", "mac+ArrowUp"], proto._moveCaret, {
      args: [2]
    }], [["ArrowDown", "mac+ArrowDown"], proto._moveCaret, {
      args: [3]
    }]]));
  }
  get telemetryInitialData() {
    return {
      action: "added",
      type: __privateGet(this, _isFreeHighlight) ? "free_highlight" : "highlight",
      color: this._uiManager.getNonHCMColorName(this.color),
      thickness: __privateGet(this, _thickness2),
      methodOfCreation: __privateGet(this, _methodOfCreation)
    };
  }
  get telemetryFinalData() {
    return {
      type: "highlight",
      color: this._uiManager.getNonHCMColorName(this.color)
    };
  }
  static computeTelemetryFinalData(data) {
    return {
      numberOfColors: data.get("color").size
    };
  }
  static initialize(l10n, uiManager) {
    var _a2;
    AnnotationEditor.initialize(l10n, uiManager);
    _HighlightEditor._defaultColor || (_HighlightEditor._defaultColor = ((_a2 = uiManager.highlightColors) == null ? void 0 : _a2.values().next().value) || "#fff066");
  }
  static updateDefaultParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
        _HighlightEditor._defaultColor = value;
        break;
      case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
        _HighlightEditor._defaultThickness = value;
        break;
    }
  }
  translateInPage(x, y) {
  }
  get toolbarPosition() {
    return __privateGet(this, _lastPoint2);
  }
  get commentButtonPosition() {
    return __privateGet(this, _firstPoint2);
  }
  updateParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
        __privateMethod(this, _updateColor3, updateColor_fn3).call(this, value);
        break;
      case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
        __privateMethod(this, _updateThickness, updateThickness_fn).call(this, value);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, _HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, _HighlightEditor._defaultThickness]];
  }
  get propertiesToUpdate() {
    return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, this.color || _HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, __privateGet(this, _thickness2) || _HighlightEditor._defaultThickness], [AnnotationEditorParamsType.HIGHLIGHT_FREE, __privateGet(this, _isFreeHighlight)]];
  }
  onUpdatedColor() {
    var _a2, _b;
    (_a2 = this.parent) == null ? void 0 : _a2.drawLayer.updateProperties(__privateGet(this, _id4), {
      root: {
        fill: this.color,
        "fill-opacity": this.opacity
      }
    });
    (_b = __privateGet(this, _colorPicker2)) == null ? void 0 : _b.updateColor(this.color);
    super.onUpdatedColor();
  }
  get toolbarButtons() {
    if (this._uiManager.highlightColors) {
      const colorPicker = __privateSet(this, _colorPicker2, new ColorPicker({
        editor: this
      }));
      return [["colorPicker", colorPicker]];
    }
    return super.toolbarButtons;
  }
  disableEditing() {
    super.disableEditing();
    this.div.classList.toggle("disabled", true);
  }
  enableEditing() {
    super.enableEditing();
    this.div.classList.toggle("disabled", false);
  }
  fixAndSetPosition() {
    return super.fixAndSetPosition(__privateMethod(this, _getRotation, getRotation_fn).call(this));
  }
  getBaseTranslation() {
    return [0, 0];
  }
  getRect(tx, ty) {
    return super.getRect(tx, ty, __privateMethod(this, _getRotation, getRotation_fn).call(this));
  }
  onceAdded(focus) {
    if (!this.annotationElementId) {
      this.parent.addUndoableEditor(this);
    }
    if (focus) {
      this.div.focus();
    }
  }
  remove() {
    __privateMethod(this, _cleanDrawLayer, cleanDrawLayer_fn).call(this);
    this._reportTelemetry({
      action: "deleted"
    });
    super.remove();
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    __privateMethod(this, _addToDrawLayer, addToDrawLayer_fn).call(this);
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  setParent(parent) {
    var _a2;
    let mustBeSelected = false;
    if (this.parent && !parent) {
      __privateMethod(this, _cleanDrawLayer, cleanDrawLayer_fn).call(this);
    } else if (parent) {
      __privateMethod(this, _addToDrawLayer, addToDrawLayer_fn).call(this, parent);
      mustBeSelected = !this.parent && ((_a2 = this.div) == null ? void 0 : _a2.classList.contains("selectedEditor"));
    }
    super.setParent(parent);
    this.show(this._isVisible);
    if (mustBeSelected) {
      this.select();
    }
  }
  rotate(angle) {
    var _a2, _b, _c;
    const {
      drawLayer
    } = this.parent;
    let box;
    if (__privateGet(this, _isFreeHighlight)) {
      angle = (angle - this.rotation + 360) % 360;
      box = __privateMethod(_a2 = _HighlightEditor, _rotateBbox, rotateBbox_fn).call(_a2, __privateGet(this, _highlightOutlines).box, angle);
    } else {
      box = __privateMethod(_b = _HighlightEditor, _rotateBbox, rotateBbox_fn).call(_b, [this.x, this.y, this.width, this.height], angle);
    }
    drawLayer.updateProperties(__privateGet(this, _id4), {
      bbox: box,
      root: {
        "data-main-rotation": angle
      }
    });
    drawLayer.updateProperties(__privateGet(this, _outlineId), {
      bbox: __privateMethod(_c = _HighlightEditor, _rotateBbox, rotateBbox_fn).call(_c, __privateGet(this, _focusOutlines).box, angle),
      root: {
        "data-main-rotation": angle
      }
    });
  }
  render() {
    if (this.div) {
      return this.div;
    }
    const div = super.render();
    if (__privateGet(this, _text2)) {
      div.setAttribute("aria-label", __privateGet(this, _text2));
      div.setAttribute("role", "mark");
    }
    if (__privateGet(this, _isFreeHighlight)) {
      div.classList.add("free");
    } else {
      this.div.addEventListener("keydown", __privateMethod(this, _keydown, keydown_fn).bind(this), {
        signal: this._uiManager._signal
      });
    }
    const highlightDiv = __privateSet(this, _highlightDiv, document.createElement("div"));
    div.append(highlightDiv);
    highlightDiv.setAttribute("aria-hidden", "true");
    highlightDiv.className = "internal";
    highlightDiv.style.clipPath = __privateGet(this, _clipPathId);
    this.setDims(this.width, this.height);
    bindEvents(this, __privateGet(this, _highlightDiv), ["pointerover", "pointerleave"]);
    this.enableEditing();
    return div;
  }
  pointerover() {
    var _a2;
    if (!this.isSelected) {
      (_a2 = this.parent) == null ? void 0 : _a2.drawLayer.updateProperties(__privateGet(this, _outlineId), {
        rootClass: {
          hovered: true
        }
      });
    }
  }
  pointerleave() {
    var _a2;
    if (!this.isSelected) {
      (_a2 = this.parent) == null ? void 0 : _a2.drawLayer.updateProperties(__privateGet(this, _outlineId), {
        rootClass: {
          hovered: false
        }
      });
    }
  }
  _moveCaret(direction) {
    this.parent.unselect(this);
    switch (direction) {
      case 0:
      case 2:
        __privateMethod(this, _setCaret, setCaret_fn).call(this, true);
        break;
      case 1:
      case 3:
        __privateMethod(this, _setCaret, setCaret_fn).call(this, false);
        break;
    }
  }
  select() {
    var _a2;
    super.select();
    if (!__privateGet(this, _outlineId)) {
      return;
    }
    (_a2 = this.parent) == null ? void 0 : _a2.drawLayer.updateProperties(__privateGet(this, _outlineId), {
      rootClass: {
        hovered: false,
        selected: true
      }
    });
  }
  unselect() {
    var _a2;
    super.unselect();
    if (!__privateGet(this, _outlineId)) {
      return;
    }
    (_a2 = this.parent) == null ? void 0 : _a2.drawLayer.updateProperties(__privateGet(this, _outlineId), {
      rootClass: {
        selected: false
      }
    });
    if (!__privateGet(this, _isFreeHighlight)) {
      __privateMethod(this, _setCaret, setCaret_fn).call(this, false);
    }
  }
  get _mustFixPosition() {
    return !__privateGet(this, _isFreeHighlight);
  }
  show(visible = this._isVisible) {
    super.show(visible);
    if (this.parent) {
      this.parent.drawLayer.updateProperties(__privateGet(this, _id4), {
        rootClass: {
          hidden: !visible
        }
      });
      this.parent.drawLayer.updateProperties(__privateGet(this, _outlineId), {
        rootClass: {
          hidden: !visible
        }
      });
    }
  }
  static startHighlighting(parent, isLTR, {
    target: textLayer,
    x,
    y
  }) {
    const {
      x: layerX,
      y: layerY,
      width: parentWidth,
      height: parentHeight
    } = textLayer.getBoundingClientRect();
    const ac = new AbortController();
    const signal = parent.combinedSignal(ac);
    const pointerUpCallback = (e) => {
      ac.abort();
      __privateMethod(this, _endHighlight, endHighlight_fn).call(this, parent, e);
    };
    window.addEventListener("blur", pointerUpCallback, {
      signal
    });
    window.addEventListener("pointerup", pointerUpCallback, {
      signal
    });
    window.addEventListener("pointerdown", stopEvent, {
      capture: true,
      passive: false,
      signal
    });
    window.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    textLayer.addEventListener("pointermove", __privateMethod(this, _highlightMove, highlightMove_fn).bind(this, parent), {
      signal
    });
    this._freeHighlight = new FreeHighlightOutliner({
      x,
      y
    }, [layerX, layerY, parentWidth, parentHeight], parent.scale, this._defaultThickness / 2, isLTR, 1e-3);
    ({
      id: this._freeHighlightId,
      clipPathId: this._freeHighlightClipId
    } = parent.drawLayer.draw({
      bbox: [0, 0, 1, 1],
      root: {
        viewBox: "0 0 1 1",
        fill: this._defaultColor,
        "fill-opacity": this._defaultOpacity
      },
      rootClass: {
        highlight: true,
        free: true
      },
      path: {
        d: this._freeHighlight.toSVGPath()
      }
    }, true, true));
  }
  static async deserialize(data, parent, uiManager) {
    var _a2, _b, _c, _d;
    let initialData = null;
    if (data instanceof HighlightAnnotationElement) {
      const {
        data: {
          quadPoints: quadPoints2,
          rect,
          rotation,
          id,
          color: color2,
          opacity: opacity2,
          popupRef,
          richText,
          contentsObj,
          creationDate,
          modificationDate
        },
        parent: {
          page: {
            pageNumber
          }
        }
      } = data;
      initialData = data = {
        annotationType: AnnotationEditorType.HIGHLIGHT,
        color: Array.from(color2),
        opacity: opacity2,
        quadPoints: quadPoints2,
        boxes: null,
        pageIndex: pageNumber - 1,
        rect: rect.slice(0),
        rotation,
        annotationElementId: id,
        id,
        deleted: false,
        popupRef,
        richText,
        comment: (contentsObj == null ? void 0 : contentsObj.str) || null,
        creationDate,
        modificationDate
      };
    } else if (data instanceof InkAnnotationElement) {
      const {
        data: {
          inkLists: inkLists2,
          rect,
          rotation,
          id,
          color: color2,
          borderStyle: {
            rawWidth: thickness
          },
          popupRef,
          richText,
          contentsObj,
          creationDate,
          modificationDate
        },
        parent: {
          page: {
            pageNumber
          }
        }
      } = data;
      initialData = data = {
        annotationType: AnnotationEditorType.HIGHLIGHT,
        color: Array.from(color2),
        thickness,
        inkLists: inkLists2,
        boxes: null,
        pageIndex: pageNumber - 1,
        rect: rect.slice(0),
        rotation,
        annotationElementId: id,
        id,
        deleted: false,
        popupRef,
        richText,
        comment: (contentsObj == null ? void 0 : contentsObj.str) || null,
        creationDate,
        modificationDate
      };
    }
    const {
      color,
      quadPoints,
      inkLists,
      opacity
    } = data;
    const editor = await super.deserialize(data, parent, uiManager);
    editor.color = Util.makeHexColor(...color);
    editor.opacity = opacity || 1;
    if (inkLists) {
      __privateSet(editor, _thickness2, data.thickness);
    }
    editor._initialData = initialData;
    if (data.comment) {
      editor.setCommentData(data);
    }
    const [pageWidth, pageHeight] = editor.pageDimensions;
    const [pageX, pageY] = editor.pageTranslation;
    if (quadPoints) {
      const boxes = __privateSet(editor, _boxes, []);
      for (let i = 0; i < quadPoints.length; i += 8) {
        boxes.push({
          x: (quadPoints[i] - pageX) / pageWidth,
          y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,
          width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,
          height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight
        });
      }
      __privateMethod(_a2 = editor, _createOutlines, createOutlines_fn).call(_a2);
      __privateMethod(_b = editor, _addToDrawLayer, addToDrawLayer_fn).call(_b);
      editor.rotate(editor.rotation);
    } else if (inkLists) {
      __privateSet(editor, _isFreeHighlight, true);
      const points = inkLists[0];
      const point = {
        x: points[0] - pageX,
        y: pageHeight - (points[1] - pageY)
      };
      const outliner = new FreeHighlightOutliner(point, [0, 0, pageWidth, pageHeight], 1, __privateGet(editor, _thickness2) / 2, true, 1e-3);
      for (let i = 0, ii = points.length; i < ii; i += 2) {
        point.x = points[i] - pageX;
        point.y = pageHeight - (points[i + 1] - pageY);
        outliner.add(point);
      }
      const {
        id,
        clipPathId
      } = parent.drawLayer.draw({
        bbox: [0, 0, 1, 1],
        root: {
          viewBox: "0 0 1 1",
          fill: editor.color,
          "fill-opacity": editor._defaultOpacity
        },
        rootClass: {
          highlight: true,
          free: true
        },
        path: {
          d: outliner.toSVGPath()
        }
      }, true, true);
      __privateMethod(_c = editor, _createFreeOutlines, createFreeOutlines_fn).call(_c, {
        highlightOutlines: outliner.getOutlines(),
        highlightId: id,
        clipPathId
      });
      __privateMethod(_d = editor, _addToDrawLayer, addToDrawLayer_fn).call(_d);
      editor.rotate(editor.parentRotation);
    }
    return editor;
  }
  serialize(isForCopying = false) {
    if (this.isEmpty() || isForCopying) {
      return null;
    }
    if (this.deleted) {
      return this.serializeDeleted();
    }
    const color = AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));
    const serialized = super.serialize(isForCopying);
    Object.assign(serialized, {
      color,
      opacity: this.opacity,
      thickness: __privateGet(this, _thickness2),
      quadPoints: __privateMethod(this, _serializeBoxes, serializeBoxes_fn).call(this),
      outlines: __privateMethod(this, _serializeOutlines, serializeOutlines_fn).call(this, serialized.rect)
    });
    this.addComment(serialized);
    if (this.annotationElementId && !__privateMethod(this, _hasElementChanged2, hasElementChanged_fn2).call(this, serialized)) {
      return null;
    }
    serialized.id = this.annotationElementId;
    return serialized;
  }
  renderAnnotationElement(annotation) {
    if (this.deleted) {
      annotation.hide();
      return null;
    }
    annotation.updateEdited({
      rect: this.getPDFRect(),
      popup: this.comment
    });
    return null;
  }
  static canCreateNewEmptyEditor() {
    return false;
  }
};
_anchorNode = new WeakMap();
_anchorOffset = new WeakMap();
_boxes = new WeakMap();
_clipPathId = new WeakMap();
_colorPicker2 = new WeakMap();
_focusOutlines = new WeakMap();
_focusNode = new WeakMap();
_focusOffset = new WeakMap();
_highlightDiv = new WeakMap();
_highlightOutlines = new WeakMap();
_id4 = new WeakMap();
_isFreeHighlight = new WeakMap();
_firstPoint2 = new WeakMap();
_lastPoint2 = new WeakMap();
_outlineId = new WeakMap();
_text2 = new WeakMap();
_thickness2 = new WeakMap();
_methodOfCreation = new WeakMap();
_createOutlines = new WeakSet();
createOutlines_fn = function() {
  const outliner = new HighlightOutliner(__privateGet(this, _boxes), 1e-3);
  __privateSet(this, _highlightOutlines, outliner.getOutlines());
  [this.x, this.y, this.width, this.height] = __privateGet(this, _highlightOutlines).box;
  const outlinerForOutline = new HighlightOutliner(__privateGet(this, _boxes), 25e-4, 1e-3, this._uiManager.direction === "ltr");
  __privateSet(this, _focusOutlines, outlinerForOutline.getOutlines());
  const {
    firstPoint
  } = __privateGet(this, _highlightOutlines);
  __privateSet(this, _firstPoint2, [(firstPoint[0] - this.x) / this.width, (firstPoint[1] - this.y) / this.height]);
  const {
    lastPoint
  } = __privateGet(this, _focusOutlines);
  __privateSet(this, _lastPoint2, [(lastPoint[0] - this.x) / this.width, (lastPoint[1] - this.y) / this.height]);
};
_createFreeOutlines = new WeakSet();
createFreeOutlines_fn = function({
  highlightOutlines,
  highlightId,
  clipPathId
}) {
  var _a2, _b;
  __privateSet(this, _highlightOutlines, highlightOutlines);
  const extraThickness = 1.5;
  __privateSet(this, _focusOutlines, highlightOutlines.getNewOutline(__privateGet(this, _thickness2) / 2 + extraThickness, 25e-4));
  if (highlightId >= 0) {
    __privateSet(this, _id4, highlightId);
    __privateSet(this, _clipPathId, clipPathId);
    this.parent.drawLayer.finalizeDraw(highlightId, {
      bbox: highlightOutlines.box,
      path: {
        d: highlightOutlines.toSVGPath()
      }
    });
    __privateSet(this, _outlineId, this.parent.drawLayer.drawOutline({
      rootClass: {
        highlightOutline: true,
        free: true
      },
      bbox: __privateGet(this, _focusOutlines).box,
      path: {
        d: __privateGet(this, _focusOutlines).toSVGPath()
      }
    }, true));
  } else if (this.parent) {
    const angle = this.parent.viewport.rotation;
    this.parent.drawLayer.updateProperties(__privateGet(this, _id4), {
      bbox: __privateMethod(_a2 = _HighlightEditor, _rotateBbox, rotateBbox_fn).call(_a2, __privateGet(this, _highlightOutlines).box, (angle - this.rotation + 360) % 360),
      path: {
        d: highlightOutlines.toSVGPath()
      }
    });
    this.parent.drawLayer.updateProperties(__privateGet(this, _outlineId), {
      bbox: __privateMethod(_b = _HighlightEditor, _rotateBbox, rotateBbox_fn).call(_b, __privateGet(this, _focusOutlines).box, angle),
      path: {
        d: __privateGet(this, _focusOutlines).toSVGPath()
      }
    });
  }
  const [x, y, width, height] = highlightOutlines.box;
  switch (this.rotation) {
    case 0:
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      break;
    case 90: {
      const [pageWidth, pageHeight] = this.parentDimensions;
      this.x = y;
      this.y = 1 - x;
      this.width = width * pageHeight / pageWidth;
      this.height = height * pageWidth / pageHeight;
      break;
    }
    case 180:
      this.x = 1 - x;
      this.y = 1 - y;
      this.width = width;
      this.height = height;
      break;
    case 270: {
      const [pageWidth, pageHeight] = this.parentDimensions;
      this.x = 1 - y;
      this.y = x;
      this.width = width * pageHeight / pageWidth;
      this.height = height * pageWidth / pageHeight;
      break;
    }
  }
  const {
    firstPoint
  } = highlightOutlines;
  __privateSet(this, _firstPoint2, [(firstPoint[0] - x) / width, (firstPoint[1] - y) / height]);
  const {
    lastPoint
  } = __privateGet(this, _focusOutlines);
  __privateSet(this, _lastPoint2, [(lastPoint[0] - x) / width, (lastPoint[1] - y) / height]);
};
_updateColor3 = new WeakSet();
updateColor_fn3 = function(color) {
  const setColorAndOpacity = (col, opa) => {
    this.color = col;
    this.opacity = opa;
    this.onUpdatedColor();
  };
  const savedColor = this.color;
  const savedOpacity = this.opacity;
  this.addCommands({
    cmd: setColorAndOpacity.bind(this, color, _HighlightEditor._defaultOpacity),
    undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: true,
    type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
    overwriteIfSameType: true,
    keepUndo: true
  });
  this._reportTelemetry({
    action: "color_changed",
    color: this._uiManager.getNonHCMColorName(color)
  }, true);
};
_updateThickness = new WeakSet();
updateThickness_fn = function(thickness) {
  const savedThickness = __privateGet(this, _thickness2);
  const setThickness = (th) => {
    __privateSet(this, _thickness2, th);
    __privateMethod(this, _changeThickness, changeThickness_fn).call(this, th);
  };
  this.addCommands({
    cmd: setThickness.bind(this, thickness),
    undo: setThickness.bind(this, savedThickness),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: true,
    type: AnnotationEditorParamsType.INK_THICKNESS,
    overwriteIfSameType: true,
    keepUndo: true
  });
  this._reportTelemetry({
    action: "thickness_changed",
    thickness
  }, true);
};
_changeThickness = new WeakSet();
changeThickness_fn = function(thickness) {
  if (!__privateGet(this, _isFreeHighlight)) {
    return;
  }
  __privateMethod(this, _createFreeOutlines, createFreeOutlines_fn).call(this, {
    highlightOutlines: __privateGet(this, _highlightOutlines).getNewOutline(thickness / 2)
  });
  this.fixAndSetPosition();
  this.setDims(this.width, this.height);
};
_cleanDrawLayer = new WeakSet();
cleanDrawLayer_fn = function() {
  if (__privateGet(this, _id4) === null || !this.parent) {
    return;
  }
  this.parent.drawLayer.remove(__privateGet(this, _id4));
  __privateSet(this, _id4, null);
  this.parent.drawLayer.remove(__privateGet(this, _outlineId));
  __privateSet(this, _outlineId, null);
};
_addToDrawLayer = new WeakSet();
addToDrawLayer_fn = function(parent = this.parent) {
  if (__privateGet(this, _id4) !== null) {
    return;
  }
  ({
    id: __privateWrapper(this, _id4)._,
    clipPathId: __privateWrapper(this, _clipPathId)._
  } = parent.drawLayer.draw({
    bbox: __privateGet(this, _highlightOutlines).box,
    root: {
      viewBox: "0 0 1 1",
      fill: this.color,
      "fill-opacity": this.opacity
    },
    rootClass: {
      highlight: true,
      free: __privateGet(this, _isFreeHighlight)
    },
    path: {
      d: __privateGet(this, _highlightOutlines).toSVGPath()
    }
  }, false, true));
  __privateSet(this, _outlineId, parent.drawLayer.drawOutline({
    rootClass: {
      highlightOutline: true,
      free: __privateGet(this, _isFreeHighlight)
    },
    bbox: __privateGet(this, _focusOutlines).box,
    path: {
      d: __privateGet(this, _focusOutlines).toSVGPath()
    }
  }, __privateGet(this, _isFreeHighlight)));
  if (__privateGet(this, _highlightDiv)) {
    __privateGet(this, _highlightDiv).style.clipPath = __privateGet(this, _clipPathId);
  }
};
_rotateBbox = new WeakSet();
rotateBbox_fn = function([x, y, width, height], angle) {
  switch (angle) {
    case 90:
      return [1 - y - height, x, height, width];
    case 180:
      return [1 - x - width, 1 - y - height, width, height];
    case 270:
      return [y, 1 - x - width, height, width];
  }
  return [x, y, width, height];
};
_keydown = new WeakSet();
keydown_fn = function(event) {
  _HighlightEditor._keyboardManager.exec(this, event);
};
_setCaret = new WeakSet();
setCaret_fn = function(start) {
  if (!__privateGet(this, _anchorNode)) {
    return;
  }
  const selection = window.getSelection();
  if (start) {
    selection.setPosition(__privateGet(this, _anchorNode), __privateGet(this, _anchorOffset));
  } else {
    selection.setPosition(__privateGet(this, _focusNode), __privateGet(this, _focusOffset));
  }
};
_getRotation = new WeakSet();
getRotation_fn = function() {
  return __privateGet(this, _isFreeHighlight) ? this.rotation : 0;
};
_serializeBoxes = new WeakSet();
serializeBoxes_fn = function() {
  if (__privateGet(this, _isFreeHighlight)) {
    return null;
  }
  const [pageWidth, pageHeight] = this.pageDimensions;
  const [pageX, pageY] = this.pageTranslation;
  const boxes = __privateGet(this, _boxes);
  const quadPoints = new Float32Array(boxes.length * 8);
  let i = 0;
  for (const {
    x,
    y,
    width,
    height
  } of boxes) {
    const sx = x * pageWidth + pageX;
    const sy = (1 - y) * pageHeight + pageY;
    quadPoints[i] = quadPoints[i + 4] = sx;
    quadPoints[i + 1] = quadPoints[i + 3] = sy;
    quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;
    quadPoints[i + 5] = quadPoints[i + 7] = sy - height * pageHeight;
    i += 8;
  }
  return quadPoints;
};
_serializeOutlines = new WeakSet();
serializeOutlines_fn = function(rect) {
  return __privateGet(this, _highlightOutlines).serialize(rect, __privateMethod(this, _getRotation, getRotation_fn).call(this));
};
_highlightMove = new WeakSet();
highlightMove_fn = function(parent, event) {
  if (this._freeHighlight.add(event)) {
    parent.drawLayer.updateProperties(this._freeHighlightId, {
      path: {
        d: this._freeHighlight.toSVGPath()
      }
    });
  }
};
_endHighlight = new WeakSet();
endHighlight_fn = function(parent, event) {
  if (!this._freeHighlight.isEmpty()) {
    parent.createAndAddNewEditor(event, false, {
      highlightId: this._freeHighlightId,
      highlightOutlines: this._freeHighlight.getOutlines(),
      clipPathId: this._freeHighlightClipId,
      methodOfCreation: "main_toolbar"
    });
  } else {
    parent.drawLayer.remove(this._freeHighlightId);
  }
  this._freeHighlightId = -1;
  this._freeHighlight = null;
  this._freeHighlightClipId = "";
};
_hasElementChanged2 = new WeakSet();
hasElementChanged_fn2 = function(serialized) {
  const {
    color
  } = this._initialData;
  return this.hasEditedComment || serialized.color.some((c, i) => c !== color[i]);
};
__privateAdd(_HighlightEditor, _rotateBbox);
__privateAdd(_HighlightEditor, _highlightMove);
__privateAdd(_HighlightEditor, _endHighlight);
__publicField(_HighlightEditor, "_defaultColor", null);
__publicField(_HighlightEditor, "_defaultOpacity", 1);
__publicField(_HighlightEditor, "_defaultThickness", 12);
__publicField(_HighlightEditor, "_type", "highlight");
__publicField(_HighlightEditor, "_editorType", AnnotationEditorType.HIGHLIGHT);
__publicField(_HighlightEditor, "_freeHighlightId", -1);
__publicField(_HighlightEditor, "_freeHighlight", null);
__publicField(_HighlightEditor, "_freeHighlightClipId", "");
var HighlightEditor = _HighlightEditor;
var _svgProperties;
var DrawingOptions = class {
  constructor() {
    __privateAdd(this, _svgProperties, /* @__PURE__ */ Object.create(null));
  }
  updateProperty(name, value) {
    this[name] = value;
    this.updateSVGProperty(name, value);
  }
  updateProperties(properties) {
    if (!properties) {
      return;
    }
    for (const [name, value] of Object.entries(properties)) {
      if (!name.startsWith("_")) {
        this.updateProperty(name, value);
      }
    }
  }
  updateSVGProperty(name, value) {
    __privateGet(this, _svgProperties)[name] = value;
  }
  toSVGProperties() {
    const root = __privateGet(this, _svgProperties);
    __privateSet(this, _svgProperties, /* @__PURE__ */ Object.create(null));
    return {
      root
    };
  }
  reset() {
    __privateSet(this, _svgProperties, /* @__PURE__ */ Object.create(null));
  }
  updateAll(options = this) {
    this.updateProperties(options);
  }
  clone() {
    unreachable("Not implemented");
  }
};
_svgProperties = new WeakMap();
var _drawOutlines, _mustBeCommitted, _currentDraw, _currentDrawingAC, _currentDrawingOptions, _currentPointerId, _currentPointerType, _currentPointerIds, _currentMoveTimestamp, _createDrawOutlines, createDrawOutlines_fn, _createDrawing, createDrawing_fn, _cleanDrawLayer2, cleanDrawLayer_fn2, _addToDrawLayer2, addToDrawLayer_fn2, _convertToParentSpace, convertToParentSpace_fn, _convertToDrawSpace, convertToDrawSpace_fn, _updateBbox, updateBbox_fn, _rotateBox, rotateBox_fn;
var _DrawingEditor = class _DrawingEditor extends AnnotationEditor {
  constructor(params) {
    super(params);
    __privateAdd(this, _createDrawOutlines);
    __privateAdd(this, _createDrawing);
    __privateAdd(this, _cleanDrawLayer2);
    __privateAdd(this, _addToDrawLayer2);
    __privateAdd(this, _convertToParentSpace);
    __privateAdd(this, _convertToDrawSpace);
    __privateAdd(this, _updateBbox);
    __privateAdd(this, _rotateBox);
    __privateAdd(this, _drawOutlines, null);
    __privateAdd(this, _mustBeCommitted, void 0);
    __publicField(this, "_colorPicker", null);
    __publicField(this, "_drawId", null);
    __privateSet(this, _mustBeCommitted, params.mustBeCommitted || false);
    this._addOutlines(params);
  }
  onUpdatedColor() {
    var _a2;
    (_a2 = this._colorPicker) == null ? void 0 : _a2.update(this.color);
    super.onUpdatedColor();
  }
  _addOutlines(params) {
    if (params.drawOutlines) {
      __privateMethod(this, _createDrawOutlines, createDrawOutlines_fn).call(this, params);
      __privateMethod(this, _addToDrawLayer2, addToDrawLayer_fn2).call(this);
    }
  }
  static _mergeSVGProperties(p1, p2) {
    const p1Keys = new Set(Object.keys(p1));
    for (const [key, value] of Object.entries(p2)) {
      if (p1Keys.has(key)) {
        Object.assign(p1[key], value);
      } else {
        p1[key] = value;
      }
    }
    return p1;
  }
  static getDefaultDrawingOptions(_options) {
    unreachable("Not implemented");
  }
  static get typesMap() {
    unreachable("Not implemented");
  }
  static get isDrawer() {
    return true;
  }
  static get supportMultipleDrawings() {
    return false;
  }
  static updateDefaultParams(type, value) {
    const propertyName = this.typesMap.get(type);
    if (propertyName) {
      this._defaultDrawingOptions.updateProperty(propertyName, value);
    }
    if (this._currentParent) {
      __privateGet(_DrawingEditor, _currentDraw).updateProperty(propertyName, value);
      this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
    }
  }
  updateParams(type, value) {
    const propertyName = this.constructor.typesMap.get(type);
    if (propertyName) {
      this._updateProperty(type, propertyName, value);
    }
  }
  static get defaultPropertiesToUpdate() {
    const properties = [];
    const options = this._defaultDrawingOptions;
    for (const [type, name] of this.typesMap) {
      properties.push([type, options[name]]);
    }
    return properties;
  }
  get propertiesToUpdate() {
    const properties = [];
    const {
      _drawingOptions
    } = this;
    for (const [type, name] of this.constructor.typesMap) {
      properties.push([type, _drawingOptions[name]]);
    }
    return properties;
  }
  _updateProperty(type, name, value) {
    const options = this._drawingOptions;
    const savedValue = options[name];
    const setter = (val) => {
      var _a2;
      options.updateProperty(name, val);
      const bbox = __privateGet(this, _drawOutlines).updateProperty(name, val);
      if (bbox) {
        __privateMethod(this, _updateBbox, updateBbox_fn).call(this, bbox);
      }
      (_a2 = this.parent) == null ? void 0 : _a2.drawLayer.updateProperties(this._drawId, options.toSVGProperties());
      if (type === this.colorType) {
        this.onUpdatedColor();
      }
    };
    this.addCommands({
      cmd: setter.bind(this, value),
      undo: setter.bind(this, savedValue),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  _onResizing() {
    var _a2;
    (_a2 = this.parent) == null ? void 0 : _a2.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(__privateGet(this, _drawOutlines).getPathResizingSVGProperties(__privateMethod(this, _convertToDrawSpace, convertToDrawSpace_fn).call(this)), {
      bbox: __privateMethod(this, _rotateBox, rotateBox_fn).call(this)
    }));
  }
  _onResized() {
    var _a2;
    (_a2 = this.parent) == null ? void 0 : _a2.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(__privateGet(this, _drawOutlines).getPathResizedSVGProperties(__privateMethod(this, _convertToDrawSpace, convertToDrawSpace_fn).call(this)), {
      bbox: __privateMethod(this, _rotateBox, rotateBox_fn).call(this)
    }));
  }
  _onTranslating(_x, _y) {
    var _a2;
    (_a2 = this.parent) == null ? void 0 : _a2.drawLayer.updateProperties(this._drawId, {
      bbox: __privateMethod(this, _rotateBox, rotateBox_fn).call(this)
    });
  }
  _onTranslated() {
    var _a2;
    (_a2 = this.parent) == null ? void 0 : _a2.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(__privateGet(this, _drawOutlines).getPathTranslatedSVGProperties(__privateMethod(this, _convertToDrawSpace, convertToDrawSpace_fn).call(this), this.parentDimensions), {
      bbox: __privateMethod(this, _rotateBox, rotateBox_fn).call(this)
    }));
  }
  _onStartDragging() {
    var _a2;
    (_a2 = this.parent) == null ? void 0 : _a2.drawLayer.updateProperties(this._drawId, {
      rootClass: {
        moving: true
      }
    });
  }
  _onStopDragging() {
    var _a2;
    (_a2 = this.parent) == null ? void 0 : _a2.drawLayer.updateProperties(this._drawId, {
      rootClass: {
        moving: false
      }
    });
  }
  commit() {
    super.commit();
    this.disableEditMode();
    this.disableEditing();
  }
  disableEditing() {
    super.disableEditing();
    this.div.classList.toggle("disabled", true);
  }
  enableEditing() {
    super.enableEditing();
    this.div.classList.toggle("disabled", false);
  }
  getBaseTranslation() {
    return [0, 0];
  }
  get isResizable() {
    return true;
  }
  onceAdded(focus) {
    if (!this.annotationElementId) {
      this.parent.addUndoableEditor(this);
    }
    this._isDraggable = true;
    if (__privateGet(this, _mustBeCommitted)) {
      __privateSet(this, _mustBeCommitted, false);
      this.commit();
      this.parent.setSelected(this);
      if (focus && this.isOnScreen) {
        this.div.focus();
      }
    }
  }
  remove() {
    __privateMethod(this, _cleanDrawLayer2, cleanDrawLayer_fn2).call(this);
    super.remove();
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    __privateMethod(this, _addToDrawLayer2, addToDrawLayer_fn2).call(this);
    __privateMethod(this, _updateBbox, updateBbox_fn).call(this, __privateGet(this, _drawOutlines).box);
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  setParent(parent) {
    var _a2;
    let mustBeSelected = false;
    if (this.parent && !parent) {
      this._uiManager.removeShouldRescale(this);
      __privateMethod(this, _cleanDrawLayer2, cleanDrawLayer_fn2).call(this);
    } else if (parent) {
      this._uiManager.addShouldRescale(this);
      __privateMethod(this, _addToDrawLayer2, addToDrawLayer_fn2).call(this, parent);
      mustBeSelected = !this.parent && ((_a2 = this.div) == null ? void 0 : _a2.classList.contains("selectedEditor"));
    }
    super.setParent(parent);
    if (mustBeSelected) {
      this.select();
    }
  }
  rotate() {
    if (!this.parent) {
      return;
    }
    this.parent.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties({
      bbox: __privateMethod(this, _rotateBox, rotateBox_fn).call(this)
    }, __privateGet(this, _drawOutlines).updateRotation((this.parentRotation - this.rotation + 360) % 360)));
  }
  onScaleChanging() {
    if (!this.parent) {
      return;
    }
    __privateMethod(this, _updateBbox, updateBbox_fn).call(this, __privateGet(this, _drawOutlines).updateParentDimensions(this.parentDimensions, this.parent.scale));
  }
  static onScaleChangingWhenDrawing() {
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this._isCopy) {
      baseX = this.x;
      baseY = this.y;
    }
    const div = super.render();
    div.classList.add("draw");
    const drawDiv = document.createElement("div");
    div.append(drawDiv);
    drawDiv.setAttribute("aria-hidden", "true");
    drawDiv.className = "internal";
    this.setDims();
    this._uiManager.addShouldRescale(this);
    this.disableEditing();
    if (this._isCopy) {
      this._moveAfterPaste(baseX, baseY);
    }
    return div;
  }
  static createDrawerInstance(_x, _y, _parentWidth3, _parentHeight3, _rotation4) {
    unreachable("Not implemented");
  }
  static startDrawing(parent, uiManager, _isLTR3, event) {
    var _a2;
    const {
      target,
      offsetX: x,
      offsetY: y,
      pointerId,
      pointerType
    } = event;
    if (__privateGet(_DrawingEditor, _currentPointerType) && __privateGet(_DrawingEditor, _currentPointerType) !== pointerType) {
      return;
    }
    const {
      viewport: {
        rotation
      }
    } = parent;
    const {
      width: parentWidth,
      height: parentHeight
    } = target.getBoundingClientRect();
    const ac = __privateSet(_DrawingEditor, _currentDrawingAC, new AbortController());
    const signal = parent.combinedSignal(ac);
    __privateGet(_DrawingEditor, _currentPointerId) || __privateSet(_DrawingEditor, _currentPointerId, pointerId);
    __privateGet(_DrawingEditor, _currentPointerType) ?? __privateSet(_DrawingEditor, _currentPointerType, pointerType);
    window.addEventListener("pointerup", (e) => {
      var _a3;
      if (__privateGet(_DrawingEditor, _currentPointerId) === e.pointerId) {
        this._endDraw(e);
      } else {
        (_a3 = __privateGet(_DrawingEditor, _currentPointerIds)) == null ? void 0 : _a3.delete(e.pointerId);
      }
    }, {
      signal
    });
    window.addEventListener("pointercancel", (e) => {
      var _a3;
      if (__privateGet(_DrawingEditor, _currentPointerId) === e.pointerId) {
        this._currentParent.endDrawingSession();
      } else {
        (_a3 = __privateGet(_DrawingEditor, _currentPointerIds)) == null ? void 0 : _a3.delete(e.pointerId);
      }
    }, {
      signal
    });
    window.addEventListener("pointerdown", (e) => {
      if (__privateGet(_DrawingEditor, _currentPointerType) !== e.pointerType) {
        return;
      }
      (__privateGet(_DrawingEditor, _currentPointerIds) || __privateSet(_DrawingEditor, _currentPointerIds, /* @__PURE__ */ new Set())).add(e.pointerId);
      if (__privateGet(_DrawingEditor, _currentDraw).isCancellable()) {
        __privateGet(_DrawingEditor, _currentDraw).removeLastElement();
        if (__privateGet(_DrawingEditor, _currentDraw).isEmpty()) {
          this._currentParent.endDrawingSession(true);
        } else {
          this._endDraw(null);
        }
      }
    }, {
      capture: true,
      passive: false,
      signal
    });
    window.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    target.addEventListener("pointermove", this._drawMove.bind(this), {
      signal
    });
    target.addEventListener("touchmove", (e) => {
      if (e.timeStamp === __privateGet(_DrawingEditor, _currentMoveTimestamp)) {
        stopEvent(e);
      }
    }, {
      signal
    });
    parent.toggleDrawing();
    (_a2 = uiManager._editorUndoBar) == null ? void 0 : _a2.hide();
    if (__privateGet(_DrawingEditor, _currentDraw)) {
      parent.drawLayer.updateProperties(this._currentDrawId, __privateGet(_DrawingEditor, _currentDraw).startNew(x, y, parentWidth, parentHeight, rotation));
      return;
    }
    uiManager.updateUIForDefaultProperties(this);
    __privateSet(_DrawingEditor, _currentDraw, this.createDrawerInstance(x, y, parentWidth, parentHeight, rotation));
    __privateSet(_DrawingEditor, _currentDrawingOptions, this.getDefaultDrawingOptions());
    this._currentParent = parent;
    ({
      id: this._currentDrawId
    } = parent.drawLayer.draw(this._mergeSVGProperties(__privateGet(_DrawingEditor, _currentDrawingOptions).toSVGProperties(), __privateGet(_DrawingEditor, _currentDraw).defaultSVGProperties), true, false));
  }
  static _drawMove(event) {
    var _a2;
    __privateSet(_DrawingEditor, _currentMoveTimestamp, -1);
    if (!__privateGet(_DrawingEditor, _currentDraw)) {
      return;
    }
    const {
      offsetX,
      offsetY,
      pointerId
    } = event;
    if (__privateGet(_DrawingEditor, _currentPointerId) !== pointerId) {
      return;
    }
    if (((_a2 = __privateGet(_DrawingEditor, _currentPointerIds)) == null ? void 0 : _a2.size) >= 1) {
      this._endDraw(event);
      return;
    }
    this._currentParent.drawLayer.updateProperties(this._currentDrawId, __privateGet(_DrawingEditor, _currentDraw).add(offsetX, offsetY));
    __privateSet(_DrawingEditor, _currentMoveTimestamp, event.timeStamp);
    stopEvent(event);
  }
  static _cleanup(all) {
    if (all) {
      this._currentDrawId = -1;
      this._currentParent = null;
      __privateSet(_DrawingEditor, _currentDraw, null);
      __privateSet(_DrawingEditor, _currentDrawingOptions, null);
      __privateSet(_DrawingEditor, _currentPointerType, null);
      __privateSet(_DrawingEditor, _currentMoveTimestamp, NaN);
    }
    if (__privateGet(_DrawingEditor, _currentDrawingAC)) {
      __privateGet(_DrawingEditor, _currentDrawingAC).abort();
      __privateSet(_DrawingEditor, _currentDrawingAC, null);
      __privateSet(_DrawingEditor, _currentPointerId, NaN);
      __privateSet(_DrawingEditor, _currentPointerIds, null);
    }
  }
  static _endDraw(event) {
    const parent = this._currentParent;
    if (!parent) {
      return;
    }
    parent.toggleDrawing(true);
    this._cleanup(false);
    if ((event == null ? void 0 : event.target) === parent.div) {
      parent.drawLayer.updateProperties(this._currentDrawId, __privateGet(_DrawingEditor, _currentDraw).end(event.offsetX, event.offsetY));
    }
    if (this.supportMultipleDrawings) {
      const draw = __privateGet(_DrawingEditor, _currentDraw);
      const drawId = this._currentDrawId;
      const lastElement = draw.getLastElement();
      parent.addCommands({
        cmd: () => {
          parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));
        },
        undo: () => {
          parent.drawLayer.updateProperties(drawId, draw.removeLastElement());
        },
        mustExec: false,
        type: AnnotationEditorParamsType.DRAW_STEP
      });
      return;
    }
    this.endDrawing(false);
  }
  static endDrawing(isAborted) {
    const parent = this._currentParent;
    if (!parent) {
      return null;
    }
    parent.toggleDrawing(true);
    parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);
    if (!__privateGet(_DrawingEditor, _currentDraw).isEmpty()) {
      const {
        pageDimensions: [pageWidth, pageHeight],
        scale
      } = parent;
      const editor = parent.createAndAddNewEditor({
        offsetX: 0,
        offsetY: 0
      }, false, {
        drawId: this._currentDrawId,
        drawOutlines: __privateGet(_DrawingEditor, _currentDraw).getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),
        drawingOptions: __privateGet(_DrawingEditor, _currentDrawingOptions),
        mustBeCommitted: !isAborted
      });
      this._cleanup(true);
      return editor;
    }
    parent.drawLayer.remove(this._currentDrawId);
    this._cleanup(true);
    return null;
  }
  createDrawingOptions(_data2) {
  }
  static deserializeDraw(_pageX, _pageY, _pageWidth2, _pageHeight2, _innerWidth, _data2) {
    unreachable("Not implemented");
  }
  static async deserialize(data, parent, uiManager) {
    var _a2, _b;
    const {
      rawDims: {
        pageWidth,
        pageHeight,
        pageX,
        pageY
      }
    } = parent.viewport;
    const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);
    const editor = await super.deserialize(data, parent, uiManager);
    editor.createDrawingOptions(data);
    __privateMethod(_a2 = editor, _createDrawOutlines, createDrawOutlines_fn).call(_a2, {
      drawOutlines
    });
    __privateMethod(_b = editor, _addToDrawLayer2, addToDrawLayer_fn2).call(_b);
    editor.onScaleChanging();
    editor.rotate();
    return editor;
  }
  serializeDraw(isForCopying) {
    const [pageX, pageY] = this.pageTranslation;
    const [pageWidth, pageHeight] = this.pageDimensions;
    return __privateGet(this, _drawOutlines).serialize([pageX, pageY, pageWidth, pageHeight], isForCopying);
  }
  renderAnnotationElement(annotation) {
    annotation.updateEdited({
      rect: this.getPDFRect()
    });
    return null;
  }
  static canCreateNewEmptyEditor() {
    return false;
  }
};
_drawOutlines = new WeakMap();
_mustBeCommitted = new WeakMap();
_currentDraw = new WeakMap();
_currentDrawingAC = new WeakMap();
_currentDrawingOptions = new WeakMap();
_currentPointerId = new WeakMap();
_currentPointerType = new WeakMap();
_currentPointerIds = new WeakMap();
_currentMoveTimestamp = new WeakMap();
_createDrawOutlines = new WeakSet();
createDrawOutlines_fn = function({
  drawOutlines,
  drawId,
  drawingOptions
}) {
  __privateSet(this, _drawOutlines, drawOutlines);
  this._drawingOptions || (this._drawingOptions = drawingOptions);
  if (!this.annotationElementId) {
    this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`);
  }
  if (drawId >= 0) {
    this._drawId = drawId;
    this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);
  } else {
    this._drawId = __privateMethod(this, _createDrawing, createDrawing_fn).call(this, drawOutlines, this.parent);
  }
  __privateMethod(this, _updateBbox, updateBbox_fn).call(this, drawOutlines.box);
};
_createDrawing = new WeakSet();
createDrawing_fn = function(drawOutlines, parent) {
  const {
    id
  } = parent.drawLayer.draw(_DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);
  return id;
};
_cleanDrawLayer2 = new WeakSet();
cleanDrawLayer_fn2 = function() {
  if (this._drawId === null || !this.parent) {
    return;
  }
  this.parent.drawLayer.remove(this._drawId);
  this._drawId = null;
  this._drawingOptions.reset();
};
_addToDrawLayer2 = new WeakSet();
addToDrawLayer_fn2 = function(parent = this.parent) {
  if (this._drawId !== null && this.parent === parent) {
    return;
  }
  if (this._drawId !== null) {
    this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);
    return;
  }
  this._drawingOptions.updateAll();
  this._drawId = __privateMethod(this, _createDrawing, createDrawing_fn).call(this, __privateGet(this, _drawOutlines), parent);
};
_convertToParentSpace = new WeakSet();
convertToParentSpace_fn = function([x, y, width, height]) {
  const {
    parentDimensions: [pW, pH],
    rotation
  } = this;
  switch (rotation) {
    case 90:
      return [y, 1 - x, width * (pH / pW), height * (pW / pH)];
    case 180:
      return [1 - x, 1 - y, width, height];
    case 270:
      return [1 - y, x, width * (pH / pW), height * (pW / pH)];
    default:
      return [x, y, width, height];
  }
};
_convertToDrawSpace = new WeakSet();
convertToDrawSpace_fn = function() {
  const {
    x,
    y,
    width,
    height,
    parentDimensions: [pW, pH],
    rotation
  } = this;
  switch (rotation) {
    case 90:
      return [1 - y, x, width * (pW / pH), height * (pH / pW)];
    case 180:
      return [1 - x, 1 - y, width, height];
    case 270:
      return [y, 1 - x, width * (pW / pH), height * (pH / pW)];
    default:
      return [x, y, width, height];
  }
};
_updateBbox = new WeakSet();
updateBbox_fn = function(bbox) {
  [this.x, this.y, this.width, this.height] = __privateMethod(this, _convertToParentSpace, convertToParentSpace_fn).call(this, bbox);
  if (this.div) {
    this.fixAndSetPosition();
    this.setDims();
  }
  this._onResized();
};
_rotateBox = new WeakSet();
rotateBox_fn = function() {
  const {
    x,
    y,
    width,
    height,
    rotation,
    parentRotation,
    parentDimensions: [pW, pH]
  } = this;
  switch ((rotation * 4 + parentRotation) / 90) {
    case 1:
      return [1 - y - height, x, height, width];
    case 2:
      return [1 - x - width, 1 - y - height, width, height];
    case 3:
      return [y, 1 - x - width, height, width];
    case 4:
      return [x, y - width * (pW / pH), height * (pH / pW), width * (pW / pH)];
    case 5:
      return [1 - y, x, width * (pW / pH), height * (pH / pW)];
    case 6:
      return [1 - x - height * (pH / pW), 1 - y, height * (pH / pW), width * (pW / pH)];
    case 7:
      return [y - width * (pW / pH), 1 - x - height * (pH / pW), width * (pW / pH), height * (pH / pW)];
    case 8:
      return [x - width, y - height, width, height];
    case 9:
      return [1 - y, x - width, height, width];
    case 10:
      return [1 - x, 1 - y, width, height];
    case 11:
      return [y - height, 1 - x, height, width];
    case 12:
      return [x - height * (pH / pW), y, height * (pH / pW), width * (pW / pH)];
    case 13:
      return [1 - y - width * (pW / pH), x - height * (pH / pW), width * (pW / pH), height * (pH / pW)];
    case 14:
      return [1 - x, 1 - y - width * (pW / pH), height * (pH / pW), width * (pW / pH)];
    case 15:
      return [y, 1 - x, width * (pW / pH), height * (pH / pW)];
    default:
      return [x, y, width, height];
  }
};
__publicField(_DrawingEditor, "_currentDrawId", -1);
__publicField(_DrawingEditor, "_currentParent", null);
__privateAdd(_DrawingEditor, _currentDraw, null);
__privateAdd(_DrawingEditor, _currentDrawingAC, null);
__privateAdd(_DrawingEditor, _currentDrawingOptions, null);
__privateAdd(_DrawingEditor, _currentPointerId, NaN);
__privateAdd(_DrawingEditor, _currentPointerType, null);
__privateAdd(_DrawingEditor, _currentPointerIds, null);
__privateAdd(_DrawingEditor, _currentMoveTimestamp, NaN);
__publicField(_DrawingEditor, "_INNER_MARGIN", 3);
var DrawingEditor = _DrawingEditor;
var _last2, _line2, _lines, _rotation2, _thickness3, _points3, _lastSVGPath, _lastIndex, _outlines2, _parentWidth, _parentHeight, _normalizePoint, normalizePoint_fn;
var InkDrawOutliner = class {
  constructor(x, y, parentWidth, parentHeight, rotation, thickness) {
    __privateAdd(this, _normalizePoint);
    __privateAdd(this, _last2, new Float64Array(6));
    __privateAdd(this, _line2, void 0);
    __privateAdd(this, _lines, void 0);
    __privateAdd(this, _rotation2, void 0);
    __privateAdd(this, _thickness3, void 0);
    __privateAdd(this, _points3, void 0);
    __privateAdd(this, _lastSVGPath, "");
    __privateAdd(this, _lastIndex, 0);
    __privateAdd(this, _outlines2, new InkDrawOutline());
    __privateAdd(this, _parentWidth, void 0);
    __privateAdd(this, _parentHeight, void 0);
    __privateSet(this, _parentWidth, parentWidth);
    __privateSet(this, _parentHeight, parentHeight);
    __privateSet(this, _rotation2, rotation);
    __privateSet(this, _thickness3, thickness);
    [x, y] = __privateMethod(this, _normalizePoint, normalizePoint_fn).call(this, x, y);
    const line = __privateSet(this, _line2, [NaN, NaN, NaN, NaN, x, y]);
    __privateSet(this, _points3, [x, y]);
    __privateSet(this, _lines, [{
      line,
      points: __privateGet(this, _points3)
    }]);
    __privateGet(this, _last2).set(line, 0);
  }
  updateProperty(name, value) {
    if (name === "stroke-width") {
      __privateSet(this, _thickness3, value);
    }
  }
  isEmpty() {
    return !__privateGet(this, _lines) || __privateGet(this, _lines).length === 0;
  }
  isCancellable() {
    return __privateGet(this, _points3).length <= 10;
  }
  add(x, y) {
    [x, y] = __privateMethod(this, _normalizePoint, normalizePoint_fn).call(this, x, y);
    const [x1, y1, x2, y2] = __privateGet(this, _last2).subarray(2, 6);
    const diffX = x - x2;
    const diffY = y - y2;
    const d = Math.hypot(__privateGet(this, _parentWidth) * diffX, __privateGet(this, _parentHeight) * diffY);
    if (d <= 2) {
      return null;
    }
    __privateGet(this, _points3).push(x, y);
    if (isNaN(x1)) {
      __privateGet(this, _last2).set([x2, y2, x, y], 2);
      __privateGet(this, _line2).push(NaN, NaN, NaN, NaN, x, y);
      return {
        path: {
          d: this.toSVGPath()
        }
      };
    }
    if (isNaN(__privateGet(this, _last2)[0])) {
      __privateGet(this, _line2).splice(6, 6);
    }
    __privateGet(this, _last2).set([x1, y1, x2, y2, x, y], 0);
    __privateGet(this, _line2).push(...Outline.createBezierPoints(x1, y1, x2, y2, x, y));
    return {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  end(x, y) {
    const change = this.add(x, y);
    if (change) {
      return change;
    }
    if (__privateGet(this, _points3).length === 2) {
      return {
        path: {
          d: this.toSVGPath()
        }
      };
    }
    return null;
  }
  startNew(x, y, parentWidth, parentHeight, rotation) {
    __privateSet(this, _parentWidth, parentWidth);
    __privateSet(this, _parentHeight, parentHeight);
    __privateSet(this, _rotation2, rotation);
    [x, y] = __privateMethod(this, _normalizePoint, normalizePoint_fn).call(this, x, y);
    const line = __privateSet(this, _line2, [NaN, NaN, NaN, NaN, x, y]);
    __privateSet(this, _points3, [x, y]);
    const last = __privateGet(this, _lines).at(-1);
    if (last) {
      last.line = new Float32Array(last.line);
      last.points = new Float32Array(last.points);
    }
    __privateGet(this, _lines).push({
      line,
      points: __privateGet(this, _points3)
    });
    __privateGet(this, _last2).set(line, 0);
    __privateSet(this, _lastIndex, 0);
    this.toSVGPath();
    return null;
  }
  getLastElement() {
    return __privateGet(this, _lines).at(-1);
  }
  setLastElement(element) {
    if (!__privateGet(this, _lines)) {
      return __privateGet(this, _outlines2).setLastElement(element);
    }
    __privateGet(this, _lines).push(element);
    __privateSet(this, _line2, element.line);
    __privateSet(this, _points3, element.points);
    __privateSet(this, _lastIndex, 0);
    return {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  removeLastElement() {
    if (!__privateGet(this, _lines)) {
      return __privateGet(this, _outlines2).removeLastElement();
    }
    __privateGet(this, _lines).pop();
    __privateSet(this, _lastSVGPath, "");
    for (let i = 0, ii = __privateGet(this, _lines).length; i < ii; i++) {
      const {
        line,
        points
      } = __privateGet(this, _lines)[i];
      __privateSet(this, _line2, line);
      __privateSet(this, _points3, points);
      __privateSet(this, _lastIndex, 0);
      this.toSVGPath();
    }
    return {
      path: {
        d: __privateGet(this, _lastSVGPath)
      }
    };
  }
  toSVGPath() {
    const firstX = Outline.svgRound(__privateGet(this, _line2)[4]);
    const firstY = Outline.svgRound(__privateGet(this, _line2)[5]);
    if (__privateGet(this, _points3).length === 2) {
      __privateSet(this, _lastSVGPath, `${__privateGet(this, _lastSVGPath)} M ${firstX} ${firstY} Z`);
      return __privateGet(this, _lastSVGPath);
    }
    if (__privateGet(this, _points3).length <= 6) {
      const i = __privateGet(this, _lastSVGPath).lastIndexOf("M");
      __privateSet(this, _lastSVGPath, `${__privateGet(this, _lastSVGPath).slice(0, i)} M ${firstX} ${firstY}`);
      __privateSet(this, _lastIndex, 6);
    }
    if (__privateGet(this, _points3).length === 4) {
      const secondX = Outline.svgRound(__privateGet(this, _line2)[10]);
      const secondY = Outline.svgRound(__privateGet(this, _line2)[11]);
      __privateSet(this, _lastSVGPath, `${__privateGet(this, _lastSVGPath)} L ${secondX} ${secondY}`);
      __privateSet(this, _lastIndex, 12);
      return __privateGet(this, _lastSVGPath);
    }
    const buffer = [];
    if (__privateGet(this, _lastIndex) === 0) {
      buffer.push(`M ${firstX} ${firstY}`);
      __privateSet(this, _lastIndex, 6);
    }
    for (let i = __privateGet(this, _lastIndex), ii = __privateGet(this, _line2).length; i < ii; i += 6) {
      const [c1x, c1y, c2x, c2y, x, y] = __privateGet(this, _line2).slice(i, i + 6).map(Outline.svgRound);
      buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);
    }
    __privateSet(this, _lastSVGPath, __privateGet(this, _lastSVGPath) + buffer.join(" "));
    __privateSet(this, _lastIndex, __privateGet(this, _line2).length);
    return __privateGet(this, _lastSVGPath);
  }
  getOutlines(parentWidth, parentHeight, scale, innerMargin) {
    const last = __privateGet(this, _lines).at(-1);
    last.line = new Float32Array(last.line);
    last.points = new Float32Array(last.points);
    __privateGet(this, _outlines2).build(__privateGet(this, _lines), parentWidth, parentHeight, scale, __privateGet(this, _rotation2), __privateGet(this, _thickness3), innerMargin);
    __privateSet(this, _last2, null);
    __privateSet(this, _line2, null);
    __privateSet(this, _lines, null);
    __privateSet(this, _lastSVGPath, null);
    return __privateGet(this, _outlines2);
  }
  get defaultSVGProperties() {
    return {
      root: {
        viewBox: "0 0 10000 10000"
      },
      rootClass: {
        draw: true
      },
      bbox: [0, 0, 1, 1]
    };
  }
};
_last2 = new WeakMap();
_line2 = new WeakMap();
_lines = new WeakMap();
_rotation2 = new WeakMap();
_thickness3 = new WeakMap();
_points3 = new WeakMap();
_lastSVGPath = new WeakMap();
_lastIndex = new WeakMap();
_outlines2 = new WeakMap();
_parentWidth = new WeakMap();
_parentHeight = new WeakMap();
_normalizePoint = new WeakSet();
normalizePoint_fn = function(x, y) {
  return Outline._normalizePoint(x, y, __privateGet(this, _parentWidth), __privateGet(this, _parentHeight), __privateGet(this, _rotation2));
};
var _bbox2, _currentRotation, _innerMargin3, _lines2, _parentWidth2, _parentHeight2, _parentScale, _rotation3, _thickness4, _getMarginComponents, getMarginComponents_fn, _getBBoxWithNoMargin, getBBoxWithNoMargin_fn, _computeBbox, computeBbox_fn, _updateThickness2, updateThickness_fn2;
var InkDrawOutline = class extends Outline {
  constructor() {
    super(...arguments);
    __privateAdd(this, _getMarginComponents);
    __privateAdd(this, _getBBoxWithNoMargin);
    __privateAdd(this, _computeBbox);
    __privateAdd(this, _updateThickness2);
    __privateAdd(this, _bbox2, void 0);
    __privateAdd(this, _currentRotation, 0);
    __privateAdd(this, _innerMargin3, void 0);
    __privateAdd(this, _lines2, void 0);
    __privateAdd(this, _parentWidth2, void 0);
    __privateAdd(this, _parentHeight2, void 0);
    __privateAdd(this, _parentScale, void 0);
    __privateAdd(this, _rotation3, void 0);
    __privateAdd(this, _thickness4, void 0);
  }
  build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {
    __privateSet(this, _parentWidth2, parentWidth);
    __privateSet(this, _parentHeight2, parentHeight);
    __privateSet(this, _parentScale, parentScale);
    __privateSet(this, _rotation3, rotation);
    __privateSet(this, _thickness4, thickness);
    __privateSet(this, _innerMargin3, innerMargin ?? 0);
    __privateSet(this, _lines2, lines);
    __privateMethod(this, _computeBbox, computeBbox_fn).call(this);
  }
  get thickness() {
    return __privateGet(this, _thickness4);
  }
  setLastElement(element) {
    __privateGet(this, _lines2).push(element);
    return {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  removeLastElement() {
    __privateGet(this, _lines2).pop();
    return {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  toSVGPath() {
    const buffer = [];
    for (const {
      line
    } of __privateGet(this, _lines2)) {
      buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);
      if (line.length === 6) {
        buffer.push("Z");
        continue;
      }
      if (line.length === 12 && isNaN(line[6])) {
        buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);
        continue;
      }
      for (let i = 6, ii = line.length; i < ii; i += 6) {
        const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6).map(Outline.svgRound);
        buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);
      }
    }
    return buffer.join("");
  }
  serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {
    const serializedLines = [];
    const serializedPoints = [];
    const [x, y, width, height] = __privateMethod(this, _getBBoxWithNoMargin, getBBoxWithNoMargin_fn).call(this);
    let tx, ty, sx, sy, x1, y1, x2, y2, rescaleFn;
    switch (__privateGet(this, _rotation3)) {
      case 0:
        rescaleFn = Outline._rescale;
        tx = pageX;
        ty = pageY + pageHeight;
        sx = pageWidth;
        sy = -pageHeight;
        x1 = pageX + x * pageWidth;
        y1 = pageY + (1 - y - height) * pageHeight;
        x2 = pageX + (x + width) * pageWidth;
        y2 = pageY + (1 - y) * pageHeight;
        break;
      case 90:
        rescaleFn = Outline._rescaleAndSwap;
        tx = pageX;
        ty = pageY;
        sx = pageWidth;
        sy = pageHeight;
        x1 = pageX + y * pageWidth;
        y1 = pageY + x * pageHeight;
        x2 = pageX + (y + height) * pageWidth;
        y2 = pageY + (x + width) * pageHeight;
        break;
      case 180:
        rescaleFn = Outline._rescale;
        tx = pageX + pageWidth;
        ty = pageY;
        sx = -pageWidth;
        sy = pageHeight;
        x1 = pageX + (1 - x - width) * pageWidth;
        y1 = pageY + y * pageHeight;
        x2 = pageX + (1 - x) * pageWidth;
        y2 = pageY + (y + height) * pageHeight;
        break;
      case 270:
        rescaleFn = Outline._rescaleAndSwap;
        tx = pageX + pageWidth;
        ty = pageY + pageHeight;
        sx = -pageWidth;
        sy = -pageHeight;
        x1 = pageX + (1 - y - height) * pageWidth;
        y1 = pageY + (1 - x - width) * pageHeight;
        x2 = pageX + (1 - y) * pageWidth;
        y2 = pageY + (1 - x) * pageHeight;
        break;
    }
    for (const {
      line,
      points
    } of __privateGet(this, _lines2)) {
      serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));
      serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));
    }
    return {
      lines: serializedLines,
      points: serializedPoints,
      rect: [x1, y1, x2, y2]
    };
  }
  static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, {
    paths: {
      lines,
      points
    },
    rotation,
    thickness
  }) {
    const newLines = [];
    let tx, ty, sx, sy, rescaleFn;
    switch (rotation) {
      case 0:
        rescaleFn = Outline._rescale;
        tx = -pageX / pageWidth;
        ty = pageY / pageHeight + 1;
        sx = 1 / pageWidth;
        sy = -1 / pageHeight;
        break;
      case 90:
        rescaleFn = Outline._rescaleAndSwap;
        tx = -pageY / pageHeight;
        ty = -pageX / pageWidth;
        sx = 1 / pageHeight;
        sy = 1 / pageWidth;
        break;
      case 180:
        rescaleFn = Outline._rescale;
        tx = pageX / pageWidth + 1;
        ty = -pageY / pageHeight;
        sx = -1 / pageWidth;
        sy = 1 / pageHeight;
        break;
      case 270:
        rescaleFn = Outline._rescaleAndSwap;
        tx = pageY / pageHeight + 1;
        ty = pageX / pageWidth + 1;
        sx = -1 / pageHeight;
        sy = -1 / pageWidth;
        break;
    }
    if (!lines) {
      lines = [];
      for (const point of points) {
        const len = point.length;
        if (len === 2) {
          lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1]]));
          continue;
        }
        if (len === 4) {
          lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1], NaN, NaN, NaN, NaN, point[2], point[3]]));
          continue;
        }
        const line = new Float32Array(3 * (len - 2));
        lines.push(line);
        let [x1, y1, x2, y2] = point.subarray(0, 4);
        line.set([NaN, NaN, NaN, NaN, x1, y1], 0);
        for (let i = 4; i < len; i += 2) {
          const x = point[i];
          const y = point[i + 1];
          line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);
          [x1, y1, x2, y2] = [x2, y2, x, y];
        }
      }
    }
    for (let i = 0, ii = lines.length; i < ii; i++) {
      newLines.push({
        line: rescaleFn(lines[i].map((x) => x ?? NaN), tx, ty, sx, sy),
        points: rescaleFn(points[i].map((x) => x ?? NaN), tx, ty, sx, sy)
      });
    }
    const outlines = new this.prototype.constructor();
    outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);
    return outlines;
  }
  get box() {
    return __privateGet(this, _bbox2);
  }
  updateProperty(name, value) {
    if (name === "stroke-width") {
      return __privateMethod(this, _updateThickness2, updateThickness_fn2).call(this, value);
    }
    return null;
  }
  updateParentDimensions([width, height], scale) {
    const [oldMarginX, oldMarginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this);
    __privateSet(this, _parentWidth2, width);
    __privateSet(this, _parentHeight2, height);
    __privateSet(this, _parentScale, scale);
    const [newMarginX, newMarginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this);
    const diffMarginX = newMarginX - oldMarginX;
    const diffMarginY = newMarginY - oldMarginY;
    const bbox = __privateGet(this, _bbox2);
    bbox[0] -= diffMarginX;
    bbox[1] -= diffMarginY;
    bbox[2] += 2 * diffMarginX;
    bbox[3] += 2 * diffMarginY;
    return bbox;
  }
  updateRotation(rotation) {
    __privateSet(this, _currentRotation, rotation);
    return {
      path: {
        transform: this.rotationTransform
      }
    };
  }
  get viewBox() {
    return __privateGet(this, _bbox2).map(Outline.svgRound).join(" ");
  }
  get defaultProperties() {
    const [x, y] = __privateGet(this, _bbox2);
    return {
      root: {
        viewBox: this.viewBox
      },
      path: {
        "transform-origin": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`
      }
    };
  }
  get rotationTransform() {
    const [, , width, height] = __privateGet(this, _bbox2);
    let a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;
    switch (__privateGet(this, _currentRotation)) {
      case 90:
        b = height / width;
        c = -width / height;
        e = width;
        break;
      case 180:
        a = -1;
        d = -1;
        e = width;
        f = height;
        break;
      case 270:
        b = -height / width;
        c = width / height;
        f = height;
        break;
      default:
        return "";
    }
    return `matrix(${a} ${b} ${c} ${d} ${Outline.svgRound(e)} ${Outline.svgRound(f)})`;
  }
  getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {
    const [marginX, marginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this);
    const [x, y, width, height] = __privateGet(this, _bbox2);
    if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {
      const tx = newX + newWidth / 2 - (x + width / 2);
      const ty = newY + newHeight / 2 - (y + height / 2);
      return {
        path: {
          "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
          transform: `${this.rotationTransform} translate(${tx} ${ty})`
        }
      };
    }
    const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);
    const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);
    const s2x = width / newWidth;
    const s2y = height / newHeight;
    return {
      path: {
        "transform-origin": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`,
        transform: `${this.rotationTransform} scale(${s2x} ${s2y}) translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`
      }
    };
  }
  getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {
    const [marginX, marginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this);
    const bbox = __privateGet(this, _bbox2);
    const [x, y, width, height] = bbox;
    bbox[0] = newX;
    bbox[1] = newY;
    bbox[2] = newWidth;
    bbox[3] = newHeight;
    if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {
      const tx2 = newX + newWidth / 2 - (x + width / 2);
      const ty2 = newY + newHeight / 2 - (y + height / 2);
      for (const {
        line,
        points
      } of __privateGet(this, _lines2)) {
        Outline._translate(line, tx2, ty2, line);
        Outline._translate(points, tx2, ty2, points);
      }
      return {
        root: {
          viewBox: this.viewBox
        },
        path: {
          "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
          transform: this.rotationTransform || null,
          d: this.toSVGPath()
        }
      };
    }
    const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);
    const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);
    const tx = -s1x * (x + marginX) + newX + marginX;
    const ty = -s1y * (y + marginY) + newY + marginY;
    if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) {
      for (const {
        line,
        points
      } of __privateGet(this, _lines2)) {
        Outline._rescale(line, tx, ty, s1x, s1y, line);
        Outline._rescale(points, tx, ty, s1x, s1y, points);
      }
    }
    return {
      root: {
        viewBox: this.viewBox
      },
      path: {
        "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
        transform: this.rotationTransform || null,
        d: this.toSVGPath()
      }
    };
  }
  getPathTranslatedSVGProperties([newX, newY], parentDimensions) {
    const [newParentWidth, newParentHeight] = parentDimensions;
    const bbox = __privateGet(this, _bbox2);
    const tx = newX - bbox[0];
    const ty = newY - bbox[1];
    if (__privateGet(this, _parentWidth2) === newParentWidth && __privateGet(this, _parentHeight2) === newParentHeight) {
      for (const {
        line,
        points
      } of __privateGet(this, _lines2)) {
        Outline._translate(line, tx, ty, line);
        Outline._translate(points, tx, ty, points);
      }
    } else {
      const sx = __privateGet(this, _parentWidth2) / newParentWidth;
      const sy = __privateGet(this, _parentHeight2) / newParentHeight;
      __privateSet(this, _parentWidth2, newParentWidth);
      __privateSet(this, _parentHeight2, newParentHeight);
      for (const {
        line,
        points
      } of __privateGet(this, _lines2)) {
        Outline._rescale(line, tx, ty, sx, sy, line);
        Outline._rescale(points, tx, ty, sx, sy, points);
      }
      bbox[2] *= sx;
      bbox[3] *= sy;
    }
    bbox[0] = newX;
    bbox[1] = newY;
    return {
      root: {
        viewBox: this.viewBox
      },
      path: {
        d: this.toSVGPath(),
        "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`
      }
    };
  }
  get defaultSVGProperties() {
    const bbox = __privateGet(this, _bbox2);
    return {
      root: {
        viewBox: this.viewBox
      },
      rootClass: {
        draw: true
      },
      path: {
        d: this.toSVGPath(),
        "transform-origin": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,
        transform: this.rotationTransform || null
      },
      bbox
    };
  }
};
_bbox2 = new WeakMap();
_currentRotation = new WeakMap();
_innerMargin3 = new WeakMap();
_lines2 = new WeakMap();
_parentWidth2 = new WeakMap();
_parentHeight2 = new WeakMap();
_parentScale = new WeakMap();
_rotation3 = new WeakMap();
_thickness4 = new WeakMap();
_getMarginComponents = new WeakSet();
getMarginComponents_fn = function(thickness = __privateGet(this, _thickness4)) {
  const margin = __privateGet(this, _innerMargin3) + thickness / 2 * __privateGet(this, _parentScale);
  return __privateGet(this, _rotation3) % 180 === 0 ? [margin / __privateGet(this, _parentWidth2), margin / __privateGet(this, _parentHeight2)] : [margin / __privateGet(this, _parentHeight2), margin / __privateGet(this, _parentWidth2)];
};
_getBBoxWithNoMargin = new WeakSet();
getBBoxWithNoMargin_fn = function() {
  const [x, y, width, height] = __privateGet(this, _bbox2);
  const [marginX, marginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this, 0);
  return [x + marginX, y + marginY, width - 2 * marginX, height - 2 * marginY];
};
_computeBbox = new WeakSet();
computeBbox_fn = function() {
  const bbox = __privateSet(this, _bbox2, new Float32Array([Infinity, Infinity, -Infinity, -Infinity]));
  for (const {
    line
  } of __privateGet(this, _lines2)) {
    if (line.length <= 12) {
      for (let i = 4, ii = line.length; i < ii; i += 6) {
        Util.pointBoundingBox(line[i], line[i + 1], bbox);
      }
      continue;
    }
    let lastX = line[4], lastY = line[5];
    for (let i = 6, ii = line.length; i < ii; i += 6) {
      const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6);
      Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x, y, bbox);
      lastX = x;
      lastY = y;
    }
  }
  const [marginX, marginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this);
  bbox[0] = MathClamp(bbox[0] - marginX, 0, 1);
  bbox[1] = MathClamp(bbox[1] - marginY, 0, 1);
  bbox[2] = MathClamp(bbox[2] + marginX, 0, 1);
  bbox[3] = MathClamp(bbox[3] + marginY, 0, 1);
  bbox[2] -= bbox[0];
  bbox[3] -= bbox[1];
};
_updateThickness2 = new WeakSet();
updateThickness_fn2 = function(thickness) {
  const [oldMarginX, oldMarginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this);
  __privateSet(this, _thickness4, thickness);
  const [newMarginX, newMarginY] = __privateMethod(this, _getMarginComponents, getMarginComponents_fn).call(this);
  const [diffMarginX, diffMarginY] = [newMarginX - oldMarginX, newMarginY - oldMarginY];
  const bbox = __privateGet(this, _bbox2);
  bbox[0] -= diffMarginX;
  bbox[1] -= diffMarginY;
  bbox[2] += 2 * diffMarginX;
  bbox[3] += 2 * diffMarginY;
  return bbox;
};
var InkDrawingOptions = class _InkDrawingOptions extends DrawingOptions {
  constructor(viewerParameters) {
    super();
    this._viewParameters = viewerParameters;
    super.updateProperties({
      fill: "none",
      stroke: AnnotationEditor._defaultLineColor,
      "stroke-opacity": 1,
      "stroke-width": 1,
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-miterlimit": 10
    });
  }
  updateSVGProperty(name, value) {
    if (name === "stroke-width") {
      value ?? (value = this["stroke-width"]);
      value *= this._viewParameters.realScale;
    }
    super.updateSVGProperty(name, value);
  }
  clone() {
    const clone = new _InkDrawingOptions(this._viewParameters);
    clone.updateAll(this);
    return clone;
  }
};
var _hasElementChanged3, hasElementChanged_fn3;
var _InkEditor = class _InkEditor extends DrawingEditor {
  constructor(params) {
    super({
      ...params,
      name: "inkEditor"
    });
    __privateAdd(this, _hasElementChanged3);
    this._willKeepAspectRatio = true;
    this.defaultL10nId = "pdfjs-editor-ink-editor";
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
    this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);
  }
  static getDefaultDrawingOptions(options) {
    const clone = this._defaultDrawingOptions.clone();
    clone.updateProperties(options);
    return clone;
  }
  static get supportMultipleDrawings() {
    return true;
  }
  static get typesMap() {
    return shadow(this, "typesMap", /* @__PURE__ */ new Map([[AnnotationEditorParamsType.INK_THICKNESS, "stroke-width"], [AnnotationEditorParamsType.INK_COLOR, "stroke"], [AnnotationEditorParamsType.INK_OPACITY, "stroke-opacity"]]));
  }
  static createDrawerInstance(x, y, parentWidth, parentHeight, rotation) {
    return new InkDrawOutliner(x, y, parentWidth, parentHeight, rotation, this._defaultDrawingOptions["stroke-width"]);
  }
  static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {
    return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
  }
  static async deserialize(data, parent, uiManager) {
    let initialData = null;
    if (data instanceof InkAnnotationElement) {
      const {
        data: {
          inkLists,
          rect,
          rotation,
          id,
          color,
          opacity,
          borderStyle: {
            rawWidth: thickness
          },
          popupRef,
          richText,
          contentsObj,
          creationDate,
          modificationDate
        },
        parent: {
          page: {
            pageNumber
          }
        }
      } = data;
      initialData = data = {
        annotationType: AnnotationEditorType.INK,
        color: Array.from(color),
        thickness,
        opacity,
        paths: {
          points: inkLists
        },
        boxes: null,
        pageIndex: pageNumber - 1,
        rect: rect.slice(0),
        rotation,
        annotationElementId: id,
        id,
        deleted: false,
        popupRef,
        richText,
        comment: (contentsObj == null ? void 0 : contentsObj.str) || null,
        creationDate,
        modificationDate
      };
    }
    const editor = await super.deserialize(data, parent, uiManager);
    editor._initialData = initialData;
    if (data.comment) {
      editor.setCommentData(data);
    }
    return editor;
  }
  get toolbarButtons() {
    this._colorPicker || (this._colorPicker = new BasicColorPicker(this));
    return [["colorPicker", this._colorPicker]];
  }
  get colorType() {
    return AnnotationEditorParamsType.INK_COLOR;
  }
  get color() {
    return this._drawingOptions.stroke;
  }
  get opacity() {
    return this._drawingOptions["stroke-opacity"];
  }
  onScaleChanging() {
    if (!this.parent) {
      return;
    }
    super.onScaleChanging();
    const {
      _drawId,
      _drawingOptions,
      parent
    } = this;
    _drawingOptions.updateSVGProperty("stroke-width");
    parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());
  }
  static onScaleChangingWhenDrawing() {
    const parent = this._currentParent;
    if (!parent) {
      return;
    }
    super.onScaleChangingWhenDrawing();
    this._defaultDrawingOptions.updateSVGProperty("stroke-width");
    parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
  }
  createDrawingOptions({
    color,
    thickness,
    opacity
  }) {
    this._drawingOptions = _InkEditor.getDefaultDrawingOptions({
      stroke: Util.makeHexColor(...color),
      "stroke-width": thickness,
      "stroke-opacity": opacity
    });
  }
  serialize(isForCopying = false) {
    if (this.isEmpty()) {
      return null;
    }
    if (this.deleted) {
      return this.serializeDeleted();
    }
    const {
      lines,
      points
    } = this.serializeDraw(isForCopying);
    const {
      _drawingOptions: {
        stroke,
        "stroke-opacity": opacity,
        "stroke-width": thickness
      }
    } = this;
    const serialized = Object.assign(super.serialize(isForCopying), {
      color: AnnotationEditor._colorManager.convert(stroke),
      opacity,
      thickness,
      paths: {
        lines,
        points
      }
    });
    this.addComment(serialized);
    if (isForCopying) {
      serialized.isCopy = true;
      return serialized;
    }
    if (this.annotationElementId && !__privateMethod(this, _hasElementChanged3, hasElementChanged_fn3).call(this, serialized)) {
      return null;
    }
    serialized.id = this.annotationElementId;
    return serialized;
  }
  renderAnnotationElement(annotation) {
    if (this.deleted) {
      annotation.hide();
      return null;
    }
    const {
      points,
      rect
    } = this.serializeDraw(false);
    annotation.updateEdited({
      rect,
      thickness: this._drawingOptions["stroke-width"],
      points,
      popup: this.comment
    });
    return null;
  }
};
_hasElementChanged3 = new WeakSet();
hasElementChanged_fn3 = function(serialized) {
  const {
    color,
    thickness,
    opacity,
    pageIndex
  } = this._initialData;
  return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c, i) => c !== color[i]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;
};
__publicField(_InkEditor, "_type", "ink");
__publicField(_InkEditor, "_editorType", AnnotationEditorType.INK);
__publicField(_InkEditor, "_defaultDrawingOptions", null);
var InkEditor = _InkEditor;
var ContourDrawOutline = class extends InkDrawOutline {
  toSVGPath() {
    let path = super.toSVGPath();
    if (!path.endsWith("Z")) {
      path += "Z";
    }
    return path;
  }
};
var BASE_HEADER_LENGTH = 8;
var POINTS_PROPERTIES_NUMBER = 3;
var _PARAMETERS, _neighborIndexToId, neighborIndexToId_fn, _neighborIdToIndex, _clockwiseNonZero, clockwiseNonZero_fn, _counterClockwiseNonZero, counterClockwiseNonZero_fn, _findContours, findContours_fn, _douglasPeuckerHelper, douglasPeuckerHelper_fn, _douglasPeucker, douglasPeucker_fn, _bilateralFilter, bilateralFilter_fn, _getHistogram, getHistogram_fn, _toUint8, toUint8_fn, _guessThreshold, guessThreshold_fn, _getGrayPixels, getGrayPixels_fn;
var SignatureExtractor = class {
  static extractContoursFromText(text, {
    fontFamily,
    fontStyle,
    fontWeight
  }, pageWidth, pageHeight, rotation, innerMargin) {
    let canvas = new OffscreenCanvas(1, 1);
    let ctx = canvas.getContext("2d", {
      alpha: false
    });
    const fontSize = 200;
    const font = ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
    const {
      actualBoundingBoxLeft,
      actualBoundingBoxRight,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent,
      fontBoundingBoxAscent,
      fontBoundingBoxDescent,
      width
    } = ctx.measureText(text);
    const SCALE = 1.5;
    const canvasWidth = Math.ceil(Math.max(Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) || 0, width) * SCALE);
    const canvasHeight = Math.ceil(Math.max(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent) || fontSize, Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || fontSize) * SCALE);
    canvas = new OffscreenCanvas(canvasWidth, canvasHeight);
    ctx = canvas.getContext("2d", {
      alpha: true,
      willReadFrequently: true
    });
    ctx.font = font;
    ctx.filter = "grayscale(1)";
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    ctx.fillStyle = "black";
    ctx.fillText(text, canvasWidth * (SCALE - 1) / 2, canvasHeight * (3 - SCALE) / 2);
    const uint8Buf = __privateMethod(this, _toUint8, toUint8_fn).call(this, ctx.getImageData(0, 0, canvasWidth, canvasHeight).data);
    const histogram = __privateMethod(this, _getHistogram, getHistogram_fn).call(this, uint8Buf);
    const threshold = __privateMethod(this, _guessThreshold, guessThreshold_fn).call(this, histogram);
    const contourList = __privateMethod(this, _findContours, findContours_fn).call(this, uint8Buf, canvasWidth, canvasHeight, threshold);
    return this.processDrawnLines({
      lines: {
        curves: contourList,
        width: canvasWidth,
        height: canvasHeight
      },
      pageWidth,
      pageHeight,
      rotation,
      innerMargin,
      mustSmooth: true,
      areContours: true
    });
  }
  static process(bitmap, pageWidth, pageHeight, rotation, innerMargin) {
    const [uint8Buf, width, height] = __privateMethod(this, _getGrayPixels, getGrayPixels_fn).call(this, bitmap);
    const [buffer, histogram] = __privateMethod(this, _bilateralFilter, bilateralFilter_fn).call(this, uint8Buf, width, height, Math.hypot(width, height) * __privateGet(this, _PARAMETERS).sigmaSFactor, __privateGet(this, _PARAMETERS).sigmaR, __privateGet(this, _PARAMETERS).kernelSize);
    const threshold = __privateMethod(this, _guessThreshold, guessThreshold_fn).call(this, histogram);
    const contourList = __privateMethod(this, _findContours, findContours_fn).call(this, buffer, width, height, threshold);
    return this.processDrawnLines({
      lines: {
        curves: contourList,
        width,
        height
      },
      pageWidth,
      pageHeight,
      rotation,
      innerMargin,
      mustSmooth: true,
      areContours: true
    });
  }
  static processDrawnLines({
    lines,
    pageWidth,
    pageHeight,
    rotation,
    innerMargin,
    mustSmooth,
    areContours
  }) {
    if (rotation % 180 !== 0) {
      [pageWidth, pageHeight] = [pageHeight, pageWidth];
    }
    const {
      curves,
      width,
      height
    } = lines;
    const thickness = lines.thickness ?? 0;
    const linesAndPoints = [];
    const ratio = Math.min(pageWidth / width, pageHeight / height);
    const xScale = ratio / pageWidth;
    const yScale = ratio / pageHeight;
    const newCurves = [];
    for (const {
      points
    } of curves) {
      const reducedPoints = mustSmooth ? __privateMethod(this, _douglasPeucker, douglasPeucker_fn).call(this, points) : points;
      if (!reducedPoints) {
        continue;
      }
      newCurves.push(reducedPoints);
      const len = reducedPoints.length;
      const newPoints = new Float32Array(len);
      const line = new Float32Array(3 * (len === 2 ? 2 : len - 2));
      linesAndPoints.push({
        line,
        points: newPoints
      });
      if (len === 2) {
        newPoints[0] = reducedPoints[0] * xScale;
        newPoints[1] = reducedPoints[1] * yScale;
        line.set([NaN, NaN, NaN, NaN, newPoints[0], newPoints[1]], 0);
        continue;
      }
      let [x1, y1, x2, y2] = reducedPoints;
      x1 *= xScale;
      y1 *= yScale;
      x2 *= xScale;
      y2 *= yScale;
      newPoints.set([x1, y1, x2, y2], 0);
      line.set([NaN, NaN, NaN, NaN, x1, y1], 0);
      for (let i = 4; i < len; i += 2) {
        const x = newPoints[i] = reducedPoints[i] * xScale;
        const y = newPoints[i + 1] = reducedPoints[i + 1] * yScale;
        line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);
        [x1, y1, x2, y2] = [x2, y2, x, y];
      }
    }
    if (linesAndPoints.length === 0) {
      return null;
    }
    const outline = areContours ? new ContourDrawOutline() : new InkDrawOutline();
    outline.build(linesAndPoints, pageWidth, pageHeight, 1, rotation, areContours ? 0 : thickness, innerMargin);
    return {
      outline,
      newCurves,
      areContours,
      thickness,
      width,
      height
    };
  }
  static async compressSignature({
    outlines,
    areContours,
    thickness,
    width,
    height
  }) {
    let minDiff = Infinity;
    let maxDiff = -Infinity;
    let outlinesLength = 0;
    for (const points of outlines) {
      outlinesLength += points.length;
      for (let i = 2, ii = points.length; i < ii; i++) {
        const dx = points[i] - points[i - 2];
        minDiff = Math.min(minDiff, dx);
        maxDiff = Math.max(maxDiff, dx);
      }
    }
    let bufferType;
    if (minDiff >= -128 && maxDiff <= 127) {
      bufferType = Int8Array;
    } else if (minDiff >= -32768 && maxDiff <= 32767) {
      bufferType = Int16Array;
    } else {
      bufferType = Int32Array;
    }
    const len = outlines.length;
    const headerLength = BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * len;
    const header = new Uint32Array(headerLength);
    let offset = 0;
    header[offset++] = headerLength * Uint32Array.BYTES_PER_ELEMENT + (outlinesLength - 2 * len) * bufferType.BYTES_PER_ELEMENT;
    header[offset++] = 0;
    header[offset++] = width;
    header[offset++] = height;
    header[offset++] = areContours ? 0 : 1;
    header[offset++] = Math.max(0, Math.floor(thickness ?? 0));
    header[offset++] = len;
    header[offset++] = bufferType.BYTES_PER_ELEMENT;
    for (const points of outlines) {
      header[offset++] = points.length - 2;
      header[offset++] = points[0];
      header[offset++] = points[1];
    }
    const cs = new CompressionStream("deflate-raw");
    const writer = cs.writable.getWriter();
    await writer.ready;
    writer.write(header);
    const BufferCtor = bufferType.prototype.constructor;
    for (const points of outlines) {
      const diffs = new BufferCtor(points.length - 2);
      for (let i = 2, ii = points.length; i < ii; i++) {
        diffs[i - 2] = points[i] - points[i - 2];
      }
      writer.write(diffs);
    }
    writer.close();
    const buf = await new Response(cs.readable).arrayBuffer();
    const bytes = new Uint8Array(buf);
    return toBase64Util(bytes);
  }
  static async decompressSignature(signatureData) {
    try {
      const bytes = fromBase64Util(signatureData);
      const {
        readable,
        writable
      } = new DecompressionStream("deflate-raw");
      const writer = writable.getWriter();
      await writer.ready;
      writer.write(bytes).then(async () => {
        await writer.ready;
        await writer.close();
      }).catch(() => {
      });
      let data = null;
      let offset = 0;
      for await (const chunk of readable) {
        data || (data = new Uint8Array(new Uint32Array(chunk.buffer, 0, 4)[0]));
        data.set(chunk, offset);
        offset += chunk.length;
      }
      const header = new Uint32Array(data.buffer, 0, data.length >> 2);
      const version2 = header[1];
      if (version2 !== 0) {
        throw new Error(`Invalid version: ${version2}`);
      }
      const width = header[2];
      const height = header[3];
      const areContours = header[4] === 0;
      const thickness = header[5];
      const numberOfDrawings = header[6];
      const bufferType = header[7];
      const outlines = [];
      const diffsOffset = (BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * numberOfDrawings) * Uint32Array.BYTES_PER_ELEMENT;
      let diffs;
      switch (bufferType) {
        case Int8Array.BYTES_PER_ELEMENT:
          diffs = new Int8Array(data.buffer, diffsOffset);
          break;
        case Int16Array.BYTES_PER_ELEMENT:
          diffs = new Int16Array(data.buffer, diffsOffset);
          break;
        case Int32Array.BYTES_PER_ELEMENT:
          diffs = new Int32Array(data.buffer, diffsOffset);
          break;
      }
      offset = 0;
      for (let i = 0; i < numberOfDrawings; i++) {
        const len = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH];
        const points = new Float32Array(len + 2);
        outlines.push(points);
        for (let j = 0; j < POINTS_PROPERTIES_NUMBER - 1; j++) {
          points[j] = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH + j + 1];
        }
        for (let j = 0; j < len; j++) {
          points[j + 2] = points[j] + diffs[offset++];
        }
      }
      return {
        areContours,
        thickness,
        outlines,
        width,
        height
      };
    } catch (e) {
      warn(`decompressSignature: ${e}`);
      return null;
    }
  }
};
_PARAMETERS = new WeakMap();
_neighborIndexToId = new WeakSet();
neighborIndexToId_fn = function(i0, j0, i, j) {
  i -= i0;
  j -= j0;
  if (i === 0) {
    return j > 0 ? 0 : 4;
  }
  if (i === 1) {
    return j + 6;
  }
  return 2 - j;
};
_neighborIdToIndex = new WeakMap();
_clockwiseNonZero = new WeakSet();
clockwiseNonZero_fn = function(buf, width, i0, j0, i, j, offset) {
  const id = __privateMethod(this, _neighborIndexToId, neighborIndexToId_fn).call(this, i0, j0, i, j);
  for (let k = 0; k < 8; k++) {
    const kk = (-k + id - offset + 16) % 8;
    const shiftI = __privateGet(this, _neighborIdToIndex)[2 * kk];
    const shiftJ = __privateGet(this, _neighborIdToIndex)[2 * kk + 1];
    if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {
      return kk;
    }
  }
  return -1;
};
_counterClockwiseNonZero = new WeakSet();
counterClockwiseNonZero_fn = function(buf, width, i0, j0, i, j, offset) {
  const id = __privateMethod(this, _neighborIndexToId, neighborIndexToId_fn).call(this, i0, j0, i, j);
  for (let k = 0; k < 8; k++) {
    const kk = (k + id + offset + 16) % 8;
    const shiftI = __privateGet(this, _neighborIdToIndex)[2 * kk];
    const shiftJ = __privateGet(this, _neighborIdToIndex)[2 * kk + 1];
    if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {
      return kk;
    }
  }
  return -1;
};
_findContours = new WeakSet();
findContours_fn = function(buf, width, height, threshold) {
  const N = buf.length;
  const types = new Int32Array(N);
  for (let i = 0; i < N; i++) {
    types[i] = buf[i] <= threshold ? 1 : 0;
  }
  for (let i = 1; i < height - 1; i++) {
    types[i * width] = types[i * width + width - 1] = 0;
  }
  for (let i = 0; i < width; i++) {
    types[i] = types[width * height - 1 - i] = 0;
  }
  let nbd = 1;
  let lnbd;
  const contours = [];
  for (let i = 1; i < height - 1; i++) {
    lnbd = 1;
    for (let j = 1; j < width - 1; j++) {
      const ij = i * width + j;
      const pix = types[ij];
      if (pix === 0) {
        continue;
      }
      let i2 = i;
      let j2 = j;
      if (pix === 1 && types[ij - 1] === 0) {
        nbd += 1;
        j2 -= 1;
      } else if (pix >= 1 && types[ij + 1] === 0) {
        nbd += 1;
        j2 += 1;
        if (pix > 1) {
          lnbd = pix;
        }
      } else {
        if (pix !== 1) {
          lnbd = Math.abs(pix);
        }
        continue;
      }
      const points = [j, i];
      const isHole = j2 === j + 1;
      const contour = {
        isHole,
        points,
        id: nbd,
        parent: 0
      };
      contours.push(contour);
      let contour0;
      for (const c of contours) {
        if (c.id === lnbd) {
          contour0 = c;
          break;
        }
      }
      if (!contour0) {
        contour.parent = isHole ? lnbd : 0;
      } else if (contour0.isHole) {
        contour.parent = isHole ? contour0.parent : lnbd;
      } else {
        contour.parent = isHole ? lnbd : contour0.parent;
      }
      const k = __privateMethod(this, _clockwiseNonZero, clockwiseNonZero_fn).call(this, types, width, i, j, i2, j2, 0);
      if (k === -1) {
        types[ij] = -nbd;
        if (types[ij] !== 1) {
          lnbd = Math.abs(types[ij]);
        }
        continue;
      }
      let shiftI = __privateGet(this, _neighborIdToIndex)[2 * k];
      let shiftJ = __privateGet(this, _neighborIdToIndex)[2 * k + 1];
      const i1 = i + shiftI;
      const j1 = j + shiftJ;
      i2 = i1;
      j2 = j1;
      let i3 = i;
      let j3 = j;
      while (true) {
        const kk = __privateMethod(this, _counterClockwiseNonZero, counterClockwiseNonZero_fn).call(this, types, width, i3, j3, i2, j2, 1);
        shiftI = __privateGet(this, _neighborIdToIndex)[2 * kk];
        shiftJ = __privateGet(this, _neighborIdToIndex)[2 * kk + 1];
        const i4 = i3 + shiftI;
        const j4 = j3 + shiftJ;
        points.push(j4, i4);
        const ij3 = i3 * width + j3;
        if (types[ij3 + 1] === 0) {
          types[ij3] = -nbd;
        } else if (types[ij3] === 1) {
          types[ij3] = nbd;
        }
        if (i4 === i && j4 === j && i3 === i1 && j3 === j1) {
          if (types[ij] !== 1) {
            lnbd = Math.abs(types[ij]);
          }
          break;
        } else {
          i2 = i3;
          j2 = j3;
          i3 = i4;
          j3 = j4;
        }
      }
    }
  }
  return contours;
};
_douglasPeuckerHelper = new WeakSet();
douglasPeuckerHelper_fn = function(points, start, end, output) {
  if (end - start <= 4) {
    for (let i = start; i < end - 2; i += 2) {
      output.push(points[i], points[i + 1]);
    }
    return;
  }
  const ax = points[start];
  const ay = points[start + 1];
  const abx = points[end - 4] - ax;
  const aby = points[end - 3] - ay;
  const dist = Math.hypot(abx, aby);
  const nabx = abx / dist;
  const naby = aby / dist;
  const aa = nabx * ay - naby * ax;
  const m = aby / abx;
  const invS = 1 / dist;
  const phi = Math.atan(m);
  const cosPhi = Math.cos(phi);
  const sinPhi = Math.sin(phi);
  const tmax = invS * (Math.abs(cosPhi) + Math.abs(sinPhi));
  const poly = invS * (1 - tmax + tmax ** 2);
  const partialPhi = Math.max(Math.atan(Math.abs(sinPhi + cosPhi) * poly), Math.atan(Math.abs(sinPhi - cosPhi) * poly));
  let dmax = 0;
  let index = start;
  for (let i = start + 2; i < end - 2; i += 2) {
    const d = Math.abs(aa - nabx * points[i + 1] + naby * points[i]);
    if (d > dmax) {
      index = i;
      dmax = d;
    }
  }
  if (dmax > (dist * partialPhi) ** 2) {
    __privateMethod(this, _douglasPeuckerHelper, douglasPeuckerHelper_fn).call(this, points, start, index + 2, output);
    __privateMethod(this, _douglasPeuckerHelper, douglasPeuckerHelper_fn).call(this, points, index, end, output);
  } else {
    output.push(ax, ay);
  }
};
_douglasPeucker = new WeakSet();
douglasPeucker_fn = function(points) {
  const output = [];
  const len = points.length;
  __privateMethod(this, _douglasPeuckerHelper, douglasPeuckerHelper_fn).call(this, points, 0, len, output);
  output.push(points[len - 2], points[len - 1]);
  return output.length <= 4 ? null : output;
};
_bilateralFilter = new WeakSet();
bilateralFilter_fn = function(buf, width, height, sigmaS, sigmaR, kernelSize) {
  const kernel = new Float32Array(kernelSize ** 2);
  const sigmaS2 = -2 * sigmaS ** 2;
  const halfSize = kernelSize >> 1;
  for (let i = 0; i < kernelSize; i++) {
    const x = (i - halfSize) ** 2;
    for (let j = 0; j < kernelSize; j++) {
      kernel[i * kernelSize + j] = Math.exp((x + (j - halfSize) ** 2) / sigmaS2);
    }
  }
  const rangeValues = new Float32Array(256);
  const sigmaR2 = -2 * sigmaR ** 2;
  for (let i = 0; i < 256; i++) {
    rangeValues[i] = Math.exp(i ** 2 / sigmaR2);
  }
  const N = buf.length;
  const out = new Uint8Array(N);
  const histogram = new Uint32Array(256);
  for (let i = 0; i < height; i++) {
    for (let j = 0; j < width; j++) {
      const ij = i * width + j;
      const center = buf[ij];
      let sum = 0;
      let norm = 0;
      for (let k = 0; k < kernelSize; k++) {
        const y = i + k - halfSize;
        if (y < 0 || y >= height) {
          continue;
        }
        for (let l = 0; l < kernelSize; l++) {
          const x = j + l - halfSize;
          if (x < 0 || x >= width) {
            continue;
          }
          const neighbour = buf[y * width + x];
          const w = kernel[k * kernelSize + l] * rangeValues[Math.abs(neighbour - center)];
          sum += neighbour * w;
          norm += w;
        }
      }
      const pix = out[ij] = Math.round(sum / norm);
      histogram[pix]++;
    }
  }
  return [out, histogram];
};
_getHistogram = new WeakSet();
getHistogram_fn = function(buf) {
  const histogram = new Uint32Array(256);
  for (const g of buf) {
    histogram[g]++;
  }
  return histogram;
};
_toUint8 = new WeakSet();
toUint8_fn = function(buf) {
  const N = buf.length;
  const out = new Uint8ClampedArray(N >> 2);
  let max = -Infinity;
  let min = Infinity;
  for (let i = 0, ii = out.length; i < ii; i++) {
    const pix = out[i] = buf[i << 2];
    max = Math.max(max, pix);
    min = Math.min(min, pix);
  }
  const ratio = 255 / (max - min);
  for (let i = 0, ii = out.length; i < ii; i++) {
    out[i] = (out[i] - min) * ratio;
  }
  return out;
};
_guessThreshold = new WeakSet();
guessThreshold_fn = function(histogram) {
  let i;
  let M = -Infinity;
  let L = -Infinity;
  const min = histogram.findIndex((v) => v !== 0);
  let pos = min;
  let spos = min;
  for (i = min; i < 256; i++) {
    const v = histogram[i];
    if (v > M) {
      if (i - pos > L) {
        L = i - pos;
        spos = i - 1;
      }
      M = v;
      pos = i;
    }
  }
  for (i = spos - 1; i >= 0; i--) {
    if (histogram[i] > histogram[i + 1]) {
      break;
    }
  }
  return i;
};
_getGrayPixels = new WeakSet();
getGrayPixels_fn = function(bitmap) {
  const originalBitmap = bitmap;
  const {
    width,
    height
  } = bitmap;
  const {
    maxDim
  } = __privateGet(this, _PARAMETERS);
  let newWidth = width;
  let newHeight = height;
  if (width > maxDim || height > maxDim) {
    let prevWidth = width;
    let prevHeight = height;
    let steps = Math.log2(Math.max(width, height) / maxDim);
    const isteps = Math.floor(steps);
    steps = steps === isteps ? isteps - 1 : isteps;
    for (let i = 0; i < steps; i++) {
      newWidth = Math.ceil(prevWidth / 2);
      newHeight = Math.ceil(prevHeight / 2);
      const offscreen2 = new OffscreenCanvas(newWidth, newHeight);
      const ctx2 = offscreen2.getContext("2d");
      ctx2.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
      prevWidth = newWidth;
      prevHeight = newHeight;
      if (bitmap !== originalBitmap) {
        bitmap.close();
      }
      bitmap = offscreen2.transferToImageBitmap();
    }
    const ratio = Math.min(maxDim / newWidth, maxDim / newHeight);
    newWidth = Math.round(newWidth * ratio);
    newHeight = Math.round(newHeight * ratio);
  }
  const offscreen = new OffscreenCanvas(newWidth, newHeight);
  const ctx = offscreen.getContext("2d", {
    willReadFrequently: true
  });
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, newWidth, newHeight);
  ctx.filter = "grayscale(1)";
  ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, newWidth, newHeight);
  const grayImage = ctx.getImageData(0, 0, newWidth, newHeight).data;
  const uint8Buf = __privateMethod(this, _toUint8, toUint8_fn).call(this, grayImage);
  return [uint8Buf, newWidth, newHeight];
};
__privateAdd(SignatureExtractor, _neighborIndexToId);
__privateAdd(SignatureExtractor, _clockwiseNonZero);
__privateAdd(SignatureExtractor, _counterClockwiseNonZero);
__privateAdd(SignatureExtractor, _findContours);
__privateAdd(SignatureExtractor, _douglasPeuckerHelper);
__privateAdd(SignatureExtractor, _douglasPeucker);
__privateAdd(SignatureExtractor, _bilateralFilter);
__privateAdd(SignatureExtractor, _getHistogram);
__privateAdd(SignatureExtractor, _toUint8);
__privateAdd(SignatureExtractor, _guessThreshold);
__privateAdd(SignatureExtractor, _getGrayPixels);
__privateAdd(SignatureExtractor, _PARAMETERS, {
  maxDim: 512,
  sigmaSFactor: 0.02,
  sigmaR: 25,
  kernelSize: 16
});
__privateAdd(SignatureExtractor, _neighborIdToIndex, new Int32Array([0, 1, -1, 1, -1, 0, -1, -1, 0, -1, 1, -1, 1, 0, 1, 1]));
var SignatureOptions = class _SignatureOptions extends DrawingOptions {
  constructor() {
    super();
    super.updateProperties({
      fill: AnnotationEditor._defaultLineColor,
      "stroke-width": 0
    });
  }
  clone() {
    const clone = new _SignatureOptions();
    clone.updateAll(this);
    return clone;
  }
};
var DrawnSignatureOptions = class _DrawnSignatureOptions extends InkDrawingOptions {
  constructor(viewerParameters) {
    super(viewerParameters);
    super.updateProperties({
      stroke: AnnotationEditor._defaultLineColor,
      "stroke-width": 1
    });
  }
  clone() {
    const clone = new _DrawnSignatureOptions(this._viewParameters);
    clone.updateAll(this);
    return clone;
  }
};
var _isExtracted, _description, _signatureData, _signatureUUID;
var _SignatureEditor = class _SignatureEditor extends DrawingEditor {
  constructor(params) {
    super({
      ...params,
      mustBeCommitted: true,
      name: "signatureEditor"
    });
    __privateAdd(this, _isExtracted, false);
    __privateAdd(this, _description, null);
    __privateAdd(this, _signatureData, null);
    __privateAdd(this, _signatureUUID, null);
    this._willKeepAspectRatio = true;
    __privateSet(this, _signatureData, params.signatureData || null);
    __privateSet(this, _description, null);
    this.defaultL10nId = "pdfjs-editor-signature-editor1";
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
    this._defaultDrawingOptions = new SignatureOptions();
    this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(uiManager.viewParameters);
  }
  static getDefaultDrawingOptions(options) {
    const clone = this._defaultDrawingOptions.clone();
    clone.updateProperties(options);
    return clone;
  }
  static get supportMultipleDrawings() {
    return false;
  }
  static get typesMap() {
    return shadow(this, "typesMap", /* @__PURE__ */ new Map());
  }
  static get isDrawer() {
    return false;
  }
  get telemetryFinalData() {
    return {
      type: "signature",
      hasDescription: !!__privateGet(this, _description)
    };
  }
  static computeTelemetryFinalData(data) {
    const hasDescriptionStats = data.get("hasDescription");
    return {
      hasAltText: hasDescriptionStats.get(true) ?? 0,
      hasNoAltText: hasDescriptionStats.get(false) ?? 0
    };
  }
  get isResizable() {
    return true;
  }
  onScaleChanging() {
    if (this._drawId === null) {
      return;
    }
    super.onScaleChanging();
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    const {
      _isCopy
    } = this;
    if (_isCopy) {
      this._isCopy = false;
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    if (this._drawId === null) {
      if (__privateGet(this, _signatureData)) {
        const {
          lines,
          mustSmooth,
          areContours,
          description,
          uuid,
          heightInPage
        } = __privateGet(this, _signatureData);
        const {
          rawDims: {
            pageWidth,
            pageHeight
          },
          rotation
        } = this.parent.viewport;
        const outline = SignatureExtractor.processDrawnLines({
          lines,
          pageWidth,
          pageHeight,
          rotation,
          innerMargin: _SignatureEditor._INNER_MARGIN,
          mustSmooth,
          areContours
        });
        this.addSignature(outline, heightInPage, description, uuid);
      } else {
        this.div.setAttribute("data-l10n-args", JSON.stringify({
          description: ""
        }));
        this.div.hidden = true;
        this._uiManager.getSignature(this);
      }
    } else {
      this.div.setAttribute("data-l10n-args", JSON.stringify({
        description: __privateGet(this, _description) || ""
      }));
    }
    if (_isCopy) {
      this._isCopy = true;
      this._moveAfterPaste(baseX, baseY);
    }
    return this.div;
  }
  setUuid(uuid) {
    __privateSet(this, _signatureUUID, uuid);
    this.addEditToolbar();
  }
  getUuid() {
    return __privateGet(this, _signatureUUID);
  }
  get description() {
    return __privateGet(this, _description);
  }
  set description(description) {
    __privateSet(this, _description, description);
    if (!this.div) {
      return;
    }
    this.div.setAttribute("data-l10n-args", JSON.stringify({
      description
    }));
    super.addEditToolbar().then((toolbar) => {
      toolbar == null ? void 0 : toolbar.updateEditSignatureButton(description);
    });
  }
  getSignaturePreview() {
    const {
      newCurves,
      areContours,
      thickness,
      width,
      height
    } = __privateGet(this, _signatureData);
    const maxDim = Math.max(width, height);
    const outlineData = SignatureExtractor.processDrawnLines({
      lines: {
        curves: newCurves.map((points) => ({
          points
        })),
        thickness,
        width,
        height
      },
      pageWidth: maxDim,
      pageHeight: maxDim,
      rotation: 0,
      innerMargin: 0,
      mustSmooth: false,
      areContours
    });
    return {
      areContours,
      outline: outlineData.outline
    };
  }
  get toolbarButtons() {
    if (this._uiManager.signatureManager) {
      return [["editSignature", this._uiManager.signatureManager]];
    }
    return super.toolbarButtons;
  }
  addSignature(data, heightInPage, description, uuid) {
    const {
      x: savedX,
      y: savedY
    } = this;
    const {
      outline
    } = __privateSet(this, _signatureData, data);
    __privateSet(this, _isExtracted, outline instanceof ContourDrawOutline);
    this.description = description;
    let drawingOptions;
    if (__privateGet(this, _isExtracted)) {
      drawingOptions = _SignatureEditor.getDefaultDrawingOptions();
    } else {
      drawingOptions = _SignatureEditor._defaultDrawnSignatureOptions.clone();
      drawingOptions.updateProperties({
        "stroke-width": outline.thickness
      });
    }
    this._addOutlines({
      drawOutlines: outline,
      drawingOptions
    });
    const [, pageHeight] = this.pageDimensions;
    let newHeight = heightInPage / pageHeight;
    newHeight = newHeight >= 1 ? 0.5 : newHeight;
    this.width *= newHeight / this.height;
    if (this.width >= 1) {
      newHeight *= 0.9 / this.width;
      this.width = 0.9;
    }
    this.height = newHeight;
    this.setDims();
    this.x = savedX;
    this.y = savedY;
    this.center();
    this._onResized();
    this.onScaleChanging();
    this.rotate();
    this._uiManager.addToAnnotationStorage(this);
    this.setUuid(uuid);
    this._reportTelemetry({
      action: "pdfjs.signature.inserted",
      data: {
        hasBeenSaved: !!uuid,
        hasDescription: !!description
      }
    });
    this.div.hidden = false;
  }
  getFromImage(bitmap) {
    const {
      rawDims: {
        pageWidth,
        pageHeight
      },
      rotation
    } = this.parent.viewport;
    return SignatureExtractor.process(bitmap, pageWidth, pageHeight, rotation, _SignatureEditor._INNER_MARGIN);
  }
  getFromText(text, fontInfo) {
    const {
      rawDims: {
        pageWidth,
        pageHeight
      },
      rotation
    } = this.parent.viewport;
    return SignatureExtractor.extractContoursFromText(text, fontInfo, pageWidth, pageHeight, rotation, _SignatureEditor._INNER_MARGIN);
  }
  getDrawnSignature(curves) {
    const {
      rawDims: {
        pageWidth,
        pageHeight
      },
      rotation
    } = this.parent.viewport;
    return SignatureExtractor.processDrawnLines({
      lines: curves,
      pageWidth,
      pageHeight,
      rotation,
      innerMargin: _SignatureEditor._INNER_MARGIN,
      mustSmooth: false,
      areContours: false
    });
  }
  createDrawingOptions({
    areContours,
    thickness
  }) {
    if (areContours) {
      this._drawingOptions = _SignatureEditor.getDefaultDrawingOptions();
    } else {
      this._drawingOptions = _SignatureEditor._defaultDrawnSignatureOptions.clone();
      this._drawingOptions.updateProperties({
        "stroke-width": thickness
      });
    }
  }
  serialize(isForCopying = false) {
    if (this.isEmpty()) {
      return null;
    }
    const {
      lines,
      points
    } = this.serializeDraw(isForCopying);
    const {
      _drawingOptions: {
        "stroke-width": thickness
      }
    } = this;
    const serialized = Object.assign(super.serialize(isForCopying), {
      isSignature: true,
      areContours: __privateGet(this, _isExtracted),
      color: [0, 0, 0],
      thickness: __privateGet(this, _isExtracted) ? 0 : thickness
    });
    this.addComment(serialized);
    if (isForCopying) {
      serialized.paths = {
        lines,
        points
      };
      serialized.uuid = __privateGet(this, _signatureUUID);
      serialized.isCopy = true;
    } else {
      serialized.lines = lines;
    }
    if (__privateGet(this, _description)) {
      serialized.accessibilityData = {
        type: "Figure",
        alt: __privateGet(this, _description)
      };
    }
    return serialized;
  }
  static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {
    if (data.areContours) {
      return ContourDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
    }
    return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
  }
  static async deserialize(data, parent, uiManager) {
    var _a2;
    const editor = await super.deserialize(data, parent, uiManager);
    __privateSet(editor, _isExtracted, data.areContours);
    editor.description = ((_a2 = data.accessibilityData) == null ? void 0 : _a2.alt) || "";
    __privateSet(editor, _signatureUUID, data.uuid);
    return editor;
  }
};
_isExtracted = new WeakMap();
_description = new WeakMap();
_signatureData = new WeakMap();
_signatureUUID = new WeakMap();
__publicField(_SignatureEditor, "_type", "signature");
__publicField(_SignatureEditor, "_editorType", AnnotationEditorType.SIGNATURE);
__publicField(_SignatureEditor, "_defaultDrawingOptions", null);
var SignatureEditor = _SignatureEditor;
var _bitmap, _bitmapId, _bitmapPromise, _bitmapUrl, _bitmapFile, _bitmapFileName, _canvas, _missingCanvas, _resizeTimeoutId, _isSvg, _hasBeenAddedInUndoStack, _getBitmapFetched, getBitmapFetched_fn, _getBitmapDone, getBitmapDone_fn, _getBitmap, getBitmap_fn, _createCanvas, createCanvas_fn, _scaleBitmap, scaleBitmap_fn, _drawBitmap, drawBitmap_fn, _serializeBitmap, serializeBitmap_fn, _hasElementChanged4, hasElementChanged_fn4;
var StampEditor = class extends AnnotationEditor {
  constructor(params) {
    super({
      ...params,
      name: "stampEditor"
    });
    __privateAdd(this, _getBitmapFetched);
    __privateAdd(this, _getBitmapDone);
    __privateAdd(this, _getBitmap);
    __privateAdd(this, _createCanvas);
    __privateAdd(this, _scaleBitmap);
    __privateAdd(this, _drawBitmap);
    __privateAdd(this, _serializeBitmap);
    __privateAdd(this, _hasElementChanged4);
    __privateAdd(this, _bitmap, null);
    __privateAdd(this, _bitmapId, null);
    __privateAdd(this, _bitmapPromise, null);
    __privateAdd(this, _bitmapUrl, null);
    __privateAdd(this, _bitmapFile, null);
    __privateAdd(this, _bitmapFileName, "");
    __privateAdd(this, _canvas, null);
    __privateAdd(this, _missingCanvas, false);
    __privateAdd(this, _resizeTimeoutId, null);
    __privateAdd(this, _isSvg, false);
    __privateAdd(this, _hasBeenAddedInUndoStack, false);
    __privateSet(this, _bitmapUrl, params.bitmapUrl);
    __privateSet(this, _bitmapFile, params.bitmapFile);
    this.defaultL10nId = "pdfjs-editor-stamp-editor";
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
  }
  static isHandlingMimeForPasting(mime) {
    return SupportedImageMimeTypes.includes(mime);
  }
  static paste(item, parent) {
    parent.pasteEditor({
      mode: AnnotationEditorType.STAMP
    }, {
      bitmapFile: item.getAsFile()
    });
  }
  altTextFinish() {
    if (this._uiManager.useNewAltTextFlow) {
      this.div.hidden = false;
    }
    super.altTextFinish();
  }
  get telemetryFinalData() {
    var _a2;
    return {
      type: "stamp",
      hasAltText: !!((_a2 = this.altTextData) == null ? void 0 : _a2.altText)
    };
  }
  static computeTelemetryFinalData(data) {
    const hasAltTextStats = data.get("hasAltText");
    return {
      hasAltText: hasAltTextStats.get(true) ?? 0,
      hasNoAltText: hasAltTextStats.get(false) ?? 0
    };
  }
  async mlGuessAltText(imageData = null, updateAltTextData = true) {
    if (this.hasAltTextData()) {
      return null;
    }
    const {
      mlManager
    } = this._uiManager;
    if (!mlManager) {
      throw new Error("No ML.");
    }
    if (!await mlManager.isEnabledFor("altText")) {
      throw new Error("ML isn't enabled for alt text.");
    }
    const {
      data,
      width,
      height
    } = imageData || this.copyCanvas(null, null, true).imageData;
    const response = await mlManager.guess({
      name: "altText",
      request: {
        data,
        width,
        height,
        channels: data.length / (width * height)
      }
    });
    if (!response) {
      throw new Error("No response from the AI service.");
    }
    if (response.error) {
      throw new Error("Error from the AI service.");
    }
    if (response.cancel) {
      return null;
    }
    if (!response.output) {
      throw new Error("No valid response from the AI service.");
    }
    const altText = response.output;
    await this.setGuessedAltText(altText);
    if (updateAltTextData && !this.hasAltTextData()) {
      this.altTextData = {
        alt: altText,
        decorative: false
      };
    }
    return altText;
  }
  remove() {
    var _a2;
    if (__privateGet(this, _bitmapId)) {
      __privateSet(this, _bitmap, null);
      this._uiManager.imageManager.deleteId(__privateGet(this, _bitmapId));
      (_a2 = __privateGet(this, _canvas)) == null ? void 0 : _a2.remove();
      __privateSet(this, _canvas, null);
      if (__privateGet(this, _resizeTimeoutId)) {
        clearTimeout(__privateGet(this, _resizeTimeoutId));
        __privateSet(this, _resizeTimeoutId, null);
      }
    }
    super.remove();
  }
  rebuild() {
    if (!this.parent) {
      if (__privateGet(this, _bitmapId)) {
        __privateMethod(this, _getBitmap, getBitmap_fn).call(this);
      }
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    if (__privateGet(this, _bitmapId) && __privateGet(this, _canvas) === null) {
      __privateMethod(this, _getBitmap, getBitmap_fn).call(this);
    }
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  onceAdded(focus) {
    this._isDraggable = true;
    if (focus) {
      this.div.focus();
    }
  }
  isEmpty() {
    return !(__privateGet(this, _bitmapPromise) || __privateGet(this, _bitmap) || __privateGet(this, _bitmapUrl) || __privateGet(this, _bitmapFile) || __privateGet(this, _bitmapId) || __privateGet(this, _missingCanvas));
  }
  get toolbarButtons() {
    return [["altText", this.createAltText()]];
  }
  get isResizable() {
    return true;
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this._isCopy) {
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    this.div.hidden = true;
    this.createAltText();
    if (!__privateGet(this, _missingCanvas)) {
      if (__privateGet(this, _bitmap)) {
        __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
      } else {
        __privateMethod(this, _getBitmap, getBitmap_fn).call(this);
      }
    }
    if (this._isCopy) {
      this._moveAfterPaste(baseX, baseY);
    }
    this._uiManager.addShouldRescale(this);
    return this.div;
  }
  setCanvas(annotationElementId, canvas) {
    const {
      id: bitmapId,
      bitmap
    } = this._uiManager.imageManager.getFromCanvas(annotationElementId, canvas);
    canvas.remove();
    if (bitmapId && this._uiManager.imageManager.isValidId(bitmapId)) {
      __privateSet(this, _bitmapId, bitmapId);
      if (bitmap) {
        __privateSet(this, _bitmap, bitmap);
      }
      __privateSet(this, _missingCanvas, false);
      __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
    }
  }
  _onResized() {
    this.onScaleChanging();
  }
  onScaleChanging() {
    if (!this.parent) {
      return;
    }
    if (__privateGet(this, _resizeTimeoutId) !== null) {
      clearTimeout(__privateGet(this, _resizeTimeoutId));
    }
    const TIME_TO_WAIT = 200;
    __privateSet(this, _resizeTimeoutId, setTimeout(() => {
      __privateSet(this, _resizeTimeoutId, null);
      __privateMethod(this, _drawBitmap, drawBitmap_fn).call(this);
    }, TIME_TO_WAIT));
  }
  copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {
    if (!maxDataDimension) {
      maxDataDimension = 224;
    }
    const {
      width: bitmapWidth,
      height: bitmapHeight
    } = __privateGet(this, _bitmap);
    const outputScale = new OutputScale();
    let bitmap = __privateGet(this, _bitmap);
    let width = bitmapWidth, height = bitmapHeight;
    let canvas = null;
    if (maxPreviewDimension) {
      if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {
        const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);
        width = Math.floor(bitmapWidth * ratio);
        height = Math.floor(bitmapHeight * ratio);
      }
      canvas = document.createElement("canvas");
      const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);
      const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);
      if (!__privateGet(this, _isSvg)) {
        bitmap = __privateMethod(this, _scaleBitmap, scaleBitmap_fn).call(this, scaledWidth, scaledHeight);
      }
      const ctx = canvas.getContext("2d");
      ctx.filter = this._uiManager.hcmFilter;
      let white = "white", black = "#cfcfd8";
      if (this._uiManager.hcmFilter !== "none") {
        black = "black";
      } else if (ColorScheme.isDarkMode) {
        white = "#8f8f9d";
        black = "#42414d";
      }
      const boxDim = 15;
      const boxDimWidth = boxDim * outputScale.sx;
      const boxDimHeight = boxDim * outputScale.sy;
      const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);
      const patternCtx = pattern.getContext("2d");
      patternCtx.fillStyle = white;
      patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);
      patternCtx.fillStyle = black;
      patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);
      patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);
      ctx.fillStyle = ctx.createPattern(pattern, "repeat");
      ctx.fillRect(0, 0, scaledWidth, scaledHeight);
      ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);
    }
    let imageData = null;
    if (createImageData) {
      let dataWidth, dataHeight;
      if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {
        dataWidth = bitmap.width;
        dataHeight = bitmap.height;
      } else {
        bitmap = __privateGet(this, _bitmap);
        if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {
          const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);
          dataWidth = Math.floor(bitmapWidth * ratio);
          dataHeight = Math.floor(bitmapHeight * ratio);
          if (!__privateGet(this, _isSvg)) {
            bitmap = __privateMethod(this, _scaleBitmap, scaleBitmap_fn).call(this, dataWidth, dataHeight);
          }
        }
      }
      const offscreen = new OffscreenCanvas(dataWidth, dataHeight);
      const offscreenCtx = offscreen.getContext("2d", {
        willReadFrequently: true
      });
      offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);
      imageData = {
        width: dataWidth,
        height: dataHeight,
        data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data
      };
    }
    return {
      canvas,
      width,
      height,
      imageData
    };
  }
  static async deserialize(data, parent, uiManager) {
    var _a2;
    let initialData = null;
    let missingCanvas = false;
    if (data instanceof StampAnnotationElement) {
      const {
        data: {
          rect: rect2,
          rotation,
          id,
          structParent,
          popupRef,
          richText,
          contentsObj,
          creationDate,
          modificationDate
        },
        container,
        parent: {
          page: {
            pageNumber
          }
        },
        canvas
      } = data;
      let bitmapId2, bitmap2;
      if (canvas) {
        delete data.canvas;
        ({
          id: bitmapId2,
          bitmap: bitmap2
        } = uiManager.imageManager.getFromCanvas(container.id, canvas));
        canvas.remove();
      } else {
        missingCanvas = true;
        data._hasNoCanvas = true;
      }
      const altText = ((_a2 = await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`)) == null ? void 0 : _a2.get("aria-label")) || "";
      initialData = data = {
        annotationType: AnnotationEditorType.STAMP,
        bitmapId: bitmapId2,
        bitmap: bitmap2,
        pageIndex: pageNumber - 1,
        rect: rect2.slice(0),
        rotation,
        annotationElementId: id,
        id,
        deleted: false,
        accessibilityData: {
          decorative: false,
          altText
        },
        isSvg: false,
        structParent,
        popupRef,
        richText,
        comment: (contentsObj == null ? void 0 : contentsObj.str) || null,
        creationDate,
        modificationDate
      };
    }
    const editor = await super.deserialize(data, parent, uiManager);
    const {
      rect,
      bitmap,
      bitmapUrl,
      bitmapId,
      isSvg,
      accessibilityData
    } = data;
    if (missingCanvas) {
      uiManager.addMissingCanvas(data.id, editor);
      __privateSet(editor, _missingCanvas, true);
    } else if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {
      __privateSet(editor, _bitmapId, bitmapId);
      if (bitmap) {
        __privateSet(editor, _bitmap, bitmap);
      }
    } else {
      __privateSet(editor, _bitmapUrl, bitmapUrl);
    }
    __privateSet(editor, _isSvg, isSvg);
    const [parentWidth, parentHeight] = editor.pageDimensions;
    editor.width = (rect[2] - rect[0]) / parentWidth;
    editor.height = (rect[3] - rect[1]) / parentHeight;
    if (accessibilityData) {
      editor.altTextData = accessibilityData;
    }
    editor._initialData = initialData;
    if (data.comment) {
      editor.setCommentData(data);
    }
    __privateSet(editor, _hasBeenAddedInUndoStack, !!initialData);
    return editor;
  }
  serialize(isForCopying = false, context = null) {
    if (this.isEmpty()) {
      return null;
    }
    if (this.deleted) {
      return this.serializeDeleted();
    }
    const serialized = Object.assign(super.serialize(isForCopying), {
      bitmapId: __privateGet(this, _bitmapId),
      isSvg: __privateGet(this, _isSvg)
    });
    this.addComment(serialized);
    if (isForCopying) {
      serialized.bitmapUrl = __privateMethod(this, _serializeBitmap, serializeBitmap_fn).call(this, true);
      serialized.accessibilityData = this.serializeAltText(true);
      serialized.isCopy = true;
      return serialized;
    }
    const {
      decorative,
      altText
    } = this.serializeAltText(false);
    if (!decorative && altText) {
      serialized.accessibilityData = {
        type: "Figure",
        alt: altText
      };
    }
    if (this.annotationElementId) {
      const changes = __privateMethod(this, _hasElementChanged4, hasElementChanged_fn4).call(this, serialized);
      if (changes.isSame) {
        return null;
      }
      if (changes.isSameAltText) {
        delete serialized.accessibilityData;
      } else {
        serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;
      }
      serialized.id = this.annotationElementId;
      delete serialized.bitmapId;
      return serialized;
    }
    if (context === null) {
      return serialized;
    }
    context.stamps || (context.stamps = /* @__PURE__ */ new Map());
    const area = __privateGet(this, _isSvg) ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;
    if (!context.stamps.has(__privateGet(this, _bitmapId))) {
      context.stamps.set(__privateGet(this, _bitmapId), {
        area,
        serialized
      });
      serialized.bitmap = __privateMethod(this, _serializeBitmap, serializeBitmap_fn).call(this, false);
    } else if (__privateGet(this, _isSvg)) {
      const prevData = context.stamps.get(__privateGet(this, _bitmapId));
      if (area > prevData.area) {
        prevData.area = area;
        prevData.serialized.bitmap.close();
        prevData.serialized.bitmap = __privateMethod(this, _serializeBitmap, serializeBitmap_fn).call(this, false);
      }
    }
    return serialized;
  }
  renderAnnotationElement(annotation) {
    if (this.deleted) {
      annotation.hide();
      return null;
    }
    annotation.updateEdited({
      rect: this.getPDFRect(),
      popup: this.comment
    });
    return null;
  }
};
_bitmap = new WeakMap();
_bitmapId = new WeakMap();
_bitmapPromise = new WeakMap();
_bitmapUrl = new WeakMap();
_bitmapFile = new WeakMap();
_bitmapFileName = new WeakMap();
_canvas = new WeakMap();
_missingCanvas = new WeakMap();
_resizeTimeoutId = new WeakMap();
_isSvg = new WeakMap();
_hasBeenAddedInUndoStack = new WeakMap();
_getBitmapFetched = new WeakSet();
getBitmapFetched_fn = function(data, fromId = false) {
  if (!data) {
    this.remove();
    return;
  }
  __privateSet(this, _bitmap, data.bitmap);
  if (!fromId) {
    __privateSet(this, _bitmapId, data.id);
    __privateSet(this, _isSvg, data.isSvg);
  }
  if (data.file) {
    __privateSet(this, _bitmapFileName, data.file.name);
  }
  __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
};
_getBitmapDone = new WeakSet();
getBitmapDone_fn = function() {
  __privateSet(this, _bitmapPromise, null);
  this._uiManager.enableWaiting(false);
  if (!__privateGet(this, _canvas)) {
    return;
  }
  if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && __privateGet(this, _bitmap)) {
    this.addEditToolbar().then(() => {
      this._editToolbar.hide();
      this._uiManager.editAltText(this, true);
    });
    return;
  }
  if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && __privateGet(this, _bitmap)) {
    this._reportTelemetry({
      action: "pdfjs.image.image_added",
      data: {
        alt_text_modal: false,
        alt_text_type: "empty"
      }
    });
    try {
      this.mlGuessAltText();
    } catch {
    }
  }
  this.div.focus();
};
_getBitmap = new WeakSet();
getBitmap_fn = function() {
  if (__privateGet(this, _bitmapId)) {
    this._uiManager.enableWaiting(true);
    this._uiManager.imageManager.getFromId(__privateGet(this, _bitmapId)).then((data) => __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data, true)).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this));
    return;
  }
  if (__privateGet(this, _bitmapUrl)) {
    const url = __privateGet(this, _bitmapUrl);
    __privateSet(this, _bitmapUrl, null);
    this._uiManager.enableWaiting(true);
    __privateSet(this, _bitmapPromise, this._uiManager.imageManager.getFromUrl(url).then((data) => __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data)).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this)));
    return;
  }
  if (__privateGet(this, _bitmapFile)) {
    const file = __privateGet(this, _bitmapFile);
    __privateSet(this, _bitmapFile, null);
    this._uiManager.enableWaiting(true);
    __privateSet(this, _bitmapPromise, this._uiManager.imageManager.getFromFile(file).then((data) => __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data)).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this)));
    return;
  }
  const input = document.createElement("input");
  input.type = "file";
  input.accept = SupportedImageMimeTypes.join(",");
  const signal = this._uiManager._signal;
  __privateSet(this, _bitmapPromise, new Promise((resolve) => {
    input.addEventListener("change", async () => {
      if (!input.files || input.files.length === 0) {
        this.remove();
      } else {
        this._uiManager.enableWaiting(true);
        const data = await this._uiManager.imageManager.getFromFile(input.files[0]);
        this._reportTelemetry({
          action: "pdfjs.image.image_selected",
          data: {
            alt_text_modal: this._uiManager.useNewAltTextFlow
          }
        });
        __privateMethod(this, _getBitmapFetched, getBitmapFetched_fn).call(this, data);
      }
      resolve();
    }, {
      signal
    });
    input.addEventListener("cancel", () => {
      this.remove();
      resolve();
    }, {
      signal
    });
  }).finally(() => __privateMethod(this, _getBitmapDone, getBitmapDone_fn).call(this)));
  input.click();
};
_createCanvas = new WeakSet();
createCanvas_fn = function() {
  var _a2;
  const {
    div
  } = this;
  let {
    width,
    height
  } = __privateGet(this, _bitmap);
  const [pageWidth, pageHeight] = this.pageDimensions;
  const MAX_RATIO = 0.75;
  if (this.width) {
    width = this.width * pageWidth;
    height = this.height * pageHeight;
  } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {
    const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);
    width *= factor;
    height *= factor;
  }
  this._uiManager.enableWaiting(false);
  const canvas = __privateSet(this, _canvas, document.createElement("canvas"));
  canvas.setAttribute("role", "img");
  this.addContainer(canvas);
  this.width = width / pageWidth;
  this.height = height / pageHeight;
  this.setDims();
  if ((_a2 = this._initialOptions) == null ? void 0 : _a2.isCentered) {
    this.center();
  } else {
    this.fixAndSetPosition();
  }
  this._initialOptions = null;
  if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {
    div.hidden = false;
  }
  __privateMethod(this, _drawBitmap, drawBitmap_fn).call(this);
  if (!__privateGet(this, _hasBeenAddedInUndoStack)) {
    this.parent.addUndoableEditor(this);
    __privateSet(this, _hasBeenAddedInUndoStack, true);
  }
  this._reportTelemetry({
    action: "inserted_image"
  });
  if (__privateGet(this, _bitmapFileName)) {
    this.div.setAttribute("aria-description", __privateGet(this, _bitmapFileName));
  }
  if (!this.annotationElementId) {
    this._uiManager.a11yAlert("pdfjs-editor-stamp-added-alert");
  }
};
_scaleBitmap = new WeakSet();
scaleBitmap_fn = function(width, height) {
  const {
    width: bitmapWidth,
    height: bitmapHeight
  } = __privateGet(this, _bitmap);
  let newWidth = bitmapWidth;
  let newHeight = bitmapHeight;
  let bitmap = __privateGet(this, _bitmap);
  while (newWidth > 2 * width || newHeight > 2 * height) {
    const prevWidth = newWidth;
    const prevHeight = newHeight;
    if (newWidth > 2 * width) {
      newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);
    }
    if (newHeight > 2 * height) {
      newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);
    }
    const offscreen = new OffscreenCanvas(newWidth, newHeight);
    const ctx = offscreen.getContext("2d");
    ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
    bitmap = offscreen.transferToImageBitmap();
  }
  return bitmap;
};
_drawBitmap = new WeakSet();
drawBitmap_fn = function() {
  const [parentWidth, parentHeight] = this.parentDimensions;
  const {
    width,
    height
  } = this;
  const outputScale = new OutputScale();
  const scaledWidth = Math.ceil(width * parentWidth * outputScale.sx);
  const scaledHeight = Math.ceil(height * parentHeight * outputScale.sy);
  const canvas = __privateGet(this, _canvas);
  if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {
    return;
  }
  canvas.width = scaledWidth;
  canvas.height = scaledHeight;
  const bitmap = __privateGet(this, _isSvg) ? __privateGet(this, _bitmap) : __privateMethod(this, _scaleBitmap, scaleBitmap_fn).call(this, scaledWidth, scaledHeight);
  const ctx = canvas.getContext("2d");
  ctx.filter = this._uiManager.hcmFilter;
  ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);
};
_serializeBitmap = new WeakSet();
serializeBitmap_fn = function(toUrl) {
  if (toUrl) {
    if (__privateGet(this, _isSvg)) {
      const url = this._uiManager.imageManager.getSvgUrl(__privateGet(this, _bitmapId));
      if (url) {
        return url;
      }
    }
    const canvas = document.createElement("canvas");
    ({
      width: canvas.width,
      height: canvas.height
    } = __privateGet(this, _bitmap));
    const ctx = canvas.getContext("2d");
    ctx.drawImage(__privateGet(this, _bitmap), 0, 0);
    return canvas.toDataURL();
  }
  if (__privateGet(this, _isSvg)) {
    const [pageWidth, pageHeight] = this.pageDimensions;
    const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);
    const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);
    const offscreen = new OffscreenCanvas(width, height);
    const ctx = offscreen.getContext("2d");
    ctx.drawImage(__privateGet(this, _bitmap), 0, 0, __privateGet(this, _bitmap).width, __privateGet(this, _bitmap).height, 0, 0, width, height);
    return offscreen.transferToImageBitmap();
  }
  return structuredClone(__privateGet(this, _bitmap));
};
_hasElementChanged4 = new WeakSet();
hasElementChanged_fn4 = function(serialized) {
  var _a2;
  const {
    pageIndex,
    accessibilityData: {
      altText
    }
  } = this._initialData;
  const isSamePageIndex = serialized.pageIndex === pageIndex;
  const isSameAltText = (((_a2 = serialized.accessibilityData) == null ? void 0 : _a2.alt) || "") === altText;
  return {
    isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,
    isSameAltText
  };
};
__publicField(StampEditor, "_type", "stamp");
__publicField(StampEditor, "_editorType", AnnotationEditorType.STAMP);
var _accessibilityManager2, _allowClick, _annotationLayer, _clickAC, _editorFocusTimeoutId, _editors, _hadPointerDown, _isDisabling, _isEnabling, _drawingAC, _focusedElement, _textLayer, _textSelectionAC, _textLayerDblClickAC, _lastPointerDownTimestamp, _uiManager4, _editorTypes2, _allEditorsIterator, allEditorsIterator_get, _textLayerPointerDown, textLayerPointerDown_fn, _currentEditorType, currentEditorType_get, _createNewEditor, createNewEditor_fn, _getCenterPoint, getCenterPoint_fn, _cleanup, cleanup_fn;
var _AnnotationEditorLayer = class _AnnotationEditorLayer {
  constructor({
    uiManager,
    pageIndex,
    div,
    structTreeLayer,
    accessibilityManager,
    annotationLayer,
    drawLayer,
    textLayer,
    viewport,
    l10n
  }) {
    __privateAdd(this, _allEditorsIterator);
    __privateAdd(this, _textLayerPointerDown);
    __privateAdd(this, _currentEditorType);
    __privateAdd(this, _createNewEditor);
    __privateAdd(this, _getCenterPoint);
    __privateAdd(this, _cleanup);
    __privateAdd(this, _accessibilityManager2, void 0);
    __privateAdd(this, _allowClick, false);
    __privateAdd(this, _annotationLayer, null);
    __privateAdd(this, _clickAC, null);
    __privateAdd(this, _editorFocusTimeoutId, null);
    __privateAdd(this, _editors, /* @__PURE__ */ new Map());
    __privateAdd(this, _hadPointerDown, false);
    __privateAdd(this, _isDisabling, false);
    __privateAdd(this, _isEnabling, false);
    __privateAdd(this, _drawingAC, null);
    __privateAdd(this, _focusedElement, null);
    __privateAdd(this, _textLayer, null);
    __privateAdd(this, _textSelectionAC, null);
    __privateAdd(this, _textLayerDblClickAC, null);
    __privateAdd(this, _lastPointerDownTimestamp, -1);
    __privateAdd(this, _uiManager4, void 0);
    const editorTypes = [...__privateGet(_AnnotationEditorLayer, _editorTypes2).values()];
    if (!_AnnotationEditorLayer._initialized) {
      _AnnotationEditorLayer._initialized = true;
      for (const editorType of editorTypes) {
        editorType.initialize(l10n, uiManager);
      }
    }
    uiManager.registerEditorTypes(editorTypes);
    __privateSet(this, _uiManager4, uiManager);
    this.pageIndex = pageIndex;
    this.div = div;
    __privateSet(this, _accessibilityManager2, accessibilityManager);
    __privateSet(this, _annotationLayer, annotationLayer);
    this.viewport = viewport;
    __privateSet(this, _textLayer, textLayer);
    this.drawLayer = drawLayer;
    this._structTree = structTreeLayer;
    __privateGet(this, _uiManager4).addLayer(this);
  }
  get isEmpty() {
    return __privateGet(this, _editors).size === 0;
  }
  get isInvisible() {
    return this.isEmpty && __privateGet(this, _uiManager4).getMode() === AnnotationEditorType.NONE;
  }
  updateToolbar(options) {
    __privateGet(this, _uiManager4).updateToolbar(options);
  }
  updateMode(mode = __privateGet(this, _uiManager4).getMode()) {
    __privateMethod(this, _cleanup, cleanup_fn).call(this);
    switch (mode) {
      case AnnotationEditorType.NONE:
        this.div.classList.toggle("nonEditing", true);
        this.disableTextSelection();
        this.togglePointerEvents(false);
        this.toggleAnnotationLayerPointerEvents(true);
        this.disableClick();
        return;
      case AnnotationEditorType.INK:
        this.disableTextSelection();
        this.togglePointerEvents(true);
        this.enableClick();
        break;
      case AnnotationEditorType.HIGHLIGHT:
        this.enableTextSelection();
        this.togglePointerEvents(false);
        this.disableClick();
        break;
      default:
        this.disableTextSelection();
        this.togglePointerEvents(true);
        this.enableClick();
    }
    this.toggleAnnotationLayerPointerEvents(false);
    const {
      classList
    } = this.div;
    classList.toggle("nonEditing", false);
    if (mode === AnnotationEditorType.POPUP) {
      classList.toggle("commentEditing", true);
    } else {
      classList.toggle("commentEditing", false);
      for (const editorType of __privateGet(_AnnotationEditorLayer, _editorTypes2).values()) {
        classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);
      }
    }
    this.div.hidden = false;
  }
  hasTextLayer(textLayer) {
    var _a2;
    return textLayer === ((_a2 = __privateGet(this, _textLayer)) == null ? void 0 : _a2.div);
  }
  setEditingState(isEditing) {
    __privateGet(this, _uiManager4).setEditingState(isEditing);
  }
  addCommands(params) {
    __privateGet(this, _uiManager4).addCommands(params);
  }
  cleanUndoStack(type) {
    __privateGet(this, _uiManager4).cleanUndoStack(type);
  }
  toggleDrawing(enabled = false) {
    this.div.classList.toggle("drawing", !enabled);
  }
  togglePointerEvents(enabled = false) {
    this.div.classList.toggle("disabled", !enabled);
  }
  toggleAnnotationLayerPointerEvents(enabled = false) {
    var _a2;
    (_a2 = __privateGet(this, _annotationLayer)) == null ? void 0 : _a2.div.classList.toggle("disabled", !enabled);
  }
  async enable() {
    var _a2;
    __privateSet(this, _isEnabling, true);
    this.div.tabIndex = 0;
    this.togglePointerEvents(true);
    this.div.classList.toggle("nonEditing", false);
    (_a2 = __privateGet(this, _textLayerDblClickAC)) == null ? void 0 : _a2.abort();
    __privateSet(this, _textLayerDblClickAC, null);
    const annotationElementIds = /* @__PURE__ */ new Set();
    for (const editor of __privateGet(this, _allEditorsIterator, allEditorsIterator_get)) {
      editor.enableEditing();
      editor.show(true);
      if (editor.annotationElementId) {
        __privateGet(this, _uiManager4).removeChangedExistingAnnotation(editor);
        annotationElementIds.add(editor.annotationElementId);
      }
    }
    const annotationLayer = __privateGet(this, _annotationLayer);
    if (annotationLayer) {
      for (const editable of annotationLayer.getEditableAnnotations()) {
        editable.hide();
        if (__privateGet(this, _uiManager4).isDeletedAnnotationElement(editable.data.id)) {
          continue;
        }
        if (annotationElementIds.has(editable.data.id)) {
          continue;
        }
        const editor = await this.deserialize(editable);
        if (!editor) {
          continue;
        }
        this.addOrRebuild(editor);
        editor.enableEditing();
      }
    }
    __privateSet(this, _isEnabling, false);
    __privateGet(this, _uiManager4)._eventBus.dispatch("editorsrendered", {
      source: this,
      pageNumber: this.pageIndex + 1
    });
  }
  disable() {
    var _a2;
    __privateSet(this, _isDisabling, true);
    this.div.tabIndex = -1;
    this.togglePointerEvents(false);
    this.div.classList.toggle("nonEditing", true);
    if (__privateGet(this, _textLayer) && !__privateGet(this, _textLayerDblClickAC)) {
      __privateSet(this, _textLayerDblClickAC, new AbortController());
      const signal = __privateGet(this, _uiManager4).combinedSignal(__privateGet(this, _textLayerDblClickAC));
      __privateGet(this, _textLayer).div.addEventListener("pointerdown", (e) => {
        const DBL_CLICK_THRESHOLD = 500;
        const {
          clientX,
          clientY,
          timeStamp
        } = e;
        const lastPointerDownTimestamp = __privateGet(this, _lastPointerDownTimestamp);
        if (timeStamp - lastPointerDownTimestamp > DBL_CLICK_THRESHOLD) {
          __privateSet(this, _lastPointerDownTimestamp, timeStamp);
          return;
        }
        __privateSet(this, _lastPointerDownTimestamp, -1);
        const {
          classList: classList2
        } = this.div;
        classList2.toggle("getElements", true);
        const elements = document.elementsFromPoint(clientX, clientY);
        classList2.toggle("getElements", false);
        if (!this.div.contains(elements[0])) {
          return;
        }
        let id;
        const regex = new RegExp(`^${AnnotationEditorPrefix}[0-9]+$`);
        for (const element of elements) {
          if (regex.test(element.id)) {
            id = element.id;
            break;
          }
        }
        if (!id) {
          return;
        }
        const editor = __privateGet(this, _editors).get(id);
        if ((editor == null ? void 0 : editor.annotationElementId) === null) {
          e.stopPropagation();
          e.preventDefault();
          editor.dblclick(e);
        }
      }, {
        signal,
        capture: true
      });
    }
    const annotationLayer = __privateGet(this, _annotationLayer);
    if (annotationLayer) {
      const changedAnnotations = /* @__PURE__ */ new Map();
      const resetAnnotations = /* @__PURE__ */ new Map();
      for (const editor of __privateGet(this, _allEditorsIterator, allEditorsIterator_get)) {
        editor.disableEditing();
        if (!editor.annotationElementId) {
          editor.updateFakeAnnotationElement(annotationLayer);
          continue;
        }
        if (editor.serialize() !== null) {
          changedAnnotations.set(editor.annotationElementId, editor);
          continue;
        } else {
          resetAnnotations.set(editor.annotationElementId, editor);
        }
        (_a2 = this.getEditableAnnotation(editor.annotationElementId)) == null ? void 0 : _a2.show();
        editor.remove();
      }
      const editables = annotationLayer.getEditableAnnotations();
      for (const editable of editables) {
        const {
          id
        } = editable.data;
        if (__privateGet(this, _uiManager4).isDeletedAnnotationElement(id)) {
          editable.updateEdited({
            deleted: true
          });
          continue;
        }
        let editor = resetAnnotations.get(id);
        if (editor) {
          editor.resetAnnotationElement(editable);
          editor.show(false);
          editable.show();
          continue;
        }
        editor = changedAnnotations.get(id);
        if (editor) {
          __privateGet(this, _uiManager4).addChangedExistingAnnotation(editor);
          if (editor.renderAnnotationElement(editable)) {
            editor.show(false);
          }
        }
        editable.show();
      }
    }
    __privateMethod(this, _cleanup, cleanup_fn).call(this);
    if (this.isEmpty) {
      this.div.hidden = true;
    }
    const {
      classList
    } = this.div;
    for (const editorType of __privateGet(_AnnotationEditorLayer, _editorTypes2).values()) {
      classList.remove(`${editorType._type}Editing`);
    }
    this.disableTextSelection();
    this.toggleAnnotationLayerPointerEvents(true);
    __privateSet(this, _isDisabling, false);
  }
  getEditableAnnotation(id) {
    var _a2;
    return ((_a2 = __privateGet(this, _annotationLayer)) == null ? void 0 : _a2.getEditableAnnotation(id)) || null;
  }
  setActiveEditor(editor) {
    const currentActive = __privateGet(this, _uiManager4).getActive();
    if (currentActive === editor) {
      return;
    }
    __privateGet(this, _uiManager4).setActiveEditor(editor);
  }
  enableTextSelection() {
    var _a2;
    this.div.tabIndex = -1;
    if (((_a2 = __privateGet(this, _textLayer)) == null ? void 0 : _a2.div) && !__privateGet(this, _textSelectionAC)) {
      __privateSet(this, _textSelectionAC, new AbortController());
      const signal = __privateGet(this, _uiManager4).combinedSignal(__privateGet(this, _textSelectionAC));
      __privateGet(this, _textLayer).div.addEventListener("pointerdown", __privateMethod(this, _textLayerPointerDown, textLayerPointerDown_fn).bind(this), {
        signal
      });
      __privateGet(this, _textLayer).div.classList.add("highlighting");
    }
  }
  disableTextSelection() {
    var _a2;
    this.div.tabIndex = 0;
    if (((_a2 = __privateGet(this, _textLayer)) == null ? void 0 : _a2.div) && __privateGet(this, _textSelectionAC)) {
      __privateGet(this, _textSelectionAC).abort();
      __privateSet(this, _textSelectionAC, null);
      __privateGet(this, _textLayer).div.classList.remove("highlighting");
    }
  }
  enableClick() {
    if (__privateGet(this, _clickAC)) {
      return;
    }
    __privateSet(this, _clickAC, new AbortController());
    const signal = __privateGet(this, _uiManager4).combinedSignal(__privateGet(this, _clickAC));
    this.div.addEventListener("pointerdown", this.pointerdown.bind(this), {
      signal
    });
    const pointerup = this.pointerup.bind(this);
    this.div.addEventListener("pointerup", pointerup, {
      signal
    });
    this.div.addEventListener("pointercancel", pointerup, {
      signal
    });
  }
  disableClick() {
    var _a2;
    (_a2 = __privateGet(this, _clickAC)) == null ? void 0 : _a2.abort();
    __privateSet(this, _clickAC, null);
  }
  attach(editor) {
    __privateGet(this, _editors).set(editor.id, editor);
    const {
      annotationElementId
    } = editor;
    if (annotationElementId && __privateGet(this, _uiManager4).isDeletedAnnotationElement(annotationElementId)) {
      __privateGet(this, _uiManager4).removeDeletedAnnotationElement(editor);
    }
  }
  detach(editor) {
    var _a2;
    __privateGet(this, _editors).delete(editor.id);
    (_a2 = __privateGet(this, _accessibilityManager2)) == null ? void 0 : _a2.removePointerInTextLayer(editor.contentDiv);
    if (!__privateGet(this, _isDisabling) && editor.annotationElementId) {
      __privateGet(this, _uiManager4).addDeletedAnnotationElement(editor);
    }
  }
  remove(editor) {
    this.detach(editor);
    __privateGet(this, _uiManager4).removeEditor(editor);
    editor.div.remove();
    editor.isAttachedToDOM = false;
  }
  changeParent(editor) {
    var _a2;
    if (editor.parent === this) {
      return;
    }
    if (editor.parent && editor.annotationElementId) {
      __privateGet(this, _uiManager4).addDeletedAnnotationElement(editor.annotationElementId);
      AnnotationEditor.deleteAnnotationElement(editor);
      editor.annotationElementId = null;
    }
    this.attach(editor);
    (_a2 = editor.parent) == null ? void 0 : _a2.detach(editor);
    editor.setParent(this);
    if (editor.div && editor.isAttachedToDOM) {
      editor.div.remove();
      this.div.append(editor.div);
    }
  }
  add(editor) {
    if (editor.parent === this && editor.isAttachedToDOM) {
      return;
    }
    this.changeParent(editor);
    __privateGet(this, _uiManager4).addEditor(editor);
    this.attach(editor);
    if (!editor.isAttachedToDOM) {
      const div = editor.render();
      this.div.append(div);
      editor.isAttachedToDOM = true;
    }
    editor.fixAndSetPosition();
    editor.onceAdded(!__privateGet(this, _isEnabling));
    __privateGet(this, _uiManager4).addToAnnotationStorage(editor);
    editor._reportTelemetry(editor.telemetryInitialData);
  }
  moveEditorInDOM(editor) {
    var _a2;
    if (!editor.isAttachedToDOM) {
      return;
    }
    const {
      activeElement
    } = document;
    if (editor.div.contains(activeElement) && !__privateGet(this, _editorFocusTimeoutId)) {
      editor._focusEventsAllowed = false;
      __privateSet(this, _editorFocusTimeoutId, setTimeout(() => {
        __privateSet(this, _editorFocusTimeoutId, null);
        if (!editor.div.contains(document.activeElement)) {
          editor.div.addEventListener("focusin", () => {
            editor._focusEventsAllowed = true;
          }, {
            once: true,
            signal: __privateGet(this, _uiManager4)._signal
          });
          activeElement.focus();
        } else {
          editor._focusEventsAllowed = true;
        }
      }, 0));
    }
    editor._structTreeParentId = (_a2 = __privateGet(this, _accessibilityManager2)) == null ? void 0 : _a2.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
  }
  addOrRebuild(editor) {
    if (editor.needsToBeRebuilt()) {
      editor.parent || (editor.parent = this);
      editor.rebuild();
      editor.show();
    } else {
      this.add(editor);
    }
  }
  addUndoableEditor(editor) {
    const cmd = () => editor._uiManager.rebuild(editor);
    const undo = () => {
      editor.remove();
    };
    this.addCommands({
      cmd,
      undo,
      mustExec: false
    });
  }
  getEditorByUID(uid) {
    for (const editor of __privateGet(this, _editors).values()) {
      if (editor.uid === uid) {
        return editor;
      }
    }
    return null;
  }
  getNextId() {
    return __privateGet(this, _uiManager4).getId();
  }
  combinedSignal(ac) {
    return __privateGet(this, _uiManager4).combinedSignal(ac);
  }
  canCreateNewEmptyEditor() {
    var _a2;
    return (_a2 = __privateGet(this, _currentEditorType, currentEditorType_get)) == null ? void 0 : _a2.canCreateNewEmptyEditor();
  }
  async pasteEditor(options, params) {
    this.updateToolbar(options);
    await __privateGet(this, _uiManager4).updateMode(options.mode);
    const {
      offsetX,
      offsetY
    } = __privateMethod(this, _getCenterPoint, getCenterPoint_fn).call(this);
    const id = this.getNextId();
    const editor = __privateMethod(this, _createNewEditor, createNewEditor_fn).call(this, {
      parent: this,
      id,
      x: offsetX,
      y: offsetY,
      uiManager: __privateGet(this, _uiManager4),
      isCentered: true,
      ...params
    });
    if (editor) {
      this.add(editor);
    }
  }
  async deserialize(data) {
    var _a2;
    return await ((_a2 = __privateGet(_AnnotationEditorLayer, _editorTypes2).get(data.annotationType ?? data.annotationEditorType)) == null ? void 0 : _a2.deserialize(data, this, __privateGet(this, _uiManager4))) || null;
  }
  createAndAddNewEditor(event, isCentered, data = {}) {
    const id = this.getNextId();
    const editor = __privateMethod(this, _createNewEditor, createNewEditor_fn).call(this, {
      parent: this,
      id,
      x: event.offsetX,
      y: event.offsetY,
      uiManager: __privateGet(this, _uiManager4),
      isCentered,
      ...data
    });
    if (editor) {
      this.add(editor);
    }
    return editor;
  }
  get boundingClientRect() {
    return this.div.getBoundingClientRect();
  }
  addNewEditor(data = {}) {
    this.createAndAddNewEditor(__privateMethod(this, _getCenterPoint, getCenterPoint_fn).call(this), true, data);
  }
  setSelected(editor) {
    __privateGet(this, _uiManager4).setSelected(editor);
  }
  toggleSelected(editor) {
    __privateGet(this, _uiManager4).toggleSelected(editor);
  }
  unselect(editor) {
    __privateGet(this, _uiManager4).unselect(editor);
  }
  pointerup(event) {
    var _a2;
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    if (event.target !== this.div) {
      return;
    }
    if (!__privateGet(this, _hadPointerDown)) {
      return;
    }
    __privateSet(this, _hadPointerDown, false);
    if (((_a2 = __privateGet(this, _currentEditorType, currentEditorType_get)) == null ? void 0 : _a2.isDrawer) && __privateGet(this, _currentEditorType, currentEditorType_get).supportMultipleDrawings) {
      return;
    }
    if (!__privateGet(this, _allowClick)) {
      __privateSet(this, _allowClick, true);
      return;
    }
    const currentMode = __privateGet(this, _uiManager4).getMode();
    if (currentMode === AnnotationEditorType.STAMP || currentMode === AnnotationEditorType.SIGNATURE) {
      __privateGet(this, _uiManager4).unselectAll();
      return;
    }
    this.createAndAddNewEditor(event, false);
  }
  pointerdown(event) {
    var _a2;
    if (__privateGet(this, _uiManager4).getMode() === AnnotationEditorType.HIGHLIGHT) {
      this.enableTextSelection();
    }
    if (__privateGet(this, _hadPointerDown)) {
      __privateSet(this, _hadPointerDown, false);
      return;
    }
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    if (event.target !== this.div) {
      return;
    }
    __privateSet(this, _hadPointerDown, true);
    if ((_a2 = __privateGet(this, _currentEditorType, currentEditorType_get)) == null ? void 0 : _a2.isDrawer) {
      this.startDrawingSession(event);
      return;
    }
    const editor = __privateGet(this, _uiManager4).getActive();
    __privateSet(this, _allowClick, !editor || editor.isEmpty());
  }
  startDrawingSession(event) {
    this.div.focus({
      preventScroll: true
    });
    if (__privateGet(this, _drawingAC)) {
      __privateGet(this, _currentEditorType, currentEditorType_get).startDrawing(this, __privateGet(this, _uiManager4), false, event);
      return;
    }
    __privateGet(this, _uiManager4).setCurrentDrawingSession(this);
    __privateSet(this, _drawingAC, new AbortController());
    const signal = __privateGet(this, _uiManager4).combinedSignal(__privateGet(this, _drawingAC));
    this.div.addEventListener("blur", ({
      relatedTarget
    }) => {
      if (relatedTarget && !this.div.contains(relatedTarget)) {
        __privateSet(this, _focusedElement, null);
        this.commitOrRemove();
      }
    }, {
      signal
    });
    __privateGet(this, _currentEditorType, currentEditorType_get).startDrawing(this, __privateGet(this, _uiManager4), false, event);
  }
  pause(on) {
    if (on) {
      const {
        activeElement
      } = document;
      if (this.div.contains(activeElement)) {
        __privateSet(this, _focusedElement, activeElement);
      }
      return;
    }
    if (__privateGet(this, _focusedElement)) {
      setTimeout(() => {
        var _a2;
        (_a2 = __privateGet(this, _focusedElement)) == null ? void 0 : _a2.focus();
        __privateSet(this, _focusedElement, null);
      }, 0);
    }
  }
  endDrawingSession(isAborted = false) {
    if (!__privateGet(this, _drawingAC)) {
      return null;
    }
    __privateGet(this, _uiManager4).setCurrentDrawingSession(null);
    __privateGet(this, _drawingAC).abort();
    __privateSet(this, _drawingAC, null);
    __privateSet(this, _focusedElement, null);
    return __privateGet(this, _currentEditorType, currentEditorType_get).endDrawing(isAborted);
  }
  findNewParent(editor, x, y) {
    const layer = __privateGet(this, _uiManager4).findParent(x, y);
    if (layer === null || layer === this) {
      return false;
    }
    layer.changeParent(editor);
    return true;
  }
  commitOrRemove() {
    if (__privateGet(this, _drawingAC)) {
      this.endDrawingSession();
      return true;
    }
    return false;
  }
  onScaleChanging() {
    if (!__privateGet(this, _drawingAC)) {
      return;
    }
    __privateGet(this, _currentEditorType, currentEditorType_get).onScaleChangingWhenDrawing(this);
  }
  destroy() {
    var _a2, _b;
    this.commitOrRemove();
    if (((_a2 = __privateGet(this, _uiManager4).getActive()) == null ? void 0 : _a2.parent) === this) {
      __privateGet(this, _uiManager4).commitOrRemove();
      __privateGet(this, _uiManager4).setActiveEditor(null);
    }
    if (__privateGet(this, _editorFocusTimeoutId)) {
      clearTimeout(__privateGet(this, _editorFocusTimeoutId));
      __privateSet(this, _editorFocusTimeoutId, null);
    }
    for (const editor of __privateGet(this, _editors).values()) {
      (_b = __privateGet(this, _accessibilityManager2)) == null ? void 0 : _b.removePointerInTextLayer(editor.contentDiv);
      editor.setParent(null);
      editor.isAttachedToDOM = false;
      editor.div.remove();
    }
    this.div = null;
    __privateGet(this, _editors).clear();
    __privateGet(this, _uiManager4).removeLayer(this);
  }
  render({
    viewport
  }) {
    this.viewport = viewport;
    setLayerDimensions(this.div, viewport);
    for (const editor of __privateGet(this, _uiManager4).getEditors(this.pageIndex)) {
      this.add(editor);
      editor.rebuild();
    }
    this.updateMode();
  }
  update({
    viewport
  }) {
    __privateGet(this, _uiManager4).commitOrRemove();
    __privateMethod(this, _cleanup, cleanup_fn).call(this);
    const oldRotation = this.viewport.rotation;
    const rotation = viewport.rotation;
    this.viewport = viewport;
    setLayerDimensions(this.div, {
      rotation
    });
    if (oldRotation !== rotation) {
      for (const editor of __privateGet(this, _editors).values()) {
        editor.rotate(rotation);
      }
    }
  }
  get pageDimensions() {
    const {
      pageWidth,
      pageHeight
    } = this.viewport.rawDims;
    return [pageWidth, pageHeight];
  }
  get scale() {
    return __privateGet(this, _uiManager4).viewParameters.realScale;
  }
};
_accessibilityManager2 = new WeakMap();
_allowClick = new WeakMap();
_annotationLayer = new WeakMap();
_clickAC = new WeakMap();
_editorFocusTimeoutId = new WeakMap();
_editors = new WeakMap();
_hadPointerDown = new WeakMap();
_isDisabling = new WeakMap();
_isEnabling = new WeakMap();
_drawingAC = new WeakMap();
_focusedElement = new WeakMap();
_textLayer = new WeakMap();
_textSelectionAC = new WeakMap();
_textLayerDblClickAC = new WeakMap();
_lastPointerDownTimestamp = new WeakMap();
_uiManager4 = new WeakMap();
_editorTypes2 = new WeakMap();
_allEditorsIterator = new WeakSet();
allEditorsIterator_get = function() {
  return __privateGet(this, _editors).size !== 0 ? __privateGet(this, _editors).values() : __privateGet(this, _uiManager4).getEditors(this.pageIndex);
};
_textLayerPointerDown = new WeakSet();
textLayerPointerDown_fn = function(event) {
  __privateGet(this, _uiManager4).unselectAll();
  const {
    target
  } = event;
  if (target === __privateGet(this, _textLayer).div || (target.getAttribute("role") === "img" || target.classList.contains("endOfContent")) && __privateGet(this, _textLayer).div.contains(target)) {
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    __privateGet(this, _uiManager4).showAllEditors("highlight", true, true);
    __privateGet(this, _textLayer).div.classList.add("free");
    this.toggleDrawing();
    HighlightEditor.startHighlighting(this, __privateGet(this, _uiManager4).direction === "ltr", {
      target: __privateGet(this, _textLayer).div,
      x: event.x,
      y: event.y
    });
    __privateGet(this, _textLayer).div.addEventListener("pointerup", () => {
      __privateGet(this, _textLayer).div.classList.remove("free");
      this.toggleDrawing(true);
    }, {
      once: true,
      signal: __privateGet(this, _uiManager4)._signal
    });
    event.preventDefault();
  }
};
_currentEditorType = new WeakSet();
currentEditorType_get = function() {
  return __privateGet(_AnnotationEditorLayer, _editorTypes2).get(__privateGet(this, _uiManager4).getMode());
};
_createNewEditor = new WeakSet();
createNewEditor_fn = function(params) {
  const editorType = __privateGet(this, _currentEditorType, currentEditorType_get);
  return editorType ? new editorType.prototype.constructor(params) : null;
};
_getCenterPoint = new WeakSet();
getCenterPoint_fn = function() {
  const {
    x,
    y,
    width,
    height
  } = this.boundingClientRect;
  const tlX = Math.max(0, x);
  const tlY = Math.max(0, y);
  const brX = Math.min(window.innerWidth, x + width);
  const brY = Math.min(window.innerHeight, y + height);
  const centerX = (tlX + brX) / 2 - x;
  const centerY = (tlY + brY) / 2 - y;
  const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];
  return {
    offsetX,
    offsetY
  };
};
_cleanup = new WeakSet();
cleanup_fn = function() {
  for (const editor of __privateGet(this, _editors).values()) {
    if (editor.isEmpty()) {
      editor.remove();
    }
  }
};
__publicField(_AnnotationEditorLayer, "_initialized", false);
__privateAdd(_AnnotationEditorLayer, _editorTypes2, new Map([FreeTextEditor, InkEditor, StampEditor, HighlightEditor, SignatureEditor].map((type) => [type._editorType, type])));
var AnnotationEditorLayer = _AnnotationEditorLayer;
var _parent2, _mapping, _toUpdate, _id5, _setBox, setBox_fn, _createSVG, createSVG_fn, _createClipPath, createClipPath_fn, _updateProperties, updateProperties_fn;
var _DrawLayer = class _DrawLayer {
  constructor({
    pageIndex
  }) {
    __privateAdd(this, _createSVG);
    __privateAdd(this, _createClipPath);
    __privateAdd(this, _updateProperties);
    __privateAdd(this, _parent2, null);
    __privateAdd(this, _mapping, /* @__PURE__ */ new Map());
    __privateAdd(this, _toUpdate, /* @__PURE__ */ new Map());
    this.pageIndex = pageIndex;
  }
  setParent(parent) {
    if (!__privateGet(this, _parent2)) {
      __privateSet(this, _parent2, parent);
      return;
    }
    if (__privateGet(this, _parent2) !== parent) {
      if (__privateGet(this, _mapping).size > 0) {
        for (const root of __privateGet(this, _mapping).values()) {
          root.remove();
          parent.append(root);
        }
      }
      __privateSet(this, _parent2, parent);
    }
  }
  static get _svgFactory() {
    return shadow(this, "_svgFactory", new DOMSVGFactory());
  }
  draw(properties, isPathUpdatable = false, hasClip = false) {
    const id = __privateWrapper(_DrawLayer, _id5)._++;
    const root = __privateMethod(this, _createSVG, createSVG_fn).call(this);
    const defs = _DrawLayer._svgFactory.createElement("defs");
    root.append(defs);
    const path = _DrawLayer._svgFactory.createElement("path");
    defs.append(path);
    const pathId = `path_p${this.pageIndex}_${id}`;
    path.setAttribute("id", pathId);
    path.setAttribute("vector-effect", "non-scaling-stroke");
    if (isPathUpdatable) {
      __privateGet(this, _toUpdate).set(id, path);
    }
    const clipPathId = hasClip ? __privateMethod(this, _createClipPath, createClipPath_fn).call(this, defs, pathId) : null;
    const use = _DrawLayer._svgFactory.createElement("use");
    root.append(use);
    use.setAttribute("href", `#${pathId}`);
    this.updateProperties(root, properties);
    __privateGet(this, _mapping).set(id, root);
    return {
      id,
      clipPathId: `url(#${clipPathId})`
    };
  }
  drawOutline(properties, mustRemoveSelfIntersections) {
    const id = __privateWrapper(_DrawLayer, _id5)._++;
    const root = __privateMethod(this, _createSVG, createSVG_fn).call(this);
    const defs = _DrawLayer._svgFactory.createElement("defs");
    root.append(defs);
    const path = _DrawLayer._svgFactory.createElement("path");
    defs.append(path);
    const pathId = `path_p${this.pageIndex}_${id}`;
    path.setAttribute("id", pathId);
    path.setAttribute("vector-effect", "non-scaling-stroke");
    let maskId;
    if (mustRemoveSelfIntersections) {
      const mask = _DrawLayer._svgFactory.createElement("mask");
      defs.append(mask);
      maskId = `mask_p${this.pageIndex}_${id}`;
      mask.setAttribute("id", maskId);
      mask.setAttribute("maskUnits", "objectBoundingBox");
      const rect = _DrawLayer._svgFactory.createElement("rect");
      mask.append(rect);
      rect.setAttribute("width", "1");
      rect.setAttribute("height", "1");
      rect.setAttribute("fill", "white");
      const use = _DrawLayer._svgFactory.createElement("use");
      mask.append(use);
      use.setAttribute("href", `#${pathId}`);
      use.setAttribute("stroke", "none");
      use.setAttribute("fill", "black");
      use.setAttribute("fill-rule", "nonzero");
      use.classList.add("mask");
    }
    const use1 = _DrawLayer._svgFactory.createElement("use");
    root.append(use1);
    use1.setAttribute("href", `#${pathId}`);
    if (maskId) {
      use1.setAttribute("mask", `url(#${maskId})`);
    }
    const use2 = use1.cloneNode();
    root.append(use2);
    use1.classList.add("mainOutline");
    use2.classList.add("secondaryOutline");
    this.updateProperties(root, properties);
    __privateGet(this, _mapping).set(id, root);
    return id;
  }
  finalizeDraw(id, properties) {
    __privateGet(this, _toUpdate).delete(id);
    this.updateProperties(id, properties);
  }
  updateProperties(elementOrId, properties) {
    var _a2;
    if (!properties) {
      return;
    }
    const {
      root,
      bbox,
      rootClass,
      path
    } = properties;
    const element = typeof elementOrId === "number" ? __privateGet(this, _mapping).get(elementOrId) : elementOrId;
    if (!element) {
      return;
    }
    if (root) {
      __privateMethod(this, _updateProperties, updateProperties_fn).call(this, element, root);
    }
    if (bbox) {
      __privateMethod(_a2 = _DrawLayer, _setBox, setBox_fn).call(_a2, element, bbox);
    }
    if (rootClass) {
      const {
        classList
      } = element;
      for (const [className, value] of Object.entries(rootClass)) {
        classList.toggle(className, value);
      }
    }
    if (path) {
      const defs = element.firstChild;
      const pathElement = defs.firstChild;
      __privateMethod(this, _updateProperties, updateProperties_fn).call(this, pathElement, path);
    }
  }
  updateParent(id, layer) {
    if (layer === this) {
      return;
    }
    const root = __privateGet(this, _mapping).get(id);
    if (!root) {
      return;
    }
    __privateGet(layer, _parent2).append(root);
    __privateGet(this, _mapping).delete(id);
    __privateGet(layer, _mapping).set(id, root);
  }
  remove(id) {
    __privateGet(this, _toUpdate).delete(id);
    if (__privateGet(this, _parent2) === null) {
      return;
    }
    __privateGet(this, _mapping).get(id).remove();
    __privateGet(this, _mapping).delete(id);
  }
  destroy() {
    __privateSet(this, _parent2, null);
    for (const root of __privateGet(this, _mapping).values()) {
      root.remove();
    }
    __privateGet(this, _mapping).clear();
    __privateGet(this, _toUpdate).clear();
  }
};
_parent2 = new WeakMap();
_mapping = new WeakMap();
_toUpdate = new WeakMap();
_id5 = new WeakMap();
_setBox = new WeakSet();
setBox_fn = function(element, [x, y, width, height]) {
  const {
    style
  } = element;
  style.top = `${100 * y}%`;
  style.left = `${100 * x}%`;
  style.width = `${100 * width}%`;
  style.height = `${100 * height}%`;
};
_createSVG = new WeakSet();
createSVG_fn = function() {
  const svg = _DrawLayer._svgFactory.create(1, 1, true);
  __privateGet(this, _parent2).append(svg);
  svg.setAttribute("aria-hidden", true);
  return svg;
};
_createClipPath = new WeakSet();
createClipPath_fn = function(defs, pathId) {
  const clipPath = _DrawLayer._svgFactory.createElement("clipPath");
  defs.append(clipPath);
  const clipPathId = `clip_${pathId}`;
  clipPath.setAttribute("id", clipPathId);
  clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
  const clipPathUse = _DrawLayer._svgFactory.createElement("use");
  clipPath.append(clipPathUse);
  clipPathUse.setAttribute("href", `#${pathId}`);
  clipPathUse.classList.add("clip");
  return clipPathId;
};
_updateProperties = new WeakSet();
updateProperties_fn = function(element, properties) {
  for (const [key, value] of Object.entries(properties)) {
    if (value === null) {
      element.removeAttribute(key);
    } else {
      element.setAttribute(key, value);
    }
  }
};
__privateAdd(_DrawLayer, _setBox);
__privateAdd(_DrawLayer, _id5, 0);
var DrawLayer = _DrawLayer;
{
  globalThis._pdfjsTestingUtils = {
    HighlightOutliner
  };
}
globalThis.pdfjsLib = {
  AbortException,
  AnnotationEditorLayer,
  AnnotationEditorParamsType,
  AnnotationEditorType,
  AnnotationEditorUIManager,
  AnnotationLayer,
  AnnotationMode,
  AnnotationType,
  applyOpacity,
  build,
  ColorPicker,
  createValidAbsoluteUrl,
  CSSConstants,
  DOMSVGFactory,
  DrawLayer,
  FeatureTest: util_FeatureTest,
  fetchData,
  findContrastColor,
  getDocument,
  getFilenameFromUrl,
  getPdfFilenameFromUrl,
  getRGB,
  getUuid,
  getXfaPageViewport,
  GlobalWorkerOptions,
  ImageKind: util_ImageKind,
  InvalidPDFException,
  isDataScheme,
  isPdfFile,
  isValidExplicitDest,
  MathClamp,
  noContextMenu,
  normalizeUnicode,
  OPS,
  OutputScale,
  PasswordResponses,
  PDFDataRangeTransport,
  PDFDateString,
  PDFWorker,
  PermissionFlag,
  PixelsPerInch,
  RenderingCancelledException,
  renderRichText,
  ResponseException,
  setLayerDimensions,
  shadow,
  SignatureExtractor,
  stopEvent,
  SupportedImageMimeTypes,
  TextLayer,
  TouchManager,
  updateUrlHash,
  Util,
  VerbosityLevel,
  version,
  XfaLayer
};

// node_modules/react-pdf/dist/Document.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e)
    n += e;
  else if ("object" == typeof e)
    if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++)
        e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else
      for (f in e)
        e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++)
    (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_default = clsx;

// node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar))
      return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!bar.has(tmp))
          return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len))
          ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len])
          ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
          return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// node_modules/make-cancellable-promise/dist/index.js
function makeCancellablePromise(promise) {
  let isCancelled = false;
  const wrappedPromise = new Promise((resolve, reject) => {
    promise.then((value) => !isCancelled && resolve(value)).catch((error) => !isCancelled && reject(error));
  });
  return {
    promise: wrappedPromise,
    cancel() {
      isCancelled = true;
    }
  };
}

// node_modules/make-event-props/dist/index.js
var clipboardEvents = ["onCopy", "onCut", "onPaste"];
var compositionEvents = [
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate"
];
var focusEvents = ["onFocus", "onBlur"];
var formEvents = ["onInput", "onInvalid", "onReset", "onSubmit"];
var imageEvents = ["onLoad", "onError"];
var keyboardEvents = ["onKeyDown", "onKeyPress", "onKeyUp"];
var mediaEvents = [
  "onAbort",
  "onCanPlay",
  "onCanPlayThrough",
  "onDurationChange",
  "onEmptied",
  "onEncrypted",
  "onEnded",
  "onError",
  "onLoadedData",
  "onLoadedMetadata",
  "onLoadStart",
  "onPause",
  "onPlay",
  "onPlaying",
  "onProgress",
  "onRateChange",
  "onSeeked",
  "onSeeking",
  "onStalled",
  "onSuspend",
  "onTimeUpdate",
  "onVolumeChange",
  "onWaiting"
];
var mouseEvents = [
  "onClick",
  "onContextMenu",
  "onDoubleClick",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp"
];
var dragEvents = [
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop"
];
var selectionEvents = ["onSelect"];
var touchEvents = ["onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart"];
var pointerEvents = [
  "onPointerDown",
  "onPointerMove",
  "onPointerUp",
  "onPointerCancel",
  "onGotPointerCapture",
  "onLostPointerCapture",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerOver",
  "onPointerOut"
];
var uiEvents = ["onScroll"];
var wheelEvents = ["onWheel"];
var animationEvents = [
  "onAnimationStart",
  "onAnimationEnd",
  "onAnimationIteration"
];
var transitionEvents = ["onTransitionEnd"];
var otherEvents = ["onToggle"];
var changeEvents = ["onChange"];
var allEvents = [
  ...clipboardEvents,
  ...compositionEvents,
  ...focusEvents,
  ...formEvents,
  ...imageEvents,
  ...keyboardEvents,
  ...mediaEvents,
  ...mouseEvents,
  ...dragEvents,
  ...selectionEvents,
  ...touchEvents,
  ...pointerEvents,
  ...uiEvents,
  ...wheelEvents,
  ...animationEvents,
  ...transitionEvents,
  ...changeEvents,
  ...otherEvents
];
function makeEventProps(props, getArgs) {
  const eventProps = {};
  for (const eventName of allEvents) {
    const eventHandler = props[eventName];
    if (!eventHandler) {
      continue;
    }
    if (getArgs) {
      eventProps[eventName] = (event) => eventHandler(event, getArgs(eventName));
    } else {
      eventProps[eventName] = eventHandler;
    }
  }
  return eventProps;
}

// node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// node_modules/react-pdf/dist/Document.js
var import_warning2 = __toESM(require_warning(), 1);

// node_modules/react-pdf/dist/DocumentContext.js
var import_react = __toESM(require_react(), 1);
var documentContext = (0, import_react.createContext)(null);
var DocumentContext_default = documentContext;

// node_modules/react-pdf/dist/LinkService.js
var DEFAULT_LINK_REL = "noopener noreferrer nofollow";
var LinkService = class {
  constructor() {
    this.externalLinkEnabled = true;
    this.externalLinkRel = void 0;
    this.externalLinkTarget = void 0;
    this.isInPresentationMode = false;
    this.pdfDocument = void 0;
    this.pdfViewer = void 0;
  }
  setDocument(pdfDocument) {
    this.pdfDocument = pdfDocument;
  }
  setViewer(pdfViewer) {
    this.pdfViewer = pdfViewer;
  }
  setExternalLinkRel(externalLinkRel) {
    this.externalLinkRel = externalLinkRel;
  }
  setExternalLinkTarget(externalLinkTarget) {
    this.externalLinkTarget = externalLinkTarget;
  }
  setHash() {
  }
  setHistory() {
  }
  get pagesCount() {
    return this.pdfDocument ? this.pdfDocument.numPages : 0;
  }
  get page() {
    invariant(this.pdfViewer, "PDF viewer is not initialized.");
    return this.pdfViewer.currentPageNumber || 0;
  }
  set page(value) {
    invariant(this.pdfViewer, "PDF viewer is not initialized.");
    this.pdfViewer.currentPageNumber = value;
  }
  get rotation() {
    return 0;
  }
  set rotation(_value) {
  }
  addLinkAttributes(link, url, newWindow) {
    link.href = url;
    link.rel = this.externalLinkRel || DEFAULT_LINK_REL;
    link.target = newWindow ? "_blank" : this.externalLinkTarget || "";
  }
  goToDestination(dest) {
    return new Promise((resolve) => {
      invariant(this.pdfDocument, "PDF document not loaded.");
      invariant(dest, "Destination is not specified.");
      if (typeof dest === "string") {
        this.pdfDocument.getDestination(dest).then(resolve);
      } else if (Array.isArray(dest)) {
        resolve(dest);
      } else {
        dest.then(resolve);
      }
    }).then((explicitDest) => {
      invariant(Array.isArray(explicitDest), `"${explicitDest}" is not a valid destination array.`);
      const destRef = explicitDest[0];
      new Promise((resolve) => {
        invariant(this.pdfDocument, "PDF document not loaded.");
        if (destRef instanceof Object) {
          this.pdfDocument.getPageIndex(destRef).then((pageIndex) => {
            resolve(pageIndex);
          }).catch(() => {
            invariant(false, `"${destRef}" is not a valid page reference.`);
          });
        } else if (typeof destRef === "number") {
          resolve(destRef);
        } else {
          invariant(false, `"${destRef}" is not a valid destination reference.`);
        }
      }).then((pageIndex) => {
        const pageNumber = pageIndex + 1;
        invariant(this.pdfViewer, "PDF viewer is not initialized.");
        invariant(pageNumber >= 1 && pageNumber <= this.pagesCount, `"${pageNumber}" is not a valid page number.`);
        this.pdfViewer.scrollPageIntoView({
          dest: explicitDest,
          pageIndex,
          pageNumber
        });
      });
    });
  }
  goToPage(pageNumber) {
    const pageIndex = pageNumber - 1;
    invariant(this.pdfViewer, "PDF viewer is not initialized.");
    invariant(pageNumber >= 1 && pageNumber <= this.pagesCount, `"${pageNumber}" is not a valid page number.`);
    this.pdfViewer.scrollPageIntoView({
      pageIndex,
      pageNumber
    });
  }
  goToXY() {
  }
  cachePageRef() {
  }
  getDestinationHash() {
    return "#";
  }
  getAnchorUrl() {
    return "#";
  }
  executeNamedAction() {
  }
  executeSetOCGState() {
  }
  isPageVisible() {
    return true;
  }
  isPageCached() {
    return true;
  }
  navigateTo(dest) {
    this.goToDestination(dest);
  }
};

// node_modules/react-pdf/dist/Message.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function Message({ children, type }) {
  return (0, import_jsx_runtime.jsx)("div", { className: `react-pdf__message react-pdf__message--${type}`, children });
}

// node_modules/react-pdf/dist/PasswordResponses.js
var PasswordResponses2 = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
var PasswordResponses_default = PasswordResponses2;

// node_modules/react-pdf/dist/shared/hooks/useResolver.js
var import_react2 = __toESM(require_react(), 1);
function reducer(state, action) {
  switch (action.type) {
    case "RESOLVE":
      return { value: action.value, error: void 0 };
    case "REJECT":
      return { value: false, error: action.error };
    case "RESET":
      return { value: void 0, error: void 0 };
    default:
      return state;
  }
}
function useResolver() {
  return (0, import_react2.useReducer)(reducer, { value: void 0, error: void 0 });
}

// node_modules/react-pdf/dist/shared/utils.js
var import_warning = __toESM(require_warning(), 1);
var isBrowser = typeof window !== "undefined";
var isLocalFileSystem = isBrowser && window.location.protocol === "file:";
function isDefined(variable) {
  return typeof variable !== "undefined";
}
function isProvided(variable) {
  return isDefined(variable) && variable !== null;
}
function isString(variable) {
  return typeof variable === "string";
}
function isArrayBuffer(variable) {
  return variable instanceof ArrayBuffer;
}
function isBlob(variable) {
  invariant(isBrowser, "isBlob can only be used in a browser environment");
  return variable instanceof Blob;
}
function isDataURI(variable) {
  return isString(variable) && /^data:/.test(variable);
}
function dataURItoByteString(dataURI) {
  invariant(isDataURI(dataURI), "Invalid data URI.");
  const [headersString = "", dataString = ""] = dataURI.split(",");
  const headers = headersString.split(";");
  if (headers.indexOf("base64") !== -1) {
    return atob(dataString);
  }
  return unescape(dataString);
}
function getDevicePixelRatio() {
  return isBrowser && window.devicePixelRatio || 1;
}
var allowFileAccessFromFilesTip = "On Chromium based browsers, you can use --allow-file-access-from-files flag for debugging purposes.";
function displayCORSWarning() {
  (0, import_warning.default)(!isLocalFileSystem, `Loading PDF as base64 strings/URLs may not work on protocols other than HTTP/HTTPS. ${allowFileAccessFromFilesTip}`);
}
function displayWorkerWarning() {
  (0, import_warning.default)(!isLocalFileSystem, `Loading PDF.js worker may not work on protocols other than HTTP/HTTPS. ${allowFileAccessFromFilesTip}`);
}
function cancelRunningTask(runningTask) {
  if (runningTask === null || runningTask === void 0 ? void 0 : runningTask.cancel)
    runningTask.cancel();
}
function makePageCallback(page, scale) {
  Object.defineProperty(page, "width", {
    get() {
      return this.getViewport({ scale }).width;
    },
    configurable: true
  });
  Object.defineProperty(page, "height", {
    get() {
      return this.getViewport({ scale }).height;
    },
    configurable: true
  });
  Object.defineProperty(page, "originalWidth", {
    get() {
      return this.getViewport({ scale: 1 }).width;
    },
    configurable: true
  });
  Object.defineProperty(page, "originalHeight", {
    get() {
      return this.getViewport({ scale: 1 }).height;
    },
    configurable: true
  });
  return page;
}
function isAbortException(error) {
  return error.name === "AbortException" || error.name === "RenderingCancelledException";
}
function loadFromFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      if (!reader.result) {
        return reject(new Error("Error while reading a file."));
      }
      resolve(reader.result);
    };
    reader.onerror = (event) => {
      if (!event.target) {
        return reject(new Error("Error while reading a file."));
      }
      const { error } = event.target;
      if (!error) {
        return reject(new Error("Error while reading a file."));
      }
      switch (error.code) {
        case error.NOT_FOUND_ERR:
          return reject(new Error("Error while reading a file: File not found."));
        case error.SECURITY_ERR:
          return reject(new Error("Error while reading a file: Security error."));
        case error.ABORT_ERR:
          return reject(new Error("Error while reading a file: Aborted."));
        default:
          return reject(new Error("Error while reading a file."));
      }
    };
    reader.readAsArrayBuffer(file);
  });
}

// node_modules/react-pdf/dist/Document.js
var { PDFDataRangeTransport: PDFDataRangeTransport2 } = pdf_exports;
var defaultOnPassword = (callback, reason) => {
  switch (reason) {
    case PasswordResponses_default.NEED_PASSWORD: {
      const password = prompt("Enter the password to open this PDF file.");
      callback(password);
      break;
    }
    case PasswordResponses_default.INCORRECT_PASSWORD: {
      const password = prompt("Invalid password. Please try again.");
      callback(password);
      break;
    }
    default:
  }
};
function isParameterObject(file) {
  return typeof file === "object" && file !== null && ("data" in file || "range" in file || "url" in file);
}
var Document = (0, import_react3.forwardRef)(function Document2({ children, className, error = "Failed to load PDF file.", externalLinkRel, externalLinkTarget, file, inputRef, imageResourcesPath, loading = "Loading PDF…", noData = "No PDF file specified.", onItemClick, onLoadError: onLoadErrorProps, onLoadProgress, onLoadSuccess: onLoadSuccessProps, onPassword = defaultOnPassword, onSourceError: onSourceErrorProps, onSourceSuccess: onSourceSuccessProps, options, renderMode, rotate, scale, ...otherProps }, ref) {
  const [sourceState, sourceDispatch] = useResolver();
  const { value: source, error: sourceError } = sourceState;
  const [pdfState, pdfDispatch] = useResolver();
  const { value: pdf, error: pdfError } = pdfState;
  const linkService = (0, import_react3.useRef)(new LinkService());
  const pages = (0, import_react3.useRef)([]);
  const prevFile = (0, import_react3.useRef)(void 0);
  const prevOptions = (0, import_react3.useRef)(void 0);
  if (file && file !== prevFile.current && isParameterObject(file)) {
    (0, import_warning2.default)(!dequal(file, prevFile.current), `File prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "file" prop.`);
    prevFile.current = file;
  }
  if (options && options !== prevOptions.current) {
    (0, import_warning2.default)(!dequal(options, prevOptions.current), `Options prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "options" prop.`);
    prevOptions.current = options;
  }
  const viewer = (0, import_react3.useRef)({
    // Handling jumping to internal links target
    scrollPageIntoView: (args) => {
      const { dest, pageNumber, pageIndex = pageNumber - 1 } = args;
      if (onItemClick) {
        onItemClick({ dest, pageIndex, pageNumber });
        return;
      }
      const page = pages.current[pageIndex];
      if (page) {
        page.scrollIntoView();
        return;
      }
      (0, import_warning2.default)(false, `An internal link leading to page ${pageNumber} was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>.`);
    }
  });
  (0, import_react3.useImperativeHandle)(ref, () => ({
    linkService,
    pages,
    viewer
  }), []);
  function onSourceSuccess() {
    if (onSourceSuccessProps) {
      onSourceSuccessProps();
    }
  }
  function onSourceError() {
    if (!sourceError) {
      return;
    }
    (0, import_warning2.default)(false, sourceError.toString());
    if (onSourceErrorProps) {
      onSourceErrorProps(sourceError);
    }
  }
  function resetSource() {
    sourceDispatch({ type: "RESET" });
  }
  (0, import_react3.useEffect)(resetSource, [file, sourceDispatch]);
  const findDocumentSource = (0, import_react3.useCallback)(async () => {
    if (!file) {
      return null;
    }
    if (typeof file === "string") {
      if (isDataURI(file)) {
        const fileByteString = dataURItoByteString(file);
        return { data: fileByteString };
      }
      displayCORSWarning();
      return { url: file };
    }
    if (file instanceof PDFDataRangeTransport2) {
      return { range: file };
    }
    if (isArrayBuffer(file)) {
      return { data: file };
    }
    if (isBrowser) {
      if (isBlob(file)) {
        const data = await loadFromFile(file);
        return { data };
      }
    }
    invariant(typeof file === "object", "Invalid parameter in file, need either Uint8Array, string or a parameter object");
    invariant(isParameterObject(file), "Invalid parameter object: need either .data, .range or .url");
    if ("url" in file && typeof file.url === "string") {
      if (isDataURI(file.url)) {
        const { url, ...otherParams } = file;
        const fileByteString = dataURItoByteString(url);
        return { data: fileByteString, ...otherParams };
      }
      displayCORSWarning();
    }
    return file;
  }, [file]);
  (0, import_react3.useEffect)(() => {
    const cancellable = makeCancellablePromise(findDocumentSource());
    cancellable.promise.then((nextSource) => {
      sourceDispatch({ type: "RESOLVE", value: nextSource });
    }).catch((error2) => {
      sourceDispatch({ type: "REJECT", error: error2 });
    });
    return () => {
      cancelRunningTask(cancellable);
    };
  }, [findDocumentSource, sourceDispatch]);
  (0, import_react3.useEffect)(() => {
    if (typeof source === "undefined") {
      return;
    }
    if (source === false) {
      onSourceError();
      return;
    }
    onSourceSuccess();
  }, [source]);
  function onLoadSuccess() {
    if (!pdf) {
      return;
    }
    if (onLoadSuccessProps) {
      onLoadSuccessProps(pdf);
    }
    pages.current = new Array(pdf.numPages);
    linkService.current.setDocument(pdf);
  }
  function onLoadError() {
    if (!pdfError) {
      return;
    }
    (0, import_warning2.default)(false, pdfError.toString());
    if (onLoadErrorProps) {
      onLoadErrorProps(pdfError);
    }
  }
  (0, import_react3.useEffect)(function resetDocument() {
    pdfDispatch({ type: "RESET" });
  }, [pdfDispatch, source]);
  (0, import_react3.useEffect)(function loadDocument() {
    if (!source) {
      return;
    }
    const documentInitParams = options ? { ...source, ...options } : source;
    const destroyable = getDocument(documentInitParams);
    if (onLoadProgress) {
      destroyable.onProgress = onLoadProgress;
    }
    if (onPassword) {
      destroyable.onPassword = onPassword;
    }
    const loadingTask = destroyable;
    loadingTask.promise.then((nextPdf) => {
      if (loadingTask.destroyed) {
        return;
      }
      pdfDispatch({ type: "RESOLVE", value: nextPdf });
    }).catch((error2) => {
      if (loadingTask.destroyed) {
        return;
      }
      pdfDispatch({ type: "REJECT", error: error2 });
    });
    return () => {
      loadingTask.destroy();
    };
  }, [options, pdfDispatch, source]);
  (0, import_react3.useEffect)(() => {
    if (typeof pdf === "undefined") {
      return;
    }
    if (pdf === false) {
      onLoadError();
      return;
    }
    onLoadSuccess();
  }, [pdf]);
  (0, import_react3.useEffect)(function setupLinkService() {
    linkService.current.setViewer(viewer.current);
    linkService.current.setExternalLinkRel(externalLinkRel);
    linkService.current.setExternalLinkTarget(externalLinkTarget);
  }, [externalLinkRel, externalLinkTarget]);
  const registerPage = (0, import_react3.useCallback)((pageIndex, ref2) => {
    pages.current[pageIndex] = ref2;
  }, []);
  const unregisterPage = (0, import_react3.useCallback)((pageIndex) => {
    delete pages.current[pageIndex];
  }, []);
  const childContext = (0, import_react3.useMemo)(() => ({
    imageResourcesPath,
    linkService: linkService.current,
    onItemClick,
    pdf,
    registerPage,
    renderMode,
    rotate,
    scale,
    unregisterPage
  }), [imageResourcesPath, onItemClick, pdf, registerPage, renderMode, rotate, scale, unregisterPage]);
  const eventProps = (0, import_react3.useMemo)(
    () => makeEventProps(otherProps, () => pdf),
    // biome-ignore lint/correctness/useExhaustiveDependencies: FIXME
    [otherProps, pdf]
  );
  function renderChildren() {
    function isFulfilledContext(context) {
      return Boolean(context === null || context === void 0 ? void 0 : context.pdf);
    }
    if (!isFulfilledContext(childContext)) {
      throw new Error("pdf is undefined");
    }
    const resolvedChildren = typeof children === "function" ? children(childContext) : children;
    return (0, import_jsx_runtime2.jsx)(DocumentContext_default.Provider, { value: childContext, children: resolvedChildren });
  }
  function renderContent() {
    if (!file) {
      return (0, import_jsx_runtime2.jsx)(Message, { type: "no-data", children: typeof noData === "function" ? noData() : noData });
    }
    if (pdf === void 0 || pdf === null) {
      return (0, import_jsx_runtime2.jsx)(Message, { type: "loading", children: typeof loading === "function" ? loading() : loading });
    }
    if (pdf === false) {
      return (0, import_jsx_runtime2.jsx)(Message, { type: "error", children: typeof error === "function" ? error() : error });
    }
    return renderChildren();
  }
  return (0, import_jsx_runtime2.jsx)("div", {
    className: clsx_default("react-pdf__Document", className),
    // Assertion is needed for React 18 compatibility
    ref: inputRef,
    ...eventProps,
    children: renderContent()
  });
});
var Document_default = Document;

// node_modules/react-pdf/dist/Outline.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_warning3 = __toESM(require_warning(), 1);

// node_modules/react-pdf/dist/OutlineContext.js
var import_react4 = __toESM(require_react(), 1);
var outlineContext = (0, import_react4.createContext)(null);
var OutlineContext_default = outlineContext;

// node_modules/react-pdf/dist/OutlineItem.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);

// node_modules/react-pdf/dist/Ref.js
var Ref = class {
  constructor({ num, gen }) {
    this.num = num;
    this.gen = gen;
  }
  toString() {
    let str = `${this.num}R`;
    if (this.gen !== 0) {
      str += this.gen;
    }
    return str;
  }
};

// node_modules/react-pdf/dist/shared/hooks/useCachedValue.js
var import_react5 = __toESM(require_react(), 1);
function useCachedValue(getter) {
  const ref = (0, import_react5.useRef)(void 0);
  const currentValue = ref.current;
  if (isDefined(currentValue)) {
    return () => currentValue;
  }
  return () => {
    const value = getter();
    ref.current = value;
    return value;
  };
}

// node_modules/react-pdf/dist/shared/hooks/useDocumentContext.js
var import_react6 = __toESM(require_react(), 1);
function useDocumentContext() {
  return (0, import_react6.useContext)(DocumentContext_default);
}

// node_modules/react-pdf/dist/shared/hooks/useOutlineContext.js
var import_react7 = __toESM(require_react(), 1);
function useOutlineContext() {
  return (0, import_react7.useContext)(OutlineContext_default);
}

// node_modules/react-pdf/dist/OutlineItem.js
function OutlineItem(props) {
  const documentContext2 = useDocumentContext();
  const outlineContext2 = useOutlineContext();
  invariant(outlineContext2, "Unable to find Outline context.");
  const mergedProps = { ...documentContext2, ...outlineContext2, ...props };
  const { item, linkService, onItemClick, pdf, ...otherProps } = mergedProps;
  invariant(pdf, "Attempted to load an outline, but no document was specified. Wrap <Outline /> in a <Document /> or pass explicit `pdf` prop.");
  const getDestination = useCachedValue(() => {
    if (typeof item.dest === "string") {
      return pdf.getDestination(item.dest);
    }
    return item.dest;
  });
  const getPageIndex = useCachedValue(async () => {
    const destination = await getDestination();
    if (!destination) {
      throw new Error("Destination not found.");
    }
    const [ref] = destination;
    return pdf.getPageIndex(new Ref(ref));
  });
  const getPageNumber = useCachedValue(async () => {
    const pageIndex = await getPageIndex();
    return pageIndex + 1;
  });
  function onClick(event) {
    event.preventDefault();
    invariant(onItemClick || linkService, "Either onItemClick callback or linkService must be defined in order to navigate to an outline item.");
    if (onItemClick) {
      Promise.all([getDestination(), getPageIndex(), getPageNumber()]).then(([dest, pageIndex, pageNumber]) => {
        onItemClick({
          dest,
          pageIndex,
          pageNumber
        });
      });
    } else if (linkService) {
      linkService.goToDestination(item.dest);
    }
  }
  function renderSubitems() {
    if (!item.items || !item.items.length) {
      return null;
    }
    const { items: subitems } = item;
    return (0, import_jsx_runtime3.jsx)("ul", { children: subitems.map((subitem, subitemIndex) => (0, import_jsx_runtime3.jsx)(OutlineItem, { item: subitem, pdf, ...otherProps }, typeof subitem.dest === "string" ? subitem.dest : subitemIndex)) });
  }
  return (0, import_jsx_runtime3.jsxs)("li", { children: [(0, import_jsx_runtime3.jsx)("a", { href: "#", onClick, children: item.title }), renderSubitems()] });
}

// node_modules/react-pdf/dist/Outline.js
function Outline2(props) {
  const documentContext2 = useDocumentContext();
  const mergedProps = { ...documentContext2, ...props };
  const { className, inputRef, onItemClick, onLoadError: onLoadErrorProps, onLoadSuccess: onLoadSuccessProps, pdf, ...otherProps } = mergedProps;
  invariant(pdf, "Attempted to load an outline, but no document was specified. Wrap <Outline /> in a <Document /> or pass explicit `pdf` prop.");
  const [outlineState, outlineDispatch] = useResolver();
  const { value: outline, error: outlineError } = outlineState;
  function onLoadSuccess() {
    if (typeof outline === "undefined" || outline === false) {
      return;
    }
    if (onLoadSuccessProps) {
      onLoadSuccessProps(outline);
    }
  }
  function onLoadError() {
    if (!outlineError) {
      return;
    }
    (0, import_warning3.default)(false, outlineError.toString());
    if (onLoadErrorProps) {
      onLoadErrorProps(outlineError);
    }
  }
  (0, import_react8.useEffect)(function resetOutline() {
    outlineDispatch({ type: "RESET" });
  }, [outlineDispatch, pdf]);
  (0, import_react8.useEffect)(function loadOutline() {
    const cancellable = makeCancellablePromise(pdf.getOutline());
    const runningTask = cancellable;
    cancellable.promise.then((nextOutline) => {
      outlineDispatch({ type: "RESOLVE", value: nextOutline });
    }).catch((error) => {
      outlineDispatch({ type: "REJECT", error });
    });
    return () => cancelRunningTask(runningTask);
  }, [outlineDispatch, pdf]);
  (0, import_react8.useEffect)(() => {
    if (outline === void 0) {
      return;
    }
    if (outline === false) {
      onLoadError();
      return;
    }
    onLoadSuccess();
  }, [outline]);
  const childContext = (0, import_react8.useMemo)(() => ({
    onItemClick
  }), [onItemClick]);
  const eventProps = (0, import_react8.useMemo)(
    () => makeEventProps(otherProps, () => outline),
    // biome-ignore lint/correctness/useExhaustiveDependencies: FIXME
    [otherProps, outline]
  );
  if (!outline) {
    return null;
  }
  function renderOutline() {
    if (!outline) {
      return null;
    }
    return (0, import_jsx_runtime4.jsx)("ul", { children: outline.map((item, itemIndex) => (0, import_jsx_runtime4.jsx)(OutlineItem, { item, pdf }, typeof item.dest === "string" ? item.dest : itemIndex)) });
  }
  return (0, import_jsx_runtime4.jsx)("div", { className: clsx_default("react-pdf__Outline", className), ref: inputRef, ...eventProps, children: (0, import_jsx_runtime4.jsx)(OutlineContext_default.Provider, { value: childContext, children: renderOutline() }) });
}

// node_modules/react-pdf/dist/Page.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);

// node_modules/merge-refs/dist/index.js
function mergeRefs() {
  var inputRefs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    inputRefs[_i] = arguments[_i];
  }
  var filteredInputRefs = inputRefs.filter(Boolean);
  if (filteredInputRefs.length <= 1) {
    var firstRef = filteredInputRefs[0];
    return firstRef || null;
  }
  return function mergedRefs(ref) {
    for (var _i2 = 0, filteredInputRefs_1 = filteredInputRefs; _i2 < filteredInputRefs_1.length; _i2++) {
      var inputRef = filteredInputRefs_1[_i2];
      if (typeof inputRef === "function") {
        inputRef(ref);
      } else if (inputRef) {
        inputRef.current = ref;
      }
    }
  };
}

// node_modules/react-pdf/dist/Page.js
var import_warning8 = __toESM(require_warning(), 1);

// node_modules/react-pdf/dist/Page/AnnotationLayer.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_warning4 = __toESM(require_warning(), 1);

// node_modules/react-pdf/dist/shared/hooks/usePageContext.js
var import_react10 = __toESM(require_react(), 1);

// node_modules/react-pdf/dist/PageContext.js
var import_react9 = __toESM(require_react(), 1);
var pageContext = (0, import_react9.createContext)(null);
var PageContext_default = pageContext;

// node_modules/react-pdf/dist/shared/hooks/usePageContext.js
function usePageContext() {
  return (0, import_react10.useContext)(PageContext_default);
}

// node_modules/react-pdf/dist/Page/AnnotationLayer.js
function AnnotationLayer2() {
  const documentContext2 = useDocumentContext();
  const pageContext2 = usePageContext();
  invariant(pageContext2, "Unable to find Page context.");
  const mergedProps = { ...documentContext2, ...pageContext2 };
  const { filterAnnotations, imageResourcesPath, linkService, onGetAnnotationsError: onGetAnnotationsErrorProps, onGetAnnotationsSuccess: onGetAnnotationsSuccessProps, onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps, onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps, page, pdf, renderForms, rotate, scale = 1 } = mergedProps;
  invariant(pdf, "Attempted to load page annotations, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop.");
  invariant(page, "Attempted to load page annotations, but no page was specified.");
  invariant(linkService, "Attempted to load page annotations, but no linkService was specified.");
  const [annotationsState, annotationsDispatch] = useResolver();
  const { value: annotations, error: annotationsError } = annotationsState;
  const layerElement = (0, import_react11.useRef)(null);
  (0, import_warning4.default)(Number.parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-annotation-layer"), 10) === 1, "AnnotationLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-annotations");
  function onLoadSuccess() {
    if (!annotations) {
      return;
    }
    if (onGetAnnotationsSuccessProps) {
      onGetAnnotationsSuccessProps(annotations);
    }
  }
  function onLoadError() {
    if (!annotationsError) {
      return;
    }
    (0, import_warning4.default)(false, annotationsError.toString());
    if (onGetAnnotationsErrorProps) {
      onGetAnnotationsErrorProps(annotationsError);
    }
  }
  (0, import_react11.useEffect)(function resetAnnotations() {
    annotationsDispatch({ type: "RESET" });
  }, [annotationsDispatch, page]);
  (0, import_react11.useEffect)(function loadAnnotations() {
    if (!page) {
      return;
    }
    const cancellable = makeCancellablePromise(page.getAnnotations());
    const runningTask = cancellable;
    cancellable.promise.then((nextAnnotations) => {
      annotationsDispatch({ type: "RESOLVE", value: nextAnnotations });
    }).catch((error) => {
      annotationsDispatch({ type: "REJECT", error });
    });
    return () => {
      cancelRunningTask(runningTask);
    };
  }, [annotationsDispatch, page]);
  (0, import_react11.useEffect)(() => {
    if (annotations === void 0) {
      return;
    }
    if (annotations === false) {
      onLoadError();
      return;
    }
    onLoadSuccess();
  }, [annotations]);
  function onRenderSuccess() {
    if (onRenderAnnotationLayerSuccessProps) {
      onRenderAnnotationLayerSuccessProps();
    }
  }
  function onRenderError(error) {
    (0, import_warning4.default)(false, `${error}`);
    if (onRenderAnnotationLayerErrorProps) {
      onRenderAnnotationLayerErrorProps(error);
    }
  }
  const viewport = (0, import_react11.useMemo)(() => page.getViewport({ scale, rotation: rotate }), [page, rotate, scale]);
  (0, import_react11.useEffect)(function renderAnnotationLayer() {
    if (!pdf || !page || !linkService || !annotations) {
      return;
    }
    const { current: layer } = layerElement;
    if (!layer) {
      return;
    }
    const clonedViewport = viewport.clone({ dontFlip: true });
    const annotationLayerParameters = {
      accessibilityManager: null,
      // TODO: Implement this
      annotationCanvasMap: null,
      // TODO: Implement this
      annotationEditorUIManager: null,
      // TODO: Implement this
      annotationStorage: pdf.annotationStorage,
      commentManager: null,
      // TODO: Implement this
      div: layer,
      l10n: null,
      // TODO: Implement this
      linkService,
      page,
      structTreeLayer: null,
      // TODO: Implement this
      viewport: clonedViewport
    };
    const renderParameters = {
      annotations: filterAnnotations ? filterAnnotations({ annotations }) : annotations,
      annotationStorage: pdf.annotationStorage,
      div: layer,
      imageResourcesPath,
      linkService,
      page,
      renderForms,
      viewport: clonedViewport
    };
    layer.innerHTML = "";
    try {
      new AnnotationLayer(annotationLayerParameters).render(renderParameters);
      onRenderSuccess();
    } catch (error) {
      onRenderError(error);
    }
    return () => {
    };
  }, [
    annotations,
    filterAnnotations,
    imageResourcesPath,
    linkService,
    page,
    pdf,
    renderForms,
    viewport
  ]);
  return (0, import_jsx_runtime5.jsx)("div", { className: clsx_default("react-pdf__Page__annotations", "annotationLayer"), ref: layerElement });
}

// node_modules/react-pdf/dist/Page/Canvas.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);
var import_warning6 = __toESM(require_warning(), 1);

// node_modules/react-pdf/dist/StructTree.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);
var import_warning5 = __toESM(require_warning(), 1);

// node_modules/react-pdf/dist/StructTreeItem.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);

// node_modules/react-pdf/dist/shared/constants.js
var PDF_ROLE_TO_HTML_ROLE = {
  // Document level structure types
  Document: null,
  // There's a "document" role, but it doesn't make sense here.
  DocumentFragment: null,
  // Grouping level structure types
  Part: "group",
  Sect: "group",
  // XXX: There's a "section" role, but it's abstract.
  Div: "group",
  Aside: "note",
  NonStruct: "none",
  // Block level structure types
  P: null,
  // H<n>,
  H: "heading",
  Title: null,
  FENote: "note",
  // Sub-block level structure type
  Sub: "group",
  // General inline level structure types
  Lbl: null,
  Span: null,
  Em: null,
  Strong: null,
  Link: "link",
  Annot: "note",
  Form: "form",
  // Ruby and Warichu structure types
  Ruby: null,
  RB: null,
  RT: null,
  RP: null,
  Warichu: null,
  WT: null,
  WP: null,
  // List standard structure types
  L: "list",
  LI: "listitem",
  LBody: null,
  // Table standard structure types
  Table: "table",
  TR: "row",
  TH: "columnheader",
  TD: "cell",
  THead: "columnheader",
  TBody: null,
  TFoot: null,
  // Standard structure type Caption
  Caption: null,
  // Standard structure type Figure
  Figure: "figure",
  // Standard structure type Formula
  Formula: null,
  // standard structure type Artifact
  Artifact: null
};
var HEADING_PATTERN = /^H(\d+)$/;

// node_modules/react-pdf/dist/shared/structTreeUtils.js
function isPdfRole(role) {
  return role in PDF_ROLE_TO_HTML_ROLE;
}
function isStructTreeNode(node) {
  return "children" in node;
}
function isStructTreeNodeWithOnlyContentChild(node) {
  if (!isStructTreeNode(node)) {
    return false;
  }
  return node.children.length === 1 && 0 in node.children && "id" in node.children[0];
}
function getRoleAttributes(node) {
  const attributes = {};
  if (isStructTreeNode(node)) {
    const { role } = node;
    const matches = role.match(HEADING_PATTERN);
    if (matches) {
      attributes.role = "heading";
      attributes["aria-level"] = Number(matches[1]);
    } else if (isPdfRole(role)) {
      const htmlRole = PDF_ROLE_TO_HTML_ROLE[role];
      if (htmlRole) {
        attributes.role = htmlRole;
      }
    }
  }
  return attributes;
}
function getBaseAttributes(node) {
  const attributes = {};
  if (isStructTreeNode(node)) {
    if (node.alt !== void 0) {
      attributes["aria-label"] = node.alt;
    }
    if (node.lang !== void 0) {
      attributes.lang = node.lang;
    }
    if (isStructTreeNodeWithOnlyContentChild(node)) {
      const [child] = node.children;
      if (child) {
        const childAttributes = getBaseAttributes(child);
        return {
          ...attributes,
          ...childAttributes
        };
      }
    }
  } else if ("id" in node) {
    attributes["aria-owns"] = node.id;
  }
  return attributes;
}
function getAttributes(node) {
  if (!node) {
    return null;
  }
  return {
    ...getRoleAttributes(node),
    ...getBaseAttributes(node)
  };
}

// node_modules/react-pdf/dist/StructTreeItem.js
function StructTreeItem({ className, node }) {
  const attributes = (0, import_react12.useMemo)(() => getAttributes(node), [node]);
  const children = (0, import_react12.useMemo)(() => {
    if (!isStructTreeNode(node)) {
      return null;
    }
    if (isStructTreeNodeWithOnlyContentChild(node)) {
      return null;
    }
    return node.children.map((child, index) => {
      return (
        // biome-ignore lint/suspicious/noArrayIndexKey: index is stable here
        (0, import_jsx_runtime6.jsx)(StructTreeItem, { node: child }, index)
      );
    });
  }, [node]);
  return (0, import_jsx_runtime6.jsx)("span", { className, ...attributes, children });
}

// node_modules/react-pdf/dist/StructTree.js
function StructTree() {
  const pageContext2 = usePageContext();
  invariant(pageContext2, "Unable to find Page context.");
  const { onGetStructTreeError: onGetStructTreeErrorProps, onGetStructTreeSuccess: onGetStructTreeSuccessProps } = pageContext2;
  const [structTreeState, structTreeDispatch] = useResolver();
  const { value: structTree, error: structTreeError } = structTreeState;
  const { customTextRenderer, page } = pageContext2;
  function onLoadSuccess() {
    if (!structTree) {
      return;
    }
    if (onGetStructTreeSuccessProps) {
      onGetStructTreeSuccessProps(structTree);
    }
  }
  function onLoadError() {
    if (!structTreeError) {
      return;
    }
    (0, import_warning5.default)(false, structTreeError.toString());
    if (onGetStructTreeErrorProps) {
      onGetStructTreeErrorProps(structTreeError);
    }
  }
  (0, import_react13.useEffect)(function resetStructTree() {
    structTreeDispatch({ type: "RESET" });
  }, [structTreeDispatch, page]);
  (0, import_react13.useEffect)(function loadStructTree() {
    if (customTextRenderer) {
      return;
    }
    if (!page) {
      return;
    }
    const cancellable = makeCancellablePromise(page.getStructTree());
    const runningTask = cancellable;
    cancellable.promise.then((nextStructTree) => {
      structTreeDispatch({ type: "RESOLVE", value: nextStructTree });
    }).catch((error) => {
      structTreeDispatch({ type: "REJECT", error });
    });
    return () => cancelRunningTask(runningTask);
  }, [customTextRenderer, page, structTreeDispatch]);
  (0, import_react13.useEffect)(() => {
    if (structTree === void 0) {
      return;
    }
    if (structTree === false) {
      onLoadError();
      return;
    }
    onLoadSuccess();
  }, [structTree]);
  if (!structTree) {
    return null;
  }
  return (0, import_jsx_runtime7.jsx)(StructTreeItem, { className: "react-pdf__Page__structTree structTree", node: structTree });
}

// node_modules/react-pdf/dist/Page/Canvas.js
var ANNOTATION_MODE = AnnotationMode;
function Canvas(props) {
  const pageContext2 = usePageContext();
  invariant(pageContext2, "Unable to find Page context.");
  const mergedProps = { ...pageContext2, ...props };
  const { _className, canvasBackground, devicePixelRatio = getDevicePixelRatio(), onRenderError: onRenderErrorProps, onRenderSuccess: onRenderSuccessProps, page, renderForms, renderTextLayer, rotate, scale } = mergedProps;
  const { canvasRef } = props;
  invariant(page, "Attempted to render page canvas, but no page was specified.");
  const canvasElement = (0, import_react14.useRef)(null);
  function onRenderSuccess() {
    if (!page) {
      return;
    }
    if (onRenderSuccessProps) {
      onRenderSuccessProps(makePageCallback(page, scale));
    }
  }
  function onRenderError(error) {
    if (isAbortException(error)) {
      return;
    }
    (0, import_warning6.default)(false, error.toString());
    if (onRenderErrorProps) {
      onRenderErrorProps(error);
    }
  }
  const renderViewport = (0, import_react14.useMemo)(() => page.getViewport({ scale: scale * devicePixelRatio, rotation: rotate }), [devicePixelRatio, page, rotate, scale]);
  const viewport = (0, import_react14.useMemo)(() => page.getViewport({ scale, rotation: rotate }), [page, rotate, scale]);
  (0, import_react14.useEffect)(function drawPageOnCanvas() {
    if (!page) {
      return;
    }
    page.cleanup();
    const { current: canvas } = canvasElement;
    if (!canvas) {
      return;
    }
    canvas.width = renderViewport.width;
    canvas.height = renderViewport.height;
    canvas.style.width = `${Math.floor(viewport.width)}px`;
    canvas.style.height = `${Math.floor(viewport.height)}px`;
    canvas.style.visibility = "hidden";
    const renderContext = {
      annotationMode: renderForms ? ANNOTATION_MODE.ENABLE_FORMS : ANNOTATION_MODE.ENABLE,
      canvas,
      canvasContext: canvas.getContext("2d", { alpha: false }),
      viewport: renderViewport
    };
    if (canvasBackground) {
      renderContext.background = canvasBackground;
    }
    const cancellable = page.render(renderContext);
    const runningTask = cancellable;
    cancellable.promise.then(() => {
      canvas.style.visibility = "";
      onRenderSuccess();
    }).catch(onRenderError);
    return () => cancelRunningTask(runningTask);
  }, [canvasBackground, page, renderForms, renderViewport, viewport]);
  const cleanup = (0, import_react14.useCallback)(() => {
    const { current: canvas } = canvasElement;
    if (canvas) {
      canvas.width = 0;
      canvas.height = 0;
    }
  }, []);
  (0, import_react14.useEffect)(() => cleanup, [cleanup]);
  return (0, import_jsx_runtime8.jsx)("canvas", { className: `${_className}__canvas`, dir: "ltr", ref: mergeRefs(canvasRef, canvasElement), style: {
    display: "block",
    userSelect: "none"
  }, children: renderTextLayer ? (0, import_jsx_runtime8.jsx)(StructTree, {}) : null });
}

// node_modules/react-pdf/dist/Page/TextLayer.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);
var import_warning7 = __toESM(require_warning(), 1);
function isTextItem(item) {
  return "str" in item;
}
function TextLayer2() {
  const pageContext2 = usePageContext();
  invariant(pageContext2, "Unable to find Page context.");
  const { customTextRenderer, onGetTextError, onGetTextSuccess, onRenderTextLayerError, onRenderTextLayerSuccess, page, pageIndex, pageNumber, rotate, scale } = pageContext2;
  invariant(page, "Attempted to load page text content, but no page was specified.");
  const [textContentState, textContentDispatch] = useResolver();
  const { value: textContent, error: textContentError } = textContentState;
  const layerElement = (0, import_react15.useRef)(null);
  (0, import_warning7.default)(Number.parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-text-layer"), 10) === 1, "TextLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-text-layer");
  function onLoadSuccess() {
    if (!textContent) {
      return;
    }
    if (onGetTextSuccess) {
      onGetTextSuccess(textContent);
    }
  }
  function onLoadError() {
    if (!textContentError) {
      return;
    }
    (0, import_warning7.default)(false, textContentError.toString());
    if (onGetTextError) {
      onGetTextError(textContentError);
    }
  }
  (0, import_react15.useEffect)(function resetTextContent() {
    textContentDispatch({ type: "RESET" });
  }, [page, textContentDispatch]);
  (0, import_react15.useEffect)(function loadTextContent() {
    if (!page) {
      return;
    }
    const cancellable = makeCancellablePromise(page.getTextContent());
    const runningTask = cancellable;
    cancellable.promise.then((nextTextContent) => {
      textContentDispatch({ type: "RESOLVE", value: nextTextContent });
    }).catch((error) => {
      textContentDispatch({ type: "REJECT", error });
    });
    return () => cancelRunningTask(runningTask);
  }, [page, textContentDispatch]);
  (0, import_react15.useEffect)(() => {
    if (textContent === void 0) {
      return;
    }
    if (textContent === false) {
      onLoadError();
      return;
    }
    onLoadSuccess();
  }, [textContent]);
  const onRenderSuccess = (0, import_react15.useCallback)(() => {
    if (onRenderTextLayerSuccess) {
      onRenderTextLayerSuccess();
    }
  }, [onRenderTextLayerSuccess]);
  const onRenderError = (0, import_react15.useCallback)((error) => {
    if (isAbortException(error)) {
      return;
    }
    (0, import_warning7.default)(false, error.toString());
    if (onRenderTextLayerError) {
      onRenderTextLayerError(error);
    }
  }, [onRenderTextLayerError]);
  function onMouseDown() {
    const layer = layerElement.current;
    if (!layer) {
      return;
    }
    layer.classList.add("selecting");
  }
  function onMouseUp() {
    const layer = layerElement.current;
    if (!layer) {
      return;
    }
    layer.classList.remove("selecting");
  }
  const viewport = (0, import_react15.useMemo)(() => page.getViewport({ scale, rotation: rotate }), [page, rotate, scale]);
  (0, import_react15.useLayoutEffect)(function renderTextLayer() {
    if (!page || !textContent) {
      return;
    }
    const { current: layer } = layerElement;
    if (!layer) {
      return;
    }
    layer.innerHTML = "";
    const textContentSource = page.streamTextContent({ includeMarkedContent: true });
    const parameters = {
      container: layer,
      textContentSource,
      viewport
    };
    const cancellable = new TextLayer(parameters);
    const runningTask = cancellable;
    cancellable.render().then(() => {
      const end = document.createElement("div");
      end.className = "endOfContent";
      layer.append(end);
      const layerChildren = layer.querySelectorAll('[role="presentation"]');
      if (customTextRenderer) {
        let index = 0;
        textContent.items.forEach((item, itemIndex) => {
          if (!isTextItem(item)) {
            return;
          }
          const child = layerChildren[index];
          if (!child) {
            return;
          }
          const content = customTextRenderer({
            pageIndex,
            pageNumber,
            itemIndex,
            ...item
          });
          child.innerHTML = content;
          index += item.str && item.hasEOL ? 2 : 1;
        });
      }
      onRenderSuccess();
    }).catch(onRenderError);
    return () => cancelRunningTask(runningTask);
  }, [
    customTextRenderer,
    onRenderError,
    onRenderSuccess,
    page,
    pageIndex,
    pageNumber,
    textContent,
    viewport
  ]);
  return (
    // biome-ignore lint/a11y/noStaticElementInteractions: False positive caused by non interactive wrapper listening for bubbling events
    (0, import_jsx_runtime9.jsx)("div", { className: clsx_default("react-pdf__Page__textContent", "textLayer"), onMouseUp, onMouseDown, ref: layerElement })
  );
}

// node_modules/react-pdf/dist/Page.js
var defaultScale = 1;
function Page(props) {
  const documentContext2 = useDocumentContext();
  const mergedProps = { ...documentContext2, ...props };
  const { _className = "react-pdf__Page", _enableRegisterUnregisterPage = true, canvasBackground, canvasRef, children, className, customRenderer: CustomRenderer, customTextRenderer, devicePixelRatio, error = "Failed to load the page.", filterAnnotations, height, inputRef, loading = "Loading page…", noData = "No page specified.", onGetAnnotationsError: onGetAnnotationsErrorProps, onGetAnnotationsSuccess: onGetAnnotationsSuccessProps, onGetStructTreeError: onGetStructTreeErrorProps, onGetStructTreeSuccess: onGetStructTreeSuccessProps, onGetTextError: onGetTextErrorProps, onGetTextSuccess: onGetTextSuccessProps, onLoadError: onLoadErrorProps, onLoadSuccess: onLoadSuccessProps, onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps, onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps, onRenderError: onRenderErrorProps, onRenderSuccess: onRenderSuccessProps, onRenderTextLayerError: onRenderTextLayerErrorProps, onRenderTextLayerSuccess: onRenderTextLayerSuccessProps, pageIndex: pageIndexProps, pageNumber: pageNumberProps, pdf, registerPage, renderAnnotationLayer: renderAnnotationLayerProps = true, renderForms = false, renderMode = "canvas", renderTextLayer: renderTextLayerProps = true, rotate: rotateProps, scale: scaleProps = defaultScale, unregisterPage, width, ...otherProps } = mergedProps;
  const [pageState, pageDispatch] = useResolver();
  const { value: page, error: pageError } = pageState;
  const pageElement = (0, import_react16.useRef)(null);
  invariant(pdf, "Attempted to load a page, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop.");
  const pageIndex = isProvided(pageNumberProps) ? pageNumberProps - 1 : pageIndexProps !== null && pageIndexProps !== void 0 ? pageIndexProps : null;
  const pageNumber = pageNumberProps !== null && pageNumberProps !== void 0 ? pageNumberProps : isProvided(pageIndexProps) ? pageIndexProps + 1 : null;
  const rotate = rotateProps !== null && rotateProps !== void 0 ? rotateProps : page ? page.rotate : null;
  const scale = (0, import_react16.useMemo)(() => {
    if (!page) {
      return null;
    }
    let pageScale = 1;
    const scaleWithDefault = scaleProps !== null && scaleProps !== void 0 ? scaleProps : defaultScale;
    if (width || height) {
      const viewport = page.getViewport({ scale: 1, rotation: rotate });
      if (width) {
        pageScale = width / viewport.width;
      } else if (height) {
        pageScale = height / viewport.height;
      }
    }
    return scaleWithDefault * pageScale;
  }, [height, page, rotate, scaleProps, width]);
  (0, import_react16.useEffect)(function hook() {
    return () => {
      if (!isProvided(pageIndex)) {
        return;
      }
      if (_enableRegisterUnregisterPage && unregisterPage) {
        unregisterPage(pageIndex);
      }
    };
  }, [_enableRegisterUnregisterPage, pdf, pageIndex, unregisterPage]);
  function onLoadSuccess() {
    if (onLoadSuccessProps) {
      if (!page || !scale) {
        return;
      }
      onLoadSuccessProps(makePageCallback(page, scale));
    }
    if (_enableRegisterUnregisterPage && registerPage) {
      if (!isProvided(pageIndex) || !pageElement.current) {
        return;
      }
      registerPage(pageIndex, pageElement.current);
    }
  }
  function onLoadError() {
    if (!pageError) {
      return;
    }
    (0, import_warning8.default)(false, pageError.toString());
    if (onLoadErrorProps) {
      onLoadErrorProps(pageError);
    }
  }
  (0, import_react16.useEffect)(function resetPage() {
    pageDispatch({ type: "RESET" });
  }, [pageDispatch, pdf, pageIndex]);
  (0, import_react16.useEffect)(function loadPage() {
    if (!pdf || !pageNumber) {
      return;
    }
    const cancellable = makeCancellablePromise(pdf.getPage(pageNumber));
    const runningTask = cancellable;
    cancellable.promise.then((nextPage) => {
      pageDispatch({ type: "RESOLVE", value: nextPage });
    }).catch((error2) => {
      pageDispatch({ type: "REJECT", error: error2 });
    });
    return () => cancelRunningTask(runningTask);
  }, [pageDispatch, pdf, pageNumber]);
  (0, import_react16.useEffect)(() => {
    if (page === void 0) {
      return;
    }
    if (page === false) {
      onLoadError();
      return;
    }
    onLoadSuccess();
  }, [page, scale]);
  const childContext = (0, import_react16.useMemo)(() => (
    // Technically there cannot be page without pageIndex, pageNumber, rotate and scale, but TypeScript doesn't know that
    isProvided(pageIndex) && pageNumber && isProvided(rotate) && isProvided(scale) ? {
      _className,
      canvasBackground,
      customTextRenderer,
      devicePixelRatio,
      filterAnnotations,
      onGetAnnotationsError: onGetAnnotationsErrorProps,
      onGetAnnotationsSuccess: onGetAnnotationsSuccessProps,
      onGetStructTreeError: onGetStructTreeErrorProps,
      onGetStructTreeSuccess: onGetStructTreeSuccessProps,
      onGetTextError: onGetTextErrorProps,
      onGetTextSuccess: onGetTextSuccessProps,
      onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps,
      onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps,
      onRenderError: onRenderErrorProps,
      onRenderSuccess: onRenderSuccessProps,
      onRenderTextLayerError: onRenderTextLayerErrorProps,
      onRenderTextLayerSuccess: onRenderTextLayerSuccessProps,
      page,
      pageIndex,
      pageNumber,
      renderForms,
      renderTextLayer: renderTextLayerProps,
      rotate,
      scale
    } : null
  ), [
    _className,
    canvasBackground,
    customTextRenderer,
    devicePixelRatio,
    filterAnnotations,
    onGetAnnotationsErrorProps,
    onGetAnnotationsSuccessProps,
    onGetStructTreeErrorProps,
    onGetStructTreeSuccessProps,
    onGetTextErrorProps,
    onGetTextSuccessProps,
    onRenderAnnotationLayerErrorProps,
    onRenderAnnotationLayerSuccessProps,
    onRenderErrorProps,
    onRenderSuccessProps,
    onRenderTextLayerErrorProps,
    onRenderTextLayerSuccessProps,
    page,
    pageIndex,
    pageNumber,
    renderForms,
    renderTextLayerProps,
    rotate,
    scale
  ]);
  const eventProps = (0, import_react16.useMemo)(
    () => makeEventProps(otherProps, () => page ? scale ? makePageCallback(page, scale) : void 0 : page),
    // biome-ignore lint/correctness/useExhaustiveDependencies: FIXME
    [otherProps, page, scale]
  );
  const pageKey = `${pageIndex}@${scale}/${rotate}`;
  function renderMainLayer() {
    switch (renderMode) {
      case "custom": {
        invariant(CustomRenderer, `renderMode was set to "custom", but no customRenderer was passed.`);
        return (0, import_jsx_runtime10.jsx)(CustomRenderer, {}, `${pageKey}_custom`);
      }
      case "none":
        return null;
      case "canvas":
      default:
        return (0, import_jsx_runtime10.jsx)(Canvas, { canvasRef }, `${pageKey}_canvas`);
    }
  }
  function renderTextLayer() {
    if (!renderTextLayerProps) {
      return null;
    }
    return (0, import_jsx_runtime10.jsx)(TextLayer2, {}, `${pageKey}_text`);
  }
  function renderAnnotationLayer() {
    if (!renderAnnotationLayerProps) {
      return null;
    }
    return (0, import_jsx_runtime10.jsx)(AnnotationLayer2, {}, `${pageKey}_annotations`);
  }
  function renderChildren() {
    function isFulfilledContext(context) {
      return Boolean(context === null || context === void 0 ? void 0 : context.page);
    }
    if (!isFulfilledContext(childContext)) {
      throw new Error("page is undefined");
    }
    const resolvedChildren = typeof children === "function" ? children(childContext) : children;
    return (0, import_jsx_runtime10.jsxs)(PageContext_default.Provider, { value: childContext, children: [renderMainLayer(), renderTextLayer(), renderAnnotationLayer(), resolvedChildren] });
  }
  function renderContent() {
    if (!pageNumber) {
      return (0, import_jsx_runtime10.jsx)(Message, { type: "no-data", children: typeof noData === "function" ? noData() : noData });
    }
    if (pdf === null || page === void 0 || page === null) {
      return (0, import_jsx_runtime10.jsx)(Message, { type: "loading", children: typeof loading === "function" ? loading() : loading });
    }
    if (pdf === false || page === false) {
      return (0, import_jsx_runtime10.jsx)(Message, { type: "error", children: typeof error === "function" ? error() : error });
    }
    return renderChildren();
  }
  return (0, import_jsx_runtime10.jsx)("div", {
    className: clsx_default(_className, className),
    "data-page-number": pageNumber,
    // Assertion is needed for React 18 compatibility
    ref: mergeRefs(inputRef, pageElement),
    style: {
      "--scale-round-x": "1px",
      "--scale-round-y": "1px",
      "--scale-factor": "1",
      "--user-unit": `${scale}`,
      "--total-scale-factor": "calc(var(--scale-factor) * var(--user-unit))",
      backgroundColor: canvasBackground || "white",
      position: "relative",
      minWidth: "min-content",
      minHeight: "min-content"
    },
    ...eventProps,
    children: renderContent()
  });
}

// node_modules/react-pdf/dist/Thumbnail.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
function Thumbnail(props) {
  const documentContext2 = useDocumentContext();
  const mergedProps = { ...documentContext2, ...props };
  const { className, linkService, onItemClick, pageIndex: pageIndexProps, pageNumber: pageNumberProps, pdf } = mergedProps;
  invariant(pdf, "Attempted to load a thumbnail, but no document was specified. Wrap <Thumbnail /> in a <Document /> or pass explicit `pdf` prop.");
  const pageIndex = isProvided(pageNumberProps) ? pageNumberProps - 1 : pageIndexProps !== null && pageIndexProps !== void 0 ? pageIndexProps : null;
  const pageNumber = pageNumberProps !== null && pageNumberProps !== void 0 ? pageNumberProps : isProvided(pageIndexProps) ? pageIndexProps + 1 : null;
  function onClick(event) {
    event.preventDefault();
    if (!isProvided(pageIndex) || !pageNumber) {
      return;
    }
    invariant(onItemClick || linkService, "Either onItemClick callback or linkService must be defined in order to navigate to an outline item.");
    if (onItemClick) {
      onItemClick({
        pageIndex,
        pageNumber
      });
    } else if (linkService) {
      linkService.goToPage(pageNumber);
    }
  }
  const { className: classNameProps, onItemClick: onItemClickProps, ...pageProps } = props;
  return (0, import_jsx_runtime11.jsx)("a", { className: clsx_default("react-pdf__Thumbnail", className), href: pageNumber ? "#" : void 0, onClick, children: (0, import_jsx_runtime11.jsx)(Page, { ...pageProps, _className: "react-pdf__Thumbnail__page", _enableRegisterUnregisterPage: false, renderAnnotationLayer: false, renderTextLayer: false }) });
}

// node_modules/react-pdf/dist/index.js
displayWorkerWarning();
GlobalWorkerOptions.workerSrc = "pdf.worker.mjs";
export {
  Document_default as Document,
  Outline2 as Outline,
  Page,
  PasswordResponses_default as PasswordResponses,
  Thumbnail,
  pdf_exports as pdfjs,
  useDocumentContext,
  useOutlineContext,
  usePageContext
};
//# sourceMappingURL=react-pdf.js.map
